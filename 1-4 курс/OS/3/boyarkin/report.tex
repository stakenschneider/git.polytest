\documentclass[14pt,a4paper,report]{report}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{listings} 
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{graphicx}
\hypersetup{
	colorlinks = true,
	linkcolor  = black
}

\usepackage{titlesec}
\titleformat{\chapter}
{\Large\bfseries} % format
{}                % label
{0pt}             % sep
{\huge}           % before-code


\DeclareCaptionFont{white}{\color{white}} 

% Listing description
\usepackage{listings} 
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{ 
	% Listing settings
	inputencoding = utf8,			
	extendedchars = \true, 
	keepspaces = true, 			  	 % Поддержка кириллицы и пробелов в комментариях
	language = C,            	 	 % Язык программирования (для подсветки)
	basicstyle = \small\sffamily, 	 % Размер и начертание шрифта для подсветки кода
	numbers = left,               	 % Где поставить нумерацию строк (слева\справа)
	numberstyle = \tiny,          	 % Размер шрифта для номеров строк
	stepnumber = 1,               	 % Размер шага между двумя номерами строк
	numbersep = 5pt,              	 % Как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor = \color{white}, % Цвет фона подсветки - используем \usepackage{color}
	showspaces = false,           	 % Показывать или нет пробелы специальными отступами
	showstringspaces = false,    	 % Показывать или нет пробелы в строках
	showtabs = false,           	 % Показывать или нет табуляцию в строках
	frame = single,              	 % Рисовать рамку вокруг кода
	tabsize = 2,                  	 % Размер табуляции по умолчанию равен 2 пробелам
	captionpos = t,             	 % Позиция заголовка вверху [t] или внизу [b] 
	breaklines = true,           	 % Автоматически переносить строки (да\нет)
	breakatwhitespace = false,   	 % Переносить строки только если есть пробел
	escapeinside = {\%*}{*)}      	 % Если нужно добавить комментарии в коде
}

\begin{document}

\def\contentsname{Содержание}

% Titlepage
\begin{titlepage}
	\begin{center}
		\textsc{Санкт-Петербургский Политехнический 
			Университет Петра Великого\\[5mm]
			Кафедра компьютерных систем и программных технологий}
		
		\vfill
		
		\textbf{Отчёт по лабораторной работе №3\\[3mm]
			Курс: «Операционные системы»\\[6mm]
			Тема: «Процессы UNIX»\\[35mm]
		}
	\end{center}
	
	\hfill
	\begin{minipage}{.5\textwidth}
		Выполнил студент:\\[2mm] 
		Бояркин Никита Сергеевич\\
		Группа: 43501/3\\[5mm]
		
		Проверил:\\[2mm] 
		Душутина Елена Владимировна
	\end{minipage}
	\vfill
	\begin{center}
		Санкт-Петербург\\ \the\year\ г.
	\end{center}
\end{titlepage}

% Contents
\tableofcontents
\clearpage

\chapter{Лабораторная работа №3}

\section{Цель работы}

Изучить принципы управления и порождения процессов, создания потоков в ОС Linux.

\section{Программа работы}

\subsubsection{Глава 1. Порождение и запуск процессов}

\begin{enumerate}
	\item Создание программы на основе исходного файла с псевдораспараллеливанием вычислений, посредством порождения процесса-потомка.
	\item Выполнить сначала однократные вычисления в каждом процессе, обратить внимание, какой процесс на каком этапе владеет процессорным ресурсом.
	\item Однократные вычисления заменить на циклы, длительность исполнения которых достаточна для наблюдения конкуренции процессов за процессорный ресурс.
	\item Изменить процедуру планирования и повторить эксперимент.
	\item Разработать программы родителя и потомка parent.c и child.c, с фиксацией состояния таблицы процессов.
	\item Запустить на выполнение программу parent. Узнать о всех процессах, запущенных с этого терминала.
	\item Запустить на выполнение программу parent в фоновом режиме. Получение таблицы процессов, запущенных с терминала.
	\item Выполнить создание процессов с использованием различных функций семейства exec(), привести результаты эксперимента.
	\item Проанализируйте значение, возвращаемое функцией wait(\&status). Предложите эксперимент, позволяющий родителю отслеживать подмножество порожденных потомков, используя различные функции семейства wait().
	\item Проанализируйте очередность исполнения процессов, порожденных вложенными вызовами fork().
	\begin{enumerate}
		\item Проанализируйте очередность исполнения процессов, порожденных вложенными вызовами fork().
		\item Измените процедуру планирования с помощью функции с шаблоном scheduler в ее названии и повторите эксперимент.
		\item Поменяйте порядок очереди в RR-процедуре.
		\item Можно ли задать разные процедуры планирования разным процессам с одинаковыми приоритетами. Как они будут конкурировать, подтвердите экспериментально.
	\end{enumerate}
	\item Определите величину кванта. Можно ли ее поменять? – для обоснования проведите эксперимент.
	\item Проанализируйте наследование на этапах fork() и exec(). Проведите эксперимент с родителем и потомками по доступу к одним и тем же файлам, открытым родителем. Аналогичные эксперименты проведите по отношению к другим параметрам.	
\end{enumerate}

\subsubsection{Глава 2. Взаимодействие родственных процессов}

\begin{enumerate}
	\item Изменяя длительности выполнения процессов и параметры системных вызовов, рассмотреть 3 ситуации и вывести соответствующие таблицы процессов.
	\begin{enumerate}
		\item Процесс-предок запускает процесс-потомок и ожидает его завершения.
		\item Процесс-предок запускает процесс-потомок и, не ожидая его завершения, завершает свое выполнение. Зафиксируйте изменение родительского идентификатора процесса-потомка.
		\item Процесс-предок запускает процесс-сын и не ожидает его завершения. Процесс-предок завершает свое выполнение. Зафиксируйте появление процесса-зомби, для этого включите команду ps в программу parent.c
	\end{enumerate}
	\item Перенаправьте вывод не только на терминал, но и в файл. Организуйте программу многопроцессного функционирования так, чтобы результатом ее работы была демонстрация всех трех ситуаций с отображением в итоговом файле.
\end{enumerate}

\subsubsection{Глава 3. Управление процессами посредством сигналов}

\begin{enumerate}
	\item С помощью команды kill -l ознакомьтесь с перечнем сигналов, поддерживаемых процессами.
	\begin{enumerate}
		\item Процесс parent порождает процессы child1, child2, child3 и запускает на исполнение программные коды из соответствующих исполнительных файлов.
		\item Далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу.
		\item В пользовательских процессах-потомках необходимо обеспечить: для child1 - реакцию на сигнал по умолчанию; для child2 - реакцию игнорирования; для child3 - перехватывание и обработку сигнала. Сформируйте файл-проект из четырех файлов, откомпилируйте, запустите программу.
	\end{enumerate}
	\item Организуйте посылку сигналов любым двум процессам, находящимся в разных состояниях: активном и пассивном, фиксируя моменты посылки и приема каждого сигнала с точностью до секунды. Приведите результаты в файле результатов.
	\item Запустите в фоновом режиме несколько утилит, например: cat *.c > myprog \& lpr myprog \& lpr intro\&. Воспользуйтесь командой jobs для анализа списка заданий и очередности их выполнения.
	\item Ознакомьтесь с выполнением команды и системного вызова nice(1) и getpriority(2). Приведите примеры их использования в приложении. Определите границы приоритетов (создайте для этого программу).
	\item Ознакомьтесь с командой nohup(1). Запустите длительный процесс по nohup(1). Завершите сеанс работы. Снова войдите в систему и проверьте таблицу процессов. Поясните результат.
	\item Определите uid процесса, каково минимальное значение и кому оно принадлежит. Каково минимальное и максимальное значение pid, каким процессам принадлежат. Проанализируйте множество системных процессов, как их отличить от прочих, перечислите назначение самых важных из них.
\end{enumerate}

\subsubsection{Глава 4. Многопоточное функционирование}

\begin{enumerate}
	\item Подготовьте программу, формирующую несколько потоков. Каждый поток выводит сообщение с разными интервалами.
	\item После запуска программы проанализируйте выполнение нитей, распределение во времени. Используйте для этого вывод таблицы процессов командой ps -axhf. Попробуйте удалить нить, зная ее идентификатор, командой kill.
	\item Модифицируйте программу так, чтобы управление второй нитью осуществлялось посредством сигнала SIGUSR1 из первой нити. На пятой секунде работы приложения удалите вторую нить. Для этого воспользуйтесь функцией pthread\_kill(t2, SIGUSR1); (t2 - дескриптор второй нити). В остальном программу можно не изменять.
	\item Последняя модификация предполагает создание собственного обработчика сигнала, содержащего уведомление о начале его работы и возврат посредством функции pthread\_exit(NULL). Сравните результаты, полученные после запуска этой модификации программы с результатами предыдущей.
	\item Перехватите сигнал «CTRL+C» для процесса и потока однократно и многократно с восстановлением исходного обработчика после нескольких раз срабатывания. Проделайте аналогичную работу для переназначения другой комбинации клавиш.
	\item С помощью утилиты kill выведите список всех сигналов и дайте их краткую характеристику на основе документации ОС. Для чего предназначены сигналы с 32 по 64-й.
	\item Проанализируйте процедуру планирования для процессов и потоков одного процесса. Обоснуйте результат экспериментально. Попробуйте процедуру планирования изменить. Подтвердите экспериментально, если изменение возможно. Задайте нитям разные приоритеты программно и извне (объясните результат).
	\item Создайте скрипт, выполняющий вашу лабораторную работу автоматически при наличии необходимых исходных файлов.
\end{enumerate}


\section{Характеристики системы}

Некоторая информация об операционной системе и текущем пользователе:

\lstinputlisting{listings/0.my.log}

Информация об операционной системе и текущем пользователе компьютера в лаборатории:

\lstinputlisting{listings/0.lab.log}

На домашнем и лабораторном компьютерах установлены реальные системы.

\section{Ход работы}

\subsection{Глава 1. Порождение и запуск процессов}

\subsubsection{Создание функции, перераспределяющей ресурсы процессора на одно ядро}

Для отображения корректного результата в условиях многопоточных возможностей процессора, разработаем функцию, перераспределяющую ресурсы процессора на одно ядро:

\lstinputlisting{listings/singlecore.c}

Заголовочный файл для функции:

\lstinputlisting{listings/singlecore.h}

\subsubsection{1. Создание программы на основе исходного файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка}

Системный вызов fork служит для создания нового процесса в операционной системе UNIX. Процесс, который инициировал системный вызов fork , принято называть родительским процессом (\emph{parent process}). Вновь порожденный процесс принято называть процессом-потомком (\emph{child process}). Процесс-потомок является почти полной копией родительского процесса. У порожденного процесса по сравнению с родительским изменяются значения следующих параметров:

\begin{itemize}
	\item Идентификатор процесса (PID).
	\item Идентификатор родительского процесса (PPID).
	\item Время, оставшееся до получения сигнала SIGALRM.
	\item Сигналы, ожидавшие доставки родительскому процессу, не будут доставляться порожденному процессу.
\end{itemize}

Была написана простейшая программа, иллюстрирующая действие функции \emph{fork()}:

\lstinputlisting{listings/p1.1.c}

Результат работы программы:

\lstinputlisting{listings/p1.1.log}

Можно наблюдать, что \emph{PPID} процесса-потомка совпадает с \emph{PID} родительского процесса. В зависимости от возвращаемого значения функции \emph{fork} можно контролировать, какой код выполнится родителем и потомком.

\subsubsection{2. Выполнение однократных вычислений в каждом процессе}

Проведем эксперимент: процесс-родитель инкрементирует переменную, процесс-потомок декрементирует переменную. Если оба результата не изменятся (останутся равными нулю), то это значит, что родитель и потомок имеют общую память данных. Если одна переменная будет равна единице, а вторая минус единице, то процессы используют различную память данных.

Была написана простейшая программа, выполняющая вычисления в процессе-родителе и процессе-потомке:

\lstinputlisting{listings/p1.2.c}

Результат работы программы:

\lstinputlisting{listings/p1.2.log}

Результат подтвердил, что процесс-родитель и процесс-потомок используют различную память данных.

\subsubsection{3. Выполнение множественных вычислений, для наблюдения конкуренции родственных процессов}

Разработаем программу, которая выводит несколько сообщений от родителя и потомка с заданной периодичностью:

\lstinputlisting{listings/p1.3.c}

Результат выполнения программы:

\lstinputlisting{listings/p1.3.log}

В результате выполнения программы видна конкуренция процессов за процессорное время.

\subsubsection{4. Наблюдение конкуренции родственных процессов, в зависимости от алгоритма планирования}

Для изменения приоритета планирования используется функция \emph{sched\_setscheduler}, принимающая следующие аргументы:

\begin{itemize}
	\item Идентификатор процесса (PID).
	\item Политику планирования. Существует три политики планирования: \emph{SCHED\_OTHER}, \emph{SCHED\_FIFO} и \emph{SCHED\_RR}. \emph{SCHED\_OTHER} - используемый по умолчанию алгоритм со стандартным разделением времени, с которым работает большинство процессов.\emph{SCHED\_FIFO} и \emph{SCHED\_RR} предназначены для процессов, зависящих от возникновения задержек, которым необходим более четкий контроль над порядком исполнения процессов.
	\item Структуру с численным значением приоритета. Для \emph{SCHED\_OTHER} численное значение всегда нулевое. Для \emph{SCHED\_FIFO} и \emph{SCHED\_RR} численные значения варьируются от 0 до 99.
\end{itemize}

Разработаем программу, принимающую в качестве аргументов командной строки алгоритм планирования и численные значение приоритетов процесса для родителя и каждого из трех потомков:

\lstinputlisting{listings/p1.4.cpp}

Пример работы программы с алгоритмом планирования \emph{SCHED\_FIFO} (первый аргумент в командной строке 0):

\lstinputlisting{listings/p1.4.f.log}

Как только появляется более приоритетный процесс он выполняется, а все остальные ждут его завершения. В первом примере первым выполнился процесс-родитель с приоритетом 74, после этого выполнился первый потомок с приоритетом 40, потом второй потомок с приоритетом 30, потом третий потомок с приоритетом 20.

Во втором эксперименте родительский-процесс и третий потомок имеют наивысшие приоритеты, вследствие чего выполняются раньше других.

Пример работы программы с алгоритмом планирования \emph{SCHED\_RR} (первый аргумент в командной строке 1):

\lstinputlisting{listings/p1.4.r.log}

Результаты \emph{SCHED\_RR} аналогичны \emph{SCHED\_FIFO}.

Пример работы программы с алгоритмом планирования \emph{SCHED\_OTHER} (первый аргумент в командной строке 2):

\lstinputlisting{listings/p1.4.o.log}

При политике \emph{SCHED\_OTHER} все процессы выполняются в стандартной последовательности.

\subsubsection{5-7. Разработка программ родителя и потомка с фиксацией состояния таблицы процессов}

Разработаем программу родителя, которая вызывает другую программу в процессе-потомке. Для запуска программы используется функция \emph{execl}, для системного вызова - функция \emph{system}, для ожидания завершения процесса-потомка используется функция \emph{wait}:

\lstinputlisting{listings/parent.c}

Программа потомок:

\lstinputlisting{listings/child.c}

Вывод программы до добавления системного вызова отображения процессов:

\lstinputlisting{listings/p1.5.log}

Вывод программы после добавления системного вызова отображения процессов:

\lstinputlisting{listings/p1.6.log}

Вывод программы в фоновом режиме после добавления системного вызова отображения процессов:

\lstinputlisting{listings/p1.7.log}

Здесь можно наблюдать передачу управления командной оболочке до завершения процесса.

\subsubsection{8. Создание процессов с использованием различных функций семейства exec()}

Семейство функций \emph{exec} содержит набор функций с различными сигнатурами для запуска дочерних процессов.

Семейство \emph{exec} содержит следующие прототипы:

\begin{verbatim}
int execl(char * pathname, char * arg0, arg1, ..., argn, NULL);
int execle(char * pathname, char * arg0, arg1, ..., argn, NULL, char ** envp);
int execlp(char * pathname, char * arg0, arg1, ..., argn, NULL);
int execlpe(char *  pathname, char * arg0, arg1, ..., argn, NULL, char ** envp);
int execv(char * pathname, char * argv[]);
int execve(char * pathname, char * argv[], char ** envp);
int execvp(char * pathname, char * argv[]);
int execvpe(char * pathname, char * argv[], char ** envp);
\end{verbatim}

Суффиксы \emph{l}, \emph{v}, \emph{p} и \emph{e}, добавляемые к имени семейства \emph{exec} обозначают,   что  данная  функция  будет работать с некоторыми особенностями:

\begin{itemize}
	\item Суффикс \emph{p} - определяет, что функция будет искать дочернюю программу в директориях, определяемых переменной среды DOS PATH. Без суффикса \emph{p}  поиск будет  производиться только в рабочем каталоге.
	\item Суффикс \emph{l} - показывает, что адресные указатели (arg0, arg1, ..., argn) передаются, как отдельные аргументы. Обычно суффикс \emph{l} употребляется, когда число передаваемых аргументов заранее вам известно.
	\item Суффикс \emph{v} - показывает, что адресные указатели  (arg[0], arg[1],...arg[n]) передаются, как массив указателей. Обычно, суффикс \emph{v} используется, когда передается неизвестно число аргументов.
	\item Суффикс \emph{e} - показывает, что дочернему процессу может быть передан аргумент \emph{envp},   который позволяет выбирать среду дочернего процесса. Без суффикса \emph{e} дочерний процесс унаследует среду родительского процесса.
\end{itemize}

Разработаем программу, которая запускает программу \emph{/bin/df} с ключем \emph{-h} шестью различными функциями семейства \emph{exec}. Функция выбирается аргументом командной строки:

\lstinputlisting{listings/p1.8.cpp}

Результаты выполнения программы ожидаемо идентичен, независимо от сигнатуры функции семейства \emph{exec}:

\lstinputlisting{listings/p1.8.log}

\subsubsection{9.1. Анализ функции wait()}

Функция \emph{wait} приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются. 

Если аргумент \emph{status} не равен \emph{NULL}, то функции \emph{wait} и \emph{waitpid} сохраняют информацию о статусе в переменной, на которую указывает status. Этот статус можно проверить с помощью нижеследующих макросов:

\begin{itemize}
	\item \emph{WIFEXITED(status)} - не равно нулю, если дочерний процесс успешно завершился.
	\item \emph{WEXITSTATUS(status)} - возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. Эти биты могли быть установлены в аргументе функции \emph{exit} или в аргументе оператора \emph{return} функции \emph{main}. Этот макрос можно использовать, только если \emph{WIFEXITED} вернул ненулевое значение.
	\item \emph{WIFSIGNALED(status)} - возвращает истинное значение, если дочерний процесс завершился из-за необработанного сигнала.
	\item \emph{WTERMSIG(status)} - возвращает номер сигнала, который привел к завершению дочернего процесса. Этот макрос можно использовать, только если \emph{WIFSIGNALED} вернул ненулевое значение.
	\item \emph{WIFSTOPPED(status)} - возвращает истинное значение, если дочерний процесс, из-за которого функция вернула управление, в настоящий момент остановлен; это возможно, только если использовался флаг\emph{WUNTRACED} или когда подпроцесс отслеживается.
	\item \emph{WSTOPSIG(status)} - возвращает номер сигнала, из-за которого дочерний процесс был остановлен. Этот макрос можно использовать, только если \emph{WIFSTOPPED} вернул ненулевое значение.
\end{itemize}

Разработаем программу, в которой процесс-родитель ожидает завершения процесса-потомка, а после анализирует статус, с помощью вышеописанных макросов:

\lstinputlisting{listings/p1.9.1.c}

Результат работы программы: 

\lstinputlisting{listings/p1.9.1.log}

Процесс потомок завершился успешно с кодом выхода 0xA, номер сигнала из-за которого процесс был остановлен также 0xA.

\subsubsection{9.2. Анализ функции waitpid()}

Функция \emph{waitpid} приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре \emph{pid}, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик. Если указанный дочерний процесс к моменту вызова функции уже завершился, то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются.

Исследуем функцию \emph{waitpid}. Она позволяет ожидать процесс по его \emph{PID}, с учетом следующих опций:

\begin{itemize}
	\item \emph{WNOHANG} - означает немедленное возвращение управления, если ни один дочерний процесс не завершил выполнение.
	\item \emph{WUNTRACED} - означает возврат управления и для остановленных (но не отслеживаемых) дочерних процессов, о статусе которых еще не было сообщено. Статус для отслеживаемых остановленных подпроцессов также обеспечивается без этой опции.
\end{itemize}

Разработаем программу, которая порождает три процесса-потомка и в зависимости от аргумента командной строки выполняет функцию \emph{waitpid} с конкретным набором опций:

\lstinputlisting{listings/p1.9.2.p.cpp}

Создадим программы-потомки для запуска. Первый потомок:

\lstinputlisting{listings/p1.9.2.c1.c}

Второй потомок:

\lstinputlisting{listings/p1.9.2.c2.c}

Третий потомок:

\lstinputlisting{listings/p1.9.2.c3.c}

Проверим работоспособность программ-потомков:

\lstinputlisting{listings/p1.9.2.c.log}

Выполним программу-родитель с разными наборами опций: аргумент 0 задает опции \emph{WNOHANG}, \emph{WUNTRACED}, \emph{WNOHANG}, аргумент 1 задает опции \emph{WUNTRACED}, \emph{WUNTRACED}, \emph{WUNTRACED}, аргумент 2 задает опции \emph{WNOHANG}, \emph{WUNTRACED}, \emph{WUNTRACED}.

\lstinputlisting{listings/p1.9.2.p.log}

Из опытов видно, чтобы процесс завершился корректно и не повис в ожидании дочернего процесса, необходимо использовать опцию \emph{WUNTRACED}. Если дочерний процесс должен быть обязательно проконтроллирован по завершению, то необходимо использовать \emph{WNOHANG}.

Рассмотрим дерево процессов перед ожиданием последнего дочернего процесса:

\lstinputlisting{listings/p1.9.2.p.ps.log}

Приставка \emph{<defunct>} у процесса \emph{p1.9.2.c1} означает, что процесс уже выполнился, но все еще остался в списке процессов. Использование опции \emph{WNOHANG} для данного процесса подтверждает корректное возвращение управления.

\subsubsection{10.1. Анализ очередности процессов, порожденных вложенными вызовами fork()}

Разработаем программу, принимающую в качестве аргументов командной строки алгоритм планирования и численные значение приоритетов процесса для родителя и каждого из трех потомков:

\lstinputlisting{listings/p1.10.1.cpp}

Пример работы программы с алгоритмом планирования \emph{SCHED\_FIFO} (первый аргумент в командной строке 0):

\lstinputlisting{listings/p1.10.1.f.log}

Пример работы программы с алгоритмом планирования \emph{SCHED\_RR} (первый аргумент в командной строке 1):

\lstinputlisting{listings/p1.10.1.r.log}

Результаты выполнения \emph{SCHED\_RR} оказались аналогичными с \emph{SCHED\_FIFO}.

Пример работы программы с алгоритмом планирования \emph{SCHED\_OTHER} (первый аргумент в командной строке 2):

\lstinputlisting{listings/p1.10.1.o.log}

При вложенных процессах первым выполняется процесс с наибольшим приоритетом. При равных приоритетах, процессы выполняются по принципу \emph{FIFO}.

\subsubsection{10.2. Разные процедуры планирования разным процессам с одинаковыми приоритетами}

Разработаем программу, в которой у процессов-потомков одинаковый приоритет, а алгоритмы планирования задаются аргументами командной строки:

\lstinputlisting{listings/p1.10.2.cpp}

Результаты выполнения программы с разными алгоритмами планирования:

\lstinputlisting{listings/p1.10.2.log}

Эксперимент №1: все четыре политики планирования \emph{SCHED\_FIFO}. Так как у всех процессов политика одинаковая, они выполняются согласно порядку попадания в очередь.

Эксперимент №2: политики планирования соответственно \emph{SCHED\_OTHER}, \emph{SCHED\_RR}, \emph{SCHED\_FIFO}, \emph{SCHED\_RR}. Второй и третий процесс выполнились раньше, чем первый.

Эксперимент №3: политики планирования соответственно \emph{SCHED\_RR}, \emph{SCHED\_FIFO}, \emph{SCHED\_RR}, \emph{SCHED\_FIFO}. Процессы выполнились согласно порядку попадания в очередь.

Эксперимент №4: политики планирования соответственно \emph{SCHED\_RR}, \emph{SCHED\_FIFO}, \emph{SCHED\_FIFO}, \emph{SCHED\_RR}. Процессы выполнились согласно порядку попадания в очередь.

Эксперимент №5: политики планирования соответственно \emph{SCHED\_OTHER}, \emph{SCHED\_OTHER}, \emph{SCHED\_OTHER}, \emph{SCHED\_OTHER}. Второй и третий процесс выполнились раньше, чем первый.

Делаем вывод, что любые комбинации комбинации \emph{SCHED\_RR} и \emph{SCHED\_FIFO} без \emph{SCHED\_OTHER} никак не влияют на порядок выполнения процессов. Это объясняется тем, что \emph{SCHED\_RR} и \emph{SCHED\_FIFO} во всех экспериментах до этого показали абсолютно одинаковые результаты.

\subsubsection{11. Определение величины кванта, попытка ее изменения}

Определить длину кванта можно с помощью функции:

\begin{verbatim}
int sched_rr_get_interval(pid_t, struct timespec*)
\end{verbatim}

Разработаем программу, определяющую длину кванта:

\lstinputlisting{listings/p1.11.cpp}

Результат выполнения программы:

\lstinputlisting{listings/p1.11.log}

Попробуем изменить длину кванта, посредством задания ему наивысшего приоритета:

\lstinputlisting{listings/p1.11.1.cpp}

Результат выполнения программы:

\lstinputlisting{listings/p1.11.1.log}

Квант изменить не удалось, однако в других \emph{ОС}, поддерживающих \emph{POSIX}, значение кванта можно менять, в том числе из системных приложений, оптимизируя функционирование прикладных задач. Особенно это существенно для ОС реального времени и систем технического обслуживания.

\subsubsection{12. Анализ наследования на этапах fork() и exec()}

Файловые дескрипторы наследуются при системном вызове функции \emph{fork}, также они не закрываются при вызове функции \emph{exec}.

Проведем эксперимент: попробуем прочитать содержимое файла в процессе-родителе, процессе-потомке и дочернем процессе. При этом дескриптор открывается один раз и не закрывается:

\lstinputlisting{listings/p1.12.c}

Дочерняя программа:

\lstinputlisting{listings/p1.12.ch.cpp}

Результат выполнения программы:

\lstinputlisting{listings/p1.12.log}

Все процессы считали содержимое файла, что подтверждает возможность единожды отрывать файловый дескриптор, которым могут пользоваться потомки и дочерние процессы.

\subsection{Глава 2. Взаимодействие родственных процессов}

\subsubsection{1.a. Процесс-родитель запускает процесс-потомок и ожидает его завершения}

Рассмотрим ситуацию, когда процесс-родитель несколько секунд ожидает дочерний процесс:

\lstinputlisting{listings/p2.1.1.c}

Дочерняя программа:

\lstinputlisting{listings/p2.1.1.ch.c}

Результат выполнения программы:

\lstinputlisting{listings/p2.1.1.log}

Процесс-родитель дождался завершения процесса-потомка и только после этого завершился сам.

\subsubsection{1.b. Процесс-родитель запускает процесс-потомок и не ожидает его завершения}

Рассмотрим ситуацию, когда процесс-родитель запускает дочерний процесс, но не ожидает его завершения:

\lstinputlisting{listings/p2.1.2.c}

Результат выполнения программы:

\lstinputlisting{listings/p2.1.2.log}

Так как родительский процесс завершился раньше дочернего, мы зафиксировали изменение \emph{PID} дочернего процесса на единицу. Это значит что родительский процесс этого процесса теперь корневой процесс \emph{init}, который запускается ядром при загрузке системы. Его задача - усыновлять процессы, которые остались без родительского процесса.

\subsubsection{1.c. Процесс-родитель запускает процесс-потомок и не ожидает его завершения, фиксация зомби процесса}

Модифицируем программу, добавив задержку, которая больше чем в дочернем процессе и системные вызовы таблицы процессов:

\lstinputlisting{listings/p2.1.3.c}

Состояния процессов во время выполнения программы:

\lstinputlisting{listings/p2.1.3.z.log}

Дочерний процесс завершает задачу раньше родительского процесса, у него отнимаются ресурсы и он становится зомби-процессом. Он полностью удалится только после завершения родительского процесса.

\subsubsection{2. Создание скрипта, запускающего все три программы}

Создадим скрипт, запускающий все три программы:

\lstinputlisting{listings/p2.2.sh}

Запустим скрипт и перенаправим вывод в файл:

\lstinputlisting{listings/p2.2.log}

Файл с результатом выполнения программ:

\lstinputlisting{listings/p2.2.r.log}

Отклонений в работе программ не обнаружено.

\subsection{Глава 3. Управление процессами посредством сигналов}

\subsubsection{1. Выполнить команду kill с ключем -l, проанализировать результат}

Выполним команду \emph{kill} с ключем \emph{-l}, которая выводит список всех сигналов для данной операционной системы:

\lstinputlisting{listings/p3.1.k.log}

Функция \emph{kill} позволяет посылать любой из этих сигналов процессу по его \emph{PID}. Функция имеет следующую сигнатуру:

\begin{verbatim}
int kill(pid_t pid, int sig);
\end{verbatim}

Также есть утилита \emph{kill}, выполняющая такую же функцию.

Функция \emph{signal} позволяет задавать собственный обработчик для вышеперечисленных сигналов. Функция имеет следующую сигнатуру:

\begin{verbatim}
int signal(int sig, void (*func)(int));
\end{verbatim}

Если значение передаваемой функции равно \emph{SIG\_DFL}, то устанавливается обработчик по умолчанию, если значение передаваемой функции равно \emph{SIG\_IGN}, то сигнал игнорируется.

\subsubsection{1.a. - 1.c. Родительский процесс порождает  три дочерних процесса. Первый дочерний процесс содержит обработчик сигнала по умолчанию, второй игнорирует сигнал, третий обрабатывает и выводит сообщение. Анализ, с помощью вызова ps -s}

Первая программа обрабатывает сигнал по умолчанию:

\lstinputlisting{listings/p3.1.1.ch.c}

Вторая программа игнорирует сигнал:

\lstinputlisting{listings/p3.1.2.ch.c}

Третья программа содержит собственный обработчик сигнала:

\lstinputlisting{listings/p3.1.3.ch.c}

Программа родитель, запускающая все три дочерних процесса, и завершающая их функцией \emph{kill}:

\lstinputlisting{listings/p3.1.p.c}

Результат эксперимента:

\lstinputlisting{listings/p3.1.log}

Первый сигнал был обработан по умолчанию и процесс завершился. Второй сигнал был ожидаемо проигнорирован и процесс завершился после некоторой задержки. Третий процесс обработал сигнал и вывел сообщение, после чего завершился.

Рассмотрим результаты залогированных вызовов \emph{ps -s}. Вызов до первого вызова \emph{kill}:

\lstinputlisting{listings/p3.1.0.log}

Вызов \emph{ps -s} после первого вызова \emph{kill}:

\lstinputlisting{listings/p3.1.1.log}

Вызов \emph{ps -s} после второго вызова \emph{kill}:

\lstinputlisting{listings/p3.1.2.log}

Вызов \emph{ps -s} после третьего вызова \emph{kill}:

\lstinputlisting{listings/p3.1.3.log}

Первый и третий процесс завершились и стали зомби, в то время как второй процесс проигнорировал сигнал завершения и завершится только после некоторой задержки.

\subsubsection{2. Посылка сигналов двум процессам, находящимся в активном и пассивных состояниях соответственно. Фиксация времени посылки и приема каждого сигнала}

Программа родитель в активном режиме запускает дочерний процесс, обрабатывает сигнал прерывания и  фиксирует время завершения:

\lstinputlisting{listings/p3.2.p.c}

Дочерний процесс в пассивном режиме (с помощью вызова \emph{daemon}) обрабатывает сигнал прерывания и фиксирует время завершения:

\lstinputlisting{listings/p3.2.ch.c}

Запустим программу родитель и вручную из нового окна терминала завершим оба процесса с фиксацией времени посылки:

\lstinputlisting{listings/p3.2.log}

Лог с фиксацией времени приема:

\lstinputlisting{listings/p3.2.pr.log}

Дочерний процесс в фоновом режиме завершился спустя $8.898$ микросекунд после посылки сигнала, родительский процесс в активном режиме завершился спустя $11.163$ микросекунд после посылки сигнала. Временные задержки завершения процессов в активном и фоновом режиме отличаются незначительно, и на основании этого эксперимента нельзя точно утверждать, что процесс в активном режиме завершается медленнее, чем в пассивном.

\subsubsection{3. Запуск в фоновом режиме нескольких утилит}

Текстовый файл для отображения утилитой \emph{cat}:

\lstinputlisting{listings/p3.3.txt}

Скрипт, выводящий сообщение в консоль и уведомляющий о своем завершении при помощи \emph{notify}:

\lstinputlisting{listings/p3.3.sh}

Программа выводящая сообщение в консоль:

\lstinputlisting{listings/p3.3.c}

Результат запуска нескольких утилит в фоновом режиме:

\lstinputlisting{listings/p3.3.log}

Теперь приостановим работу программы и вновь возобновим ее:

\lstinputlisting{listings/p3.3.n.log}

В списке \emph{jobs} выведена информация о том, что программа приостановлена, после этого программа была восстановлена командой \emph{fg \%2} и было выведено сообщение в консоль.

\subsubsection{4. Ознакомление с системными вызовами nice() и getpriority()}

Утилита \emph{nice} запускает процесс на выполнение с некоторым приоритетом, который варьируется от -19 до 20. Меньшее число обозначает наивысший приоритет. Большее число означает низший приоритет.

Разработаем программу, которая выводит сообщение в консоль несколько раз с некоторой периодичностью:

\lstinputlisting{listings/p3.4.1.c}

Рассмотрим результаты запуска двух экземпляров программ с одинаковыми приоритетами:

\lstinputlisting{listings/p3.4.1.1.log}

Так как приоритет одинаковый, процессы конкурируют между собой за право выполнения и ни один из них не вырывается вперед образовывая неровность выполнения.

Рассмотрим результаты запуска двух экземпляров программ с разными приоритетами:

\lstinputlisting{listings/p3.4.1.2.log}

Видно, что первый процесс выполнил первую и вторую итерацию раньше, чем второй, это связано с тем что его приоритет выше.

Функция \emph{getpriority} получает текущее значение приоритета для процесса, группы или пользователя. Функция имеет следующие сигнатуры:

\begin{verbatim}
int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);
\end{verbatim}

Для определения минимального и максимального значения приоритета для конкретного алгоритма планирования можно с помощью функций \emph{sched\_get\_priority\_min} и \emph{sched\_get\_priority\_max} соответственно. Функции имеет следующие сигнатуры:

\begin{verbatim}
int sched_get_priority_max(int policy);
int sched_get_priority_min(int policy);
\end{verbatim}

Разработаем программу, определяющую текущую политику планирования и возможные диапазоны приоритетов для этих политик:

\lstinputlisting{listings/p3.4.2.cpp}

Результат работы программы:

\lstinputlisting{listings/p3.4.2.log}

Делаем вывод, что алгоритм планирования по умолчанию SCHED\_OTHER, а приоритет равен 0.

Рассмотрим некоторые процессы текущего пользователя и суперпользователя:

\lstinputlisting{listings/p3.4.2.ps.log}

Процессы были отсортированы по убыванию приоритетов (столбец \emph{NI}). Заметим, что приоритеты у обычного пользователя за редкими исключениями отличаются от нуля, в то время как у суперпользователя большой набор процессов, запущенных с наивысшим приоритетом. Это связано с необходимостью контролирования работы системы.

\subsubsection{5. Ознакомление с командой nohup}

Команда \emph{nohup} запускает указанную команду с игнорированием сигналов потери связи \emph{SIGHUP}. Таким образом, команда продолжает выполнение в фоновом режиме и после выхода из системы.

Разработаем программу, которая не завершается самостоятельно:

\lstinputlisting{listings/p3.5.c}

Запустим программу с опцией \emph{nohup}:

\lstinputlisting{listings/p3.5.log}

Зафиксируем наличие процесса до перезагрузки:

\lstinputlisting{listings/p3.5.be.log}

Зафиксируем наличие процесса после перезагрузки:

\lstinputlisting{listings/p3.5.af.log}

\subsubsection{5. Определение UID процесса, зафиксировать минимальное и максимальное значение PID, анализ системных процессов}

Для определения \emph{UID} процесса воспользуемся следующим набором команд:

\lstinputlisting{listings/p3.6.log}

В первую очередь получаем \emph{UID} пользователя и суперпользователя по их имени. После этого вызвали таблицу процессов с флагом \emph{-l}, для получения информации о текущем \emph{UID} процесса.

Зафиксируем текущие минимальное и максимальное \emph{PID} процессов в системе:

\lstinputlisting{listings/p3.6.pid.log}

Минимальное возможное значение \emph{PID} равно единице и всегда принадлежит процессу \emph{systemd}. Максимальное возможное значение \emph{PID} было получено чтением системного файла, оно равно 32768.

Системные процессы легко определить от прочих: они имеют наивысший приоритет, имеют маленькие значения \emph{PID} и  принадлежат суперпользователю. Системными процессами, например, являются: \emph{shed} (диспетчер свопинга), \emph{vhand} (диспетчер страничного замещения), \emph{kmadaemon} (диспетчер памяти ядра).

\subsection{Глава 4. Многопоточное функционирование}

\subsubsection{1. Создание программы, формирующей несколько потоков, которые выводят сообщения с определенным интервалом}

В настоящее время в GNU/Linux потоки отличаются от процессов в основном набором свойств и вещами вроде вызова функций семейства \emph{exec} в одном из потоков. То есть и процессы, и потоки являются объектами планирования для планировщика ядра, могут независимо друг от друга блокироваться, получать сигналы и т.д. Даже порождение процессов и потоков происходит схожим образом при помощи функции \emph{clone} перечислением нужных флагов, определяющих свойства порождаемого объекта.

Рассмотрим основные отличия потока от процесса:

\begin{itemize}
	\item Потоки всегда работают в контексте какого-то процесса: потоков без процессов не бывает.
	\item Потоки одного процесса совместно используют  адресное пространство этого процесса, что означает, что потоки могут работать с данными друг друга без использования \emph{IPC}, просто средствами языка программирования как с обычными переменными внутри единой программы.
	\item Некоторые сигналы (вроде SIGSEGV) вызывают принудительное завершение всего процесса (появление SIGSEGV связано с обнаружением нарушения адресного пространства, а это влияет на все потоки процесса), тогда как появление SIGSEGV в одном процессе обычно не влияет на другой процесс.
\end{itemize}

Так как глобальные данные, используемые нескольким потоками, не содержат чего-либо, имеющего отношение к управлению своевременностью доступа, то используется такое понятие как критическая секция: это блок кода, в котором выполняется обращение к защищаемым данным. Защита в этом случае обеспечивается использованием мьютексов и/или семафоров. Это специальные системные объекты, состояние которых нужно проверять перед выполнением критической секции и реагировать соответственно ему.

Разработаем программу, порождающую два потока. Первый поток выводит сообщение один раз в пять секунд, второй поток выводит сообщение один раз в секунду. Основной поток блокируется до завершения этих потоков: 

\lstinputlisting{listings/p4.1.c}

Результат выполнения программы:

\lstinputlisting{listings/p4.1.log}

Из результатов видно, что на пять сообщений второго потока приходится одно сообщение первого потока, что полностью соответствует ожиданиям.

Выясним, как регистрируются потоки с точки зрения системы. Для этого выполним команду \emph{ps} с флагом \emph{-L}:

\lstinputlisting{listings/p4.1.ps.log}

Информация о потоках отображается в столбцах \emph{LWP} (Light Weight Process - облегченные процессы) и \emph{NLWP} (Number of LWP's - количество потоков). В нашем случае система регистрирует три потока \emph{NLWP}, у которых различные идентификаторы \emph{LWP}.

\subsubsection{2. Создание программы, формирующей несколько потоков, которые выводят сообщения с определенным интервалом}

Модифицируем программу из предыдущего пункта, добавив в нее логирование таблицы процессов:

\lstinputlisting{listings/p4.2.c}

Запустим программу и завершим ее командой \emph{kill} из соседнего терминала.

Рассмотрим логи таблиц процессов:

\lstinputlisting{listings/p4.2.1.log}

\lstinputlisting{listings/p4.2.2.log}

\lstinputlisting{listings/p4.2.3.log}

Можно заметить, что ни на одном из этапов программы разделения на дочерние процессы не происходит, и оба потока являются одним процессом.

\subsubsection{3. Модификация программы с завершением потока посредством сигнала SIGUSR1}

Модифицируем программу, добавив код, который через определенное количество секунд завершит вторую нить из первой:

\lstinputlisting{listings/p4.3.c}

Результат работы программы:

\lstinputlisting{listings/p4.3.log}

\subsubsection{4. Модификация программы с добавлением  функции pthread\_exit()}

Если в предыдущем пункте программа завершалась с помощью глобальной переменной, в этой программе используем специальную функцию завершения потока \emph{pthread\_exit}:

\lstinputlisting{listings/p4.4.c}

Результат работы программы аналогичен предыдущему пункту:

\lstinputlisting{listings/p4.4.log}

\subsubsection{5.1. Перехват сигнала Ctrl+C из терминала однократно для процесса}

Однократный перехватчик сигнала для процесса:

\lstinputlisting{listings/p4.5.1.c}

Результат работы программы:

\lstinputlisting{listings/p4.5.1.log}

\subsubsection{5.2. Перехват сигнала Ctrl+C из терминала однократно для потока}

Однократный перехватчик сигнала для потока:

\lstinputlisting{listings/p4.5.2.c}

Результат работы программы:

\lstinputlisting{listings/p4.5.2.log}

\subsubsection{5.3. Перехват сигнала Ctrl+C из терминала многократно с восстановлением исходного обработчика}

Многократный перехватчик сигнала с восстановлением исходного обработчика:

\lstinputlisting{listings/p4.5.3.c}

Результат работы программы:

\lstinputlisting{listings/p4.5.3.log}

\subsubsection{5.4. Перехват сигнала для другой комбинации клавиш (Ctrl+Z)}

Многократный перехватчик сигнала с восстановлением исходного обработчика для комбинации клавиш \emph{Ctrl+Z} (сигнал \emph{SIGTSTP}):

\lstinputlisting{listings/p4.5.4.c}

Результат работы программы:

\lstinputlisting{listings/p4.5.4.log}

\subsubsection{6. Перехват сигнала для другой комбинации клавиш (Ctrl+Z)}

Выполним команду \emph{kill} с ключем \emph{-l}, которая выводит список всех сигналов для данной операционной системы:

\lstinputlisting{listings/p4.6.log}

Рассмотрим некоторые из них:

\begin{itemize}
	\item \emph{SIGABRT} - сигнал посылаемый функцией \emph{abort()}, по умолчанию завершает процесс с дампом памяти.	
	\item \emph{SIGALRM} - 	сигнал истечения времени, заданного \emph{alarm()}, по умолчанию завершает процесс.
	\item \emph{SIGBUS} - 	неправильное обращение в физическую память, по умолчанию завершает процесс с дампом памяти.	
	\item \emph{SIGCHLD} - дочерний процесс завершен или остановлен, по умолчанию игнорируется.	
	\item \emph{SIGCONT} -  по умолчанию продолжает выполнение ранее остановленного процесса.
	\item \emph{SIGFPE} - ошибочная арифметическая операция, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGHUP} - закрытие терминала, по умолчанию завершает процесс.	
	\item \emph{SIGILL} - недопустимая инструкция процессора, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGINT} - сигнал прерывания \emph{Ctrl-C} с терминала, по умолчанию завершает процесс.	
	\item \emph{SIGKILL} - безусловное завершение, по умолчанию завершает процесс.	
	\item \emph{SIGPIPE} - запись в разорванное соединение (пайп или сокет), по умолчанию завершает процесс.	
	\item \emph{SIGQUIT} - сигнал \emph{Quit} с терминала \emph{Ctrl-$\backslash$}, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGSEGV} - нарушение при обращении в память, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGSTOP} - остановка выполнения процесса.	
	\item \emph{SIGTERM} - сигнал завершения (сигнал по умолчанию для утилиты \emph{kill})
	\item \emph{SIGTSTP} - сигнал остановки с терминала \emph{Ctrl-Z}, по умолчанию останавливает процесс.
	\item \emph{SIGTTIN} - попытка чтения с терминала фоновым процессом, по умолчанию останавливает процесс.	
	\item \emph{SIGTTOU} - попытка записи на терминал фоновым процессом, по умолчанию останавливает процесс.	
	\item \emph{SIGUSR1} - пользовательский сигнал № 1, по умолчанию завершает процесс.	
	\item \emph{SIGUSR2} - пользовательский сигнал № 2, по умолчанию завершает процесс.
	\item \emph{SIGPOLL} - событие, отслеживаемое \emph{poll()}, по умолчанию завершает процесс.	
	\item \emph{SIGPROF} - истечение таймера профилирования, по умолчанию завершает процесс.	
	\item \emph{SIGSYS} - неправильный системный вызов, по умолчанию завершает процесс с дампом памяти.	
	\item \emph{SIGTRAP} - ловушка трассировки или брейкпоинт, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGURG} - на сокете получены срочные данные, по умолчанию игнорируется.	
	\item \emph{SIGVTALRM} - истечение «виртуального таймера», по умолчанию завершает процесс.	
	\item \emph{SIGXCPU} - процесс превысил лимит процессорного времени, по умолчанию завершает процесс с дампом памяти.		
	\item \emph{SIGXFSZ} - процесс превысил допустимый размер файла, по умолчанию завершает процесс с дампом памяти.		
	
\end{itemize}

Остальные сигналы (с кодами большими 32) - это сигналы реального времени. В отличие от обычных сигналов, сигналы реального времени имеют очередь, при использовании специальных функций для отправки сигнала (\emph{sigqueue} - передача сигнала или данных процессу) могут передавать информацию (целое число или указатель), доставляются в том же порядке, в котором были отправлены.

\subsubsection{7. Эксперимент с изменением процедуры планирования для потоков одного процесса}

Разработаем программу, которая при помощи атрибутов \emph{pthread\_attr\_t} задает потокам атрибуты, в которых указывается политика планирования и приоритет. В самих потоках, с помощью функции  \emph{sched\_getscheduler} выводим политику планирования текущего потока.

\lstinputlisting{listings/p4.7.c}

Результат работы программы:

\lstinputlisting{listings/p4.7.log}

Согласно результатам, первый поток имеет политику планирования \emph{SCHED\_OTHER}, в отличие от ожидаемой политики \emph{SCHED\_FIFO}. это связано с тем, что первая политика была задана с опцией \emph{PTHREAD\_INHERIT\_SCHED}, что означает, что политика наследуется от родительского потока. 

Как и ожидалось, третий поток выполняется быстрее, чем должен. Это связано с тем, что третьему потоку задан наивысший приоритет.  

Рассмотрим значения приоритет потоков с точки зрения системы:

\lstinputlisting{listings/p4.7.ps.log}

Как и ожидалось, система регистрирует все четыре потока приложения, приоритеты которых (столбец \emph{PRI}) отличаются. У основного потока и первого потока одинаковые приоритеты, равные 80, что объясняется наследованием приоритета от родительского потока. Третий поток имеет приоритет -40, то есть наивысший. Это объясняется заданием значения приоритета 99 в коде программы.

\subsubsection{8. Скрипт, выполняющий лабораторную работу из исходных файлов}

Был написан скрипт, выполняющий лабораторную работу из исходных файлов:

\lstinputlisting{listings/p4.8/p4.8.sh}

Скрипт, выполняющий первую главу:

\lstinputlisting{listings/p4.8/p4.8.p1.sh}

Скрипт, выполняющий вторую главу:

\lstinputlisting{listings/p4.8/p4.8.p2.sh}

Скрипт, выполняющий третью главу:

\lstinputlisting{listings/p4.8/p4.8.p3.sh}

Скрипт, выполняющий четвертую главу:

\lstinputlisting{listings/p4.8/p4.8.p4.sh}

Скрипт, выполняющий всю лабораторную работу, был успешно запущен на лабораторном компьютере. Ввиду отсутствия \emph{C++ 11} на лабораторных компьютерах, некоторые программы были отредактированы, для использования более старой версией компилятора. Также из-за отсутствия прав суперпользователя, эксперименты с планированием не работают. Все остальные эксперименты успешно выполнены.

\clearpage

\section{Вывод}

В ходе работы были изучены методы распараллеливания процессов, изменение приоритетов выполнения, программную обработку сигналов. 

Процессы можно создавать с помощью функции \emph{fork}, копирующей процесс со всеми структурами, возвращающей идентификатор процесса для процесса, откуда она была вызвана, и ноль для скопированного процесса. Это позволяет организовать псевдораспараллеливание процессов.

При помощи функций семейства \emph{exec} можно заменить образ текущего процесса на новый образ процесса из файла, задать параметры вызываемого процесса и новые переменные окружения разными форматами: строкой или вектором.

Изменяя политику планирования, можно управлять принципами построения очереди. Изменяя приоритет процесса, можно изменить порядок выполнения и дать преимущество в борьбе за процессорный ресурс.

Кроме того, в существует набор сигналов, которые позволяют процессам обмениваться информацией между собой и позволяют системе уведомлять процессы о различных событиях в системе, будь то нажатие клавиш, окончание пользовательской сессии или множество других событий. Для каждого процесса можно установить реакцию на получение сигнала: действие по умолчанию, игнорирование и вызов определенной функции. Необдуманное использование сигналов может привести к сбою.

Альтернативой использования \emph{fork} и \emph{exec} для распараллеливания вычислений является многопоточное программирование. Потоки могут создаваться и отслеживаться в основном процессе, им могут быть переданы параметры, назначены обработчики сигналов, а так же изменена процедура планирования и приоритеты.

\section{Список литературы}

\begin{itemize}
	

	\item Многопоточное программирование [Электронный ресурс]. — URL: \href{http://citforum.ru/programming/unix/threads/}{http://citforum.ru/programming/unix/\linebreak threads/} (дата обращения 17.11.2016).
	
	\item Мануал getpriority [Электронный ресурс]. — URL: \href{http://man7.org/linux/man-pages/man2/getpriority.2.html}{http://man7.org/linux/man-pages/man2/getpriority.\linebreak 2.html} (дата обращения 17.11.2016).
	
	\item Мануал sched\_get\_priority [Электронный ресурс]. — URL: \href{http://man7.org/linux/man-pages/man2/sched_get_priority_min.2.html}{http://man7.org/linux/man-pages/man2/sched\linebreak \_get\_priority\_min.2.html} (дата обращения 17.11.2016).
	
	\item Использование сигналов в Unix [Электронный ресурс]. — URL: \href{http://www.opennet.ru/base/dev/unix_signals.txt.html}{http://www.opennet.ru/base/dev/unix\linebreak \_signals.txt.html} (дата обращения 17.11.2016).
	
	\item Мануал wait [Электронный ресурс]. — URL: \href{https://www.opennet.ru/man.shtml?topic=wait}{https://www.opennet.ru/man.shtml?topic=wait} (дата обращения 17.11.2016).
	
	\item Семейство функций exec [Электронный ресурс]. — URL: \href{http://www.codenet.ru/progr/cpp/spr/084.php}{http://www.codenet.ru/progr/cpp/spr/084.php} (дата обращения 17.11.2016).
	
	\item Системный вызов fork [Электронный ресурс]. — URL: \href{http://www.intuit.ru/studies/courses/2249/52/lecture/1552?page=2}{http://www.intuit.ru/studies/courses/2249/52/lecture/\linebreak 1552?page=2} (дата обращения 17.11.2016).
	
	\item Мануал sched\_setscheduler [Электронный ресурс]. — URL: \href{https://www.opennet.ru/man.shtml?topic=sched_setscheduler&category=2}{https://www.opennet.ru/man.shtml?topic=sched\linebreak \_setscheduler\&category=2} (дата обращения 17.11.2016).
	
	\item Мануал sched\_setscheduler [Электронный ресурс]. — URL: \href{https://www.opennet.ru/man.shtml?topic=sched_setscheduler&category=2}{https://www.opennet.ru/man.shtml?topic=sched\linebreak \_setscheduler\&category=2} (дата обращения 17.11.2016).
	
	\item Пример разработки простого многопоточного сетевого сервера [Электронный ресурс]. — URL: \href{https://www.ibm.com/developerworks/ru/library/l-server5/}{https://www.\linebreak ibm.com/developerworks/ru/library/l-server5/} (дата обращения 17.11.2016).
	
\end{itemize}

\end{document}