\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}

\usepackage{caption}
\renewcommand{\lstlistingname}{Листинг}

\usepackage{listings}
\lstdefinestyle{base_listing}{ %
extendedchars=\true,
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
keepspaces = true
}

\lstdefinestyle{crs_bash}{
  style    = {base_listing},
  language = {bash}
}

\lstdefinestyle{crs_cpp}{
  style    = {base_listing},
  language = {C++}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm]
\large Отчет по лабораторной работе №4\\[0.1cm]
\large IPC в UNIX-системах\\[5cm]
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Цель работы}
	Изучить средства IPC в ОС семейства UNIX: сигналы, каналы, сообщения, семафоры, разделяемая память, сокеты.
\section{Программа работы}
\begin{enumerate}
\item Изучить сигналы
\begin{enumerate}
	\item Создать программу, позволяющую изменить диспозицию сигналов, а именно, установить:
- обработчик пользовательских сигналов SIGUSR1 и SIGUSR2;
- реакцию по умолчанию на сигнал SIGINT;
- игнорирование сигнала SIGCHLD;
Породить процесс-копию и уйти в ожидание сигналов. Обработчик сигналов должен содержать восстановление диспозиции и оповещение на экране о полученном (удачно или неудачно) сигнале и идентификаторе родительского процесса. Процесс-потомок, получив идентификатор родительского процесса, должен отправить процессу-отцу сигнал SIGUSR1 и извещение об удачной или неудачной отправке указанного сигнала. Остальные сигналы можно сгенерировать из командной строки.
	\item Создать программу, позволяющую продемонстрировать возможность отложенной обработки (временного блокирования) сигнала (например, SIGINT).
	\item Изменить обработчик сигнала так, чтобы из него производилась отправка другого сигнала.
	\item Проведите эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени, (более двух сигналов, для этого увеличьте «вложенность» вызовов обработчиков); экспериментально подтвердите, что обработка равноприоритетных сигналов реального времени происходит в порядке FIFO; опытным путем подтвердите наличие приоритетов сигналов реального времени.
\end{enumerate}
\item Организуем программу (файл pipe.c) так, чтобы процесс-родитель создавал неименованный канал, создавал потомка, закрывал канал на запись и записывал в произвольный текстовый файл считываемую из канала информацию. В функции процесса-потомка будет входить считывание данных из файла и запись их в канал.
	\begin{enumerate} \item Создать клиент-серверное приложение, демонстрирующее дуплексную (двунаправленную) передачу информации двумя однонаправленными именованными каналами между клиентом и сервером.
	\end{enumerate}
\item Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очередей сообщений.
\item Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очередей сообщений.
	\begin{enumerate} \item К условиям предыдущей задачи добавляется наличие не единичного буфера, а буфера некоторого размера.
	\end{enumerate}
\item Сервер прослушивает заданный порт, при приходе нового соединения, создается новый поток для его обработки. Работа с клиентом организована как бесконечный цикл, в котором выполняется прием сообщения от клиента, вывод его на экран и пересылка обратно клиенту.
	\begin{enumerate} \item Модифицировать, если необходимо, предложенное приложение и реализовать обмен сервера с множеством клиентов. Количество клиентов: 10, 100, 1000.
		\itemВыполнить аналогичное взаимодействие на основе UDP.
	\end{enumerate}
\end{enumerate}
\section{Рабочая станция}
	Лабораторная выполняется на физической машине со следующими характеристиками:
	\lstinputlisting[style=crs_bash]{../listings/uname}
	
\section{Ход работы}

\subsection{Сигналы}
	Сигналы позволяют осуществить самый примитивный способ коммуникации между двумя процессами. Сигналы в системе UNIX используются для того, чтобы: сообщить процессу о том, что возникло асинхронное событие; или необходимо обработать исключительное состояние.
	
	Изначально сигналы были разработаны для уведомления об ошибках. В дальнейшем их стали использовать и как простейшую форму межпроцессного взаимодействия (IPС), например, для синхронизации процессов или для передачи простейших команд от одного процесса другому. Сигнал позволяет передать уведомление о некотором произошедшем событии между процессами или между ядром системы и процессами. Это означает, что посредством сигналов можно выполнять две основные функции IPC: передачу информации и синхронизацию процессов или потоков.
	
	Ознакомиться с полным перечнем сигналов можно с помощью команды \textbf{kill -l} в командном интерпретаторе:
	\lstinputlisting[style=crs_bash]{../listings/kill_l}

	Кроме того, сигнал может быть отправлен процессу либо ядром, либо другим процессом с помощью системного вызова \textbf{kill()}:
	\begin{lstlisting}[style=crs_cpp]
#include <signal.h>
int kill(pid_t pid, int sig);		
	\end{lstlisting}
	Аргумент pid адресует процесc, которому посылается сигнал. Аргумент sig определяет тип отправляемого сигнала. С помощью системного вызова \textbf{kill()} процесс может послать сигнал, как самому себе, так и другому процессу или группе процессов.
	
	Аналогичное действие можно произвести из командной строки в терминальном режиме, используя команду интерпретатора \textbf{kill pid}.
	
	Процесс может выбрать одно из трех возможных действий при получении сигнала:
	\begin{itemize}
	\item игнорировать сигнал,
	\item перехватить и самостоятельно обработать сигнал,
	\item позволить действие по умолчанию.	
	\end{itemize}
	
	Текущее действие при получении сигнала называется диспозицией сигнала.
	
	Порожденный вызовом fork() процесс наследует диспозицию сигналов от своего родителя. Однако при вызове exec() диспозиция всех перехватываемых сигналов будет установлена ядром на действие по умолчанию.
	
	Функция \textbf{signal()} позволяет устанавливать и изменять диспозицию сигнала.
	\begin{lstlisting}[style=crs_cpp]
#include <signal.h>
void (*signal (int sig, void (*disp)(int)))(int);	
	\end{lstlisting}
	
	В случае успешного завершения \textbf{signal()} возвращает предыдущую диспозицию - это может быть функция-обработчик сигнала или системные значения \texttt{SlG\_DFL} или \texttt{SlG\_IGN}. Это значение в случае необходимости может быть использовано для восстановления предыдущей диспозиции после однократного выполнения пользовательского обработчика.
	
	Более гибкое управление сигналами предоставляет функция \textbf{sigaction()}:
	\begin{lstlisting}[style=crs_cpp]
int sigaction( int sig,
const struct sigaction * act,
struct sigaction * oact );
	\end{lstlisting}
	Данная функция позволяет вызывающему процессу получить информацию или установить (или и то и другое) действие, соответствующее какому-либо сигналу или группе сигналов. При этом каждый сигнал ассоциируется с битом 32-х/(64-х) –разрядного слова-маски, соответствующим номеру сигнала.
	
	\subsubsection{Ненадежные сигналы}
	Создать программу, позволяющую изменить диспозицию сигналов, а именно, установить:
	\begin{itemize}
	\item обработчик пользовательских сигналов SIGUSR1 и SIGUSR2;
	\item реакцию по умолчанию на сигнал SIGINT;
	\item игнорирование сигнала SIGCHLD;	
	\end{itemize}

	Породить процесс-копию и уйти в ожидание сигналов. Обработчик сигналов должен содержать восстановление диспозиции и оповещение на экране о полученном (удачно или неудачно) сигнале и идентификаторе родительского процесса. Процесс-потомок, получив идентификатор родительского процесса, должен отправить процессу-отцу сигнал SIGUSR1 и извещение об удачной или неудачной отправке указанного сигнала. Остальные сигналы можно сгенерировать из командной строки.
	
	Обе программы (родителя и потомка) были заданы в одном файле:
	\lstinputlisting[style=crs_cpp]{../listings/sig_exam.c}
	
	Компиляция и запуск программы и отправление еще 3 сигналов процессу-отцу: SIGCHLD, SIGUSR2, SIGINT:

	\lstinputlisting[style=crs_bash]{../listings/sig_exam}

	Процесс-потомок отправил сигнал SIGUSR1, а процесс-отец его успешно принял. В программе был задан обработчик сигналов SIGUSR1 и SIGUSR2, поэтому при получении этих сигналов вывелось соответствующее сообщение. Сигналу SIGCHLD был установлен обработчик игнорирования, поэтому при получении данного сигнала ничего не произошло. Сигналу SIGINT был установлен обработчик по умолчанию (завершение работы процесса), поэтому при получении данного сигнала процесс завершился.
	
	Запустим программу еще раз и отправим ей 2 сигнала SUGUSR2:
	\lstinputlisting[style=crs_bash]{../listings/sig_exam_usr2}
	
	В результате первый сигнал был <<пойман>>, второй обработался по умолчанию. Это происходит потому, что в обработчике прерываний после первого приема сигнала происходит восстановление диспозиции сигналов.

	Рассмотри, можно ли перенести обработчик сигнала в нить:
	\lstinputlisting[style=crs_cpp]{../listings/toop.c}
	Результат запуска:
	\lstinputlisting[style=crs_bash]{../listings/toop}
	Перенос вызова signal в поток не приводит к тому, что обработчик сигнала будет в потоке, это видно по пропавшему выводу основного потока. Однако для потоков внутри одного процесса есть возможность обмениваться сигналами с помошью системного вызова pthread\_kill(). Вызовем signal не в том потоке, которуму будем посылать сигнал:
	\lstinputlisting[style=crs_cpp]{../listings/ktoop.c}
	Результат запуска:
	\lstinputlisting[style=crs_bash]{../listings/ktoop}
	Закрылся поток, который был указан в pthread\_kill, хотя signal была вызвана в основном потоке. Это говорит о точ, что место переопределения обработчика сигнала не имеет значения, в отличие от источника сигнала(kill или pthread\_kill). 
	
	Рассмотрим случай обмена сигналами между двумя разными процессами. Для этого запустим один процесс в фоновом режиме, посмотрим его PID:	
	\lstinputlisting[style=crs_cpp]{../listings/two_proc.c}

	Укажем в другой программе PID порожденного процесса для посылки сигнала:
	\lstinputlisting[style=crs_cpp]{../listings/two_proc2.c}
	
	Запустим программы:
	\lstinputlisting[style=crs_bash]{../listings/two_proc}
	
	Мы видим, что первый процесс принял отправленный сигнал. Время, прошедшее между посылкой и обработкой сигнала менее 1 секунды.\\
	
	Обмен сигналами между потоками разных процессов не возможен, так как мы убедились ранее, назначить обработчик потоку в коде нельзя, а pthread\_kill действует в пределах одного процесса. Даже системный вызов clone  требует разделения таблицы обработчиков сигналов в случает создание потока в пределах того же процесса.
	
	
	\subsubsection{Надежные сигналы}
	Создать программу, позволяющую продемонстрировать возможность отложенной обработки (временного блокирования) сигнала (например, SIGINT).
	
	Вся необходимая для управления сигналами информация передается через указатель на структуру sigaction. Блокировку реализуем, вызвав "засыпание" процесса на одну минуту из обработчика пользовательских сигналов. В основной программе установим диспозицию этих сигналов. С рабочего терминала отправим процессу sigact сигнал SIGUSR1 или SIGUSR2, а затем сигнал SIGINT.
	
	Исходный код программы:
	\lstinputlisting[style=crs_cpp]{../listings/sigact.c}
	
	Результат выполнения:
	\lstinputlisting[style=crs_bash]{../listings/sigact}


	По результатам сигнал SIGUSR1 принят корректно, но после посылки сигнала SIGINT программа продолжала выполняться еще минуту, и только после этого завершилась. В этом отличие надежной обработки сигналов от ненадежной: есть возможность отложить прием некоторых других сигналов. Отложенные таким образом сигналы записываются в маску PENDING и обрабатываются после завершения обработки сигналов, которые отложили обработку. Механизм ненадёжных сигналов не позволяет откладывать обработку других сигналов (можно лишь установить игнорирование некоторых сигналов на время обработки).
	
	Изменить обработчик сигнала так, чтобы из него производилась отправка другого сигнала. Пусть из обработчика сигнала SIGUSR1 функцией kill() генерируется сигнал SIGINT. Проанализируем наличие и очередность обработки сигналов.	
	Исходный код программы:
	\lstinputlisting[style=crs_cpp]{../listings/sigact2.c}
	
	Результат выполнения:
	\lstinputlisting[style=crs_bash]{../listings/sigact2}
	
	При генерации сигнала (в данном случае SIGINT) из обработчика другого сигнала обработка сгенерированного сигнала задерживается до конца выполнения текущего обработчика (как и в предыдущем эксперименте).

	\subsubsection{Сигналы реального времени}
	\begin{enumerate}
	\item Провести эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени (более двух сигналов. Для этого увеличить вложенность вызовов обработчиков).
	\item Экспериментально подтвердить, что обработка равноприоритетных сигналов реального времени происходит в порядке очереди.
	\item Опытным путем подтвердить наличие приоритетов сигналов реального времени.
	\end{enumerate}
	Сигналы реального времени не имеют предопределённых значений и могут быть в целях приложения. Однако стандартное поведение при отсутствие обработчика - завершить процесс.
	
	Основываясь на данных системного мануала (man 7 signal), можно сказать, что при блокировке, в отличие от обычных, все сигналы реального времени будут поставлены в очередь. RT сигналы одного типа будут поставлены в очередь в том порядке, в котором они пришли, а расположение разных типов произойдёт по приоритетам: у меньшего номера типа больший приоритет, т.е. он выше в очереди. А номера процессов могут варьироваться, так что хорошей практикой является использование SIGRTMIN+n и проверка не превышения SIGRTMAX. Приоритет обычных и процессов реального времени не определён стандартом POSIX, а Linux отдаёт приоритет стандартным процессам.
	Для работы с сигналами реального времени применяются те же самые системные вызовы, что и для работы с обычными сигналами. 
	В качестве примера напишем программу, производящую отсылку набора традиционных сигналов и набора сигналов реального времени, для иллюстрации упорядочивания и постановки в очередь сигналов реального времени:

	\lstinputlisting[style=crs_cpp]{../listings/posix.c}
	
	Результат выполнения:
	\lstinputlisting[style=crs_bash]{../listings/posix}

	Сигналы посылались процессу в разнобой и были доставлены одновременно, однако из результатов видно, что сформировалась очередь из сигналов реального времени в порядке увеличения номеров сигналов (меньший номер соответствует большему приоритету), а в рамках одного типа сигнала сохранилась изначальная последовательность.  Кроме того, количество принятых сигналов реального времени равно количеству отправленных сигналов реального времени, тогда как стандартные сигналы имеет лишь по одному представителю каждого посланного типа. Кроме того, виден приоритет стандартных сигналов над сигналами реального времени.\\
	
	Как будет показано в пункте \ref{IPClimits}, существует ограничение на длину сообщения, 8192 байта. У сигнала посылаемого системным вызовом sigqueue() передаются всего двенадцать байт (структура из int'а и указателя). Однако факт передачи подразумевает возможность указать на данные, превышающие даже ограничение сообщения, однако, стоит учитывать, что указатель, для одного адресного пространства не будет указывать на те же данные в другом. Докажем неработоспособность в отдельных процессах:\\
	Программа передатчик:
	\lstinputlisting[style=crs_cpp]{../listings/sig_val_transmitter.c}
	Программа приёмник:
	\lstinputlisting[style=crs_cpp]{../listings/sig_val_recv.c}
	Адресные пространства данных процессов сильно отличаются, поэтому ожидаем увидеть случайные данные или отказ в доступе:
	\lstinputlisting[style=crs_bash]{../listings/sig_val_sep_log}
	Процесс получатель попытался читать память к которой у него не доступа, но не потому, что указатель указывал на верные данные, а у получателя не было прав на чтение, а потому, что в адресном пространстве нет данных, расположенных по такому указателю.\\
	
	Создадим программу потомка и отправим сигнал родителю, изменив объявленные данные. Таким образом адресные пространства будут расположены одинаково, но содержание будет отличаться:
		\lstinputlisting[style=crs_cpp]{../listings/sig_val_fork.c}
		Ожидаем увидеть правильно адресованные данные, но соответствующие родительским, а не изменённым в дочернем потоке:
		\lstinputlisting[style=crs_bash]{../listings/sig_val_fork_log}
		Ожидания оправдались, указатель отработал корректно, указав на локальную версию данных. Таким образом передача более 12 байт данных через сигнал невозможна.	

\subsection{Каналы}
	Различают два типа каналов анонимные (иначе их называют «программные» или «неименованные») и именованные. Они по-разному реализованы, но доступ к ним организуется одинаково с помощью обычных функций read и write (унифицированный подход по типу файловой модели). Одним из свойств программных каналов и FIFO является то, что данные по ним передаются в виде потоков байтов (аналогично соединению TCP). Деление этого потока на самостоятельные записи полностью предоставляется приложению (в отличие, например, от очередей сообщений, которые автоматически расставляют границы между записями, аналогично тому, как это делается в дейтаграммах UDP).
		
	\subsubsection{Неименованные каналы}
	Программные (неименованные) каналы – однонаправленные, используются только для связи родственных процессов, в принципе могут использоваться и неродственными процессами, если предоставить им возможность передавать друг другу дескрипторы (т.к. имен они не имеют). Неименованный канал создается посредством системного вызова pipe(2), который возвращает 2 файловых дескриптора filedes[1] для записи в канал и filedes[0] для чтения из канала.
	
	Доступ к дескрипторам канала может получить как процесс, вызвавший pipe() , так и его дочерние процессы. Канал создается одним процессом, может использоваться им единолично (но редко). Как правило, это средство применяется для связи между двумя процессами, следующим образом: процесс создает канал, а затем вызывает fork(), создавая свою копию — дочерний процесс. Затем родительский процесс закрывает открытый для чтения конец канала, а дочерний, в свою очередь, — открытый на запись конец канала. Это обеспечивает одностороннюю передачу данных между процессами. При необходимости передачи данных в обе стороны нужно создавать пару каналов и использовать каждый из них для передачи данных в одну сторону.
	
	Организуем программу (файл pipe.c) так, чтобы процесс-родитель создавал неименованный канал, создавал потомка, закрывал канал на запись и записывал в произвольный текстовый файл считываемую из канала информацию. В функции процесса-потомка будет входить считывание данных из файла и запись их в канал.
	
	Исходный код программы:
	\lstinputlisting[style=crs_cpp]{../listings/pipe.c}
	
	Результат выполнения:
	\lstinputlisting[style=crs_bash]{../listings/pipe}

	Содержимое файла from.txt успешно переписалось в изначально пустой файл to.txt с использованием неименованного канала.	Так как процесс-родитель только читает из канала, то дескриптор для записи (filedes[1]) он закрывает, аналогично процесс-сын в начале работы закрывает дескриптор для чтения из канала (filedes[0]).

	Главное применение неименованных каналов в ОС Unix --– реализация конвейеров команд в интерпретаторах командной строки. Например, при выполнении конвейера ls|sort|grep интерпретатор создаст три процесса с двумя каналами между ними так, что открытый для чтения конец каждого канала будет подключен к стандартному потоку ввода, а открытый на запись — к стандартному потоку вывода.
	
	Пример использования неименнованого канала в командном интерпретаторе. Допустим, нам интересно узнать, какие серверные файлы существуют в каталоге. Для этого используем неименованный канал и утилиту фильтрации вывода \textbf{grep}
	\lstinputlisting[style=crs_bash]{../listings/pipe_bash}
	Первая команда просто выводит список файлов в директории, а вторая команда выводит список файлов не на выходной поток, а через неименованный канал подаёт на вход следующей команды (grep)\\
	
	Однако этот эксперимент не доказывал, что используются именно неименованные каналы. С помощью утилиты \textbf{strace} отследим наличие системного вызова \textbf{pipe()}. Так как за создание канала ответственен интерпретатор, то мы будем подавать утилите именно интерпретатор, в противном случае булут отслежены системные вызовы только первого процесса. Эксперимент состоит из 4 запусков утилиты:
	\begin{itemize}
		\item запуск отдельно утилиты \textbf{cat}
		\item запуск отдельно утилиты \textbf{echo}
		\item совместный запуск через оператор \textbf{|}
		\item совместный запуск с добавлением ещё одной утилиты \textbf{cat}
	\end{itemize}	 
	
	\lstinputlisting[style=crs_bash]{../listings/pipe_proove}
	
	Из эксперимента видно, что количество системных вызовов \textbf{pipe()} равно количеству операторов \textbf{|} при условие, что сами команды не используют внутри неименованные каналы. Из этого следует, что для такого перенаправления потока используются неименованные каналы.\\
	
	Хотя и рекомендовано писать приложения так, чтобы чтение происходило максимально быстро после записи и данные в канале не накапливались, проверить его размер не будет лишним. Для этого напишем программу, которая будет писать в канал по два байта байта и выводить количество записанных байт:
	
	\lstinputlisting[style=crs_cpp]{../listings/pipe_capacity.c}
	
	Ожидаем, что счётчик дойдёт до 65536(значение по умолчанию для Linux 2.6.35 и выше) и там программа либо остановится, либо сгенерирует ошибку:
	\lstinputlisting[style=crs_bash]{../listings/pipe_capacity}
	Результаты совпали с ожиданиями и программа остановилась на 65536, что равно ёмкости канала.\\
	
	Однако помимо ёмкости одного канала интересным аспектом является количество каналов. Основываясь на ошибках возвращаемых функцией \textbf{pipe()}, такого ограничения отдельно в Linux нет, однако оно вытекает из двух других:
\begin{enumerate}
	\item Максимальное количество файловых дескрипторов используемых процессом(из ошибки \textbf{EMFILE})
	\item Максимальное количество файлов, открытых системой (из ошибки \textbf{ENFILE})
\end{enumerate}
	Если второе ограничение проверить сложно, то для первого напишем программу, открывающую дескрипторы, пока pipe() не вернёт ошибку:
	\lstinputlisting[style=crs_cpp]{../listings/pipes.c}
	
	Ожидаем число вдвое меньшее, чем максимальное количество открытых файлов, ведь неименованный канал для открытия требут два файловых дескриптора:
	\lstinputlisting[style=crs_bash]{../listings/pipes}
	Номер ошибки говорит, что лимит открытых файлов на процесс исчерпан, однако мы видим, что лимит 1024, а создано 510 неименованных каналов, т.е. открыто только 1020 файлов. Вероятно, процесс уже использует какие-то файловые дескрипторы. Проверим, добавим \textbf{sleep(60)} перед \textbf{return 0}:
	\lstinputlisting[style=crs_bash]{../listings/pipes_other_fd}
	Мы видим, что у процесса три файловых дескриптора заняты общением с псевдотерминалом. То есть действительно у процесса открыты 1023 файла, что не позволяет открыть ещё два до достижения ограничения.
	
	\subsubsection{Именованные каналы}
	Именованные каналы в Unix функционируют подобно неименованным — они позволяют передавать данные только в одну сторону. Однако в отличие от неименоаванных каналов каждому каналу FIFO сопоставляется полное имя в файловой системе, что позволяет двум неродственным процессам обратиться к одному и тому же FIFO. Аббревиатура FIFO расшифровывается как «first in, first out» — «первым вошел, первым вышел», то есть эти каналы работают как очереди.
	
	После создания канал FIFO должен быть открыт на чтение или запись с помощью либо функции open, либо одной из стандартных функций открытия файлов из библиотеки ввода-вывода (например, fopen). FIFO может быть открыт либо только на чтение, либо только на запись. Нельзя открывать канал на чтение и запись одновременно, поскольку именованные каналы могут быть только односторонними.

	Создать клиент-серверное приложение, демонстрирующее дуплексную (двунаправленную) передачу информации двумя однонаправленными именованными каналами между клиентом и сервером.
	
	В файле server.c в основной программе: создадим 2 именованных канала, используя системный вызов mknod(), аргументы которого: имя файла FIFO в файловой системе; флаги владения, прав доступа (установим открытые для всех права доступа на чтение и на запись \texttt{S\_IFIFO} | 0666). Откроем один канал на запись (chan1), другой - на чтение (chan2) и запустим серверную часть программы.
	
	В серверной части программы: запишем имя файла в канал 1 (для записи) функцией write(); прочитаем данные из канала 2 и выведем на экран.

	В файле client.c запрограммируем функции: открытия каналов для чтения (chan1) и записи (chan2). Из первого канал читается имя файла, во второй канал пишется его содержимое.
	
	Исходный код программы server:
	\lstinputlisting[style=crs_cpp]{../listings/server.c}
		
	Исходный код программы client:
	\lstinputlisting[style=crs_cpp]{../listings/client.c}
	
	Результат работы:
	\lstinputlisting[style=crs_bash]{../listings/serv_cli}
	
	Сервер создает два канала, записывает в один из них имя файла и ждёт данные от клиента. Каналы создаются в рабочей папке сервера, и использовать их может любой процесс, а не только дочерний по отношению к серверу. Клиент после запуска также открывает уже созданные каналы, считывает имя файла и отсылает серверу его содержимое, используя второй канал. После завершения передачи, сервер уничтожает каналы с помощью функции unlink().
	
	Несмотря на то, что именованные каналы являются отдельным типом файлов и могут быть видимы разными процессами даже в распределенной файловой системе, использование FIFO для взаимодействия удаленных процессов и обмена информацией между ними невозможно. Так как и в этом случае для передачи данных задействовано ядро. Создаваемый файл служит для получения данных о расположении FIFO в адресном пространстве ядра и его состоянии.
	
	Продемонстрируем это на примере. Изменим ранее использованную программу так, чтобы сервер, перед тем как читать данные из канала, ожидал ввода пользователя. Исходный код клиента оставим неизменным.

	Исходный код программы server2:
	\lstinputlisting[style=crs_cpp]{../listings/server2.c}

	Запустим клиент и сервер. Пока сервер ожидает ввода, посмотрим размер файла канала.
	\lstinputlisting[style=crs_bash]{../listings/serv_cli2}
 	
 	Размер файла канала не изменяется, несмотря на записанные данные, это свидетельствует о том, что файл используется не как хранилище пересылаемых данных, а только для получения информации системой о них. Сами данные проходят через ядро ОС.
 	
 	После нажатия какой-либо клавиши мы видим, что сервер получил данные:
	\lstinputlisting[style=crs_bash]{../listings/serv_cli2_1}

	На неименованные каналы и каналы FIFO системой накладываются всего два ограничения: \texttt{OPEN\_MAX} --- максимальное количество дескрипторов, которые могут быть одновременно открыты некоторым процессом (POSIX устанавливает для этой величины ограничение снизу); \texttt{PIPE\_BUF} --- максимальное количество данных, для которого гарантируется атомарность операции записи (POSIX требует по менее 512 байт).
	
	Значение \texttt{OPEN\_MAX} можно узнать, вызвав функцию sysconf, его можно изменить из интерпретатора команд или из процесса. Значение \texttt{PIPE\_BUF} обычно определено в заголовочном файле. Для FIFO с точки зрения стандарта POSIX оно представляет собой переменную (ее значение можно получить в момент выполнения программы), зависимую от полного имени файла, поскольку разные имена могут относиться к разным файловым системам, и эти файловые системы могут иметь различные характеристики.

\subsection{Очереди сообщений}
	Очередь сообщений находится в адресном пространстве ядра и имеет ограниченный размер. В отличие от каналов, которые обладают теми же самыми свойствами, очереди сообщений сохраняют границы сообщений. Это значит, что ядро ОС гарантирует, что сообщение, поставленное в очередь, не смешается с предыдущим или следующим сообщением при чтении из очереди. Кроме того, с каждым сообщением связывается его тип. Процесс, читающий очередь сообщений, может отбирать только сообщения заданного типа или все сообщения кроме сообщений заданного типа.
	
	Очередь сообщений можно рассматривать как связный список сообщений. Каждое сообщение представляет собой запись, очереди сообщений автоматически расставляют границы между записями, аналогично тому, как это делается в дейтаграммах UDP. Для записи сообщения в очередь не требуется наличия ожидающего его процесса в отличие от неименованных каналов и FIFO, в которые нельзя произвести запись, пока не появится считывающий данные процесс. Поэтому процесс может записать в очередь какие-то сообщения, после чего они могут быть получены другим процессом в любое время, даже если первый завершит свою работу. С завершением процесса-источника данные не исчезают (данные, остающиеся в именованном или неименованном канале, сбрасываются, после того как все процессы закроют его).
	
	Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очередей сообщений.

	Аналогично предыдущему разделу программа включает 2 файла: серверный и клиентский. В общем случае одновременно могут работать несколько клиентов.
	
	Серверный файл содержит:
	\begin{itemize}
	\item подключение библиотек (см. листинг ниже)
	\item обработчик сигнала SIGINT (с восстановлением диспозиции и удалением очереди сообщений системным вызовом msgctl() для корректного завершения сервера при получении сигнала SIGINT);
	\item основную программу.
	\end{itemize}
далее создается очередь сообщений, используя системный вызов msgget(key, PERM | \texttt{IPC\_CREAT}), организовывается цикл ожидания сообщения и его чтение. Сервер в цикле читает сообщения из очереди (тип = 1) функцией msgrcv() и посылает на каждое сообщение ответ клиенту (тип = 2) функцией msgsnd() . Целесообразно дублировать вывод сообщений на экран для контроля. В случае возникновения любых ошибок функцией kill() инициируется посылка сигнала SIGINT. Обработчик сигнала выполняет восстановление диспозиции сигналов и удаление очереди сообщений системным вызовом msgctl().

	В файле client.c аналогично серверному коду должен быть получен ключ, затем доступ к очереди сообщений, отправка сообщения серверу (тип 1). Затем организовывается цикл ожидания сообщения клиентом с последующим чтением (тип 2).
	
	Таким образом, функции чтения и отправки сообщения реализуются системными вызовами: msgrcv(), msgsnd().
	
	Описание работы сервера: Сервер получает ключ, по имени файла. С помощью ключа и идентификатора = 'Q' получает очередь сообщений и ждет сообщений с типом 1 от клиентов. При получении сообщения сервер выводит его на экран и отсылает обратное сообщение с типом 2, содержащее фразу «ОК».

	Описание работы клиента: Клиент получает ту же очередь, что и сервер и ждет ввода пользователя. Считав ввод, он шлет сообщение с типом 1, содержащее считанные данные и ожидает от сервера подтверждения о принятии.
	
	Исходный код программы server\_key:
	\lstinputlisting[style=crs_cpp]{../listings/server_key.c}

		
	Исходный код программы client\_key
	\lstinputlisting[style=crs_cpp]{../listings/client_key.c}
	
	Работа сервера:
	\begin{lstlisting}[style=crs_bash]
$ ./server    
Using default key file key
Client's request: test_is_here
Client's request: another test
	\end{lstlisting}
	
	Первый клиент:
	\begin{lstlisting}[style=crs_bash]
$ ./client 
Using default key file key
test_is_here
Server's response: OK

	\end{lstlisting}
	
	Другой клиент:
	\begin{lstlisting}[style=crs_bash]
$ ./client 
Using default key file key
another test
Server's response: OK
^C
$
	\end{lstlisting}
	
\subsection{Количественные ограничения средств IPC}
\label{IPClimits}
	Максимальные и минимальные значения констант можно выяснить различными способами, в частности, просматривая соответствующие файлы каталога /proc/sys/kernel.
	
	Наиболее простой способ --– воспользоваться утилитой ipcs с ключом -l.
	\lstinputlisting[style=crs_bash]{../listings/ipcs}
	
	Например, если необходимо определить максимальные размер сообщения и одномоментное количество сообщений в очереди, то, как видим по результатам вывода утилиты, по умолчанию размер одного сообщения не может быть больше 8192 байт, а очередь не может содержать больше 32000 сообщений в один момент времени.
	
\subsection{Семафоры и разделяемая память}
	Рассмотрим несколько вариантов постановки задачи синхронизации доступа к разделяемой памяти.
	
	\subsubsection{Вариант 1}	
	Есть один процесс, выполняющий запись в разделяемую память и один процесс, выполняющий чтение из нее. Под чтением понимается извлечение данных из памяти. Программа должна обеспечить невозможность повторного чтения одних и тех же данных и невозможность перезаписи данных, т.е. новой записи, до тех пор, пока читатель не прочитает предыдущую.
В таком варианте задания для синхронизации процессов достаточно двух семафоров.

	Покажем, почему не достаточно одного на примере. Так как мы используем один семафор, то алгоритм работы читателя и писателя может быть только таким – захват семафора, выполнение действия (чтение / запись), освобождение семафора. Теперь допустим, что читатель прочитал данные, освободил семафор и еще не до конца использовал квант процессорного времени. Тогда он перейдет на новую итерацию, снова захватит только что освобожденный семафор и снова прочитает данные --– ошибка.
	
	Теперь покажем, почему достаточно двух семафоров. Придадим одному из них смысл «запись разрешена», т.е. читатель предыдущие данные уже использовал; второму –-- «чтение разрешено», т.е. писатель уже сгенерировал новые данные, которые нужно прочитать.
	
	Оба семафора бинарные и используют стандартные операции, захват семафора --– это ожидание освобождения ресурса (установки семафора в 1) и последующий захват ресурса (установки семафора в 0), освобождение ресурса --– это установка семафора в 1.

	Пару семафоров, использованных таким образом, иногда называют разделенным бинарным семафором, поскольку в любой момент времени только один из них может иметь значение 1.
	
	При таком алгоритме работы, оба процесса после выполнения своей задачи и освобождения одного из семафоров, будут ждать освобождения другого семафора, которое произведет другой процесс, но только после выполнения своей работы. Таким образом повторное чтение, или повторная запись стала невозможной.
	
	Исходный код программы reader:
	\lstinputlisting[style=crs_cpp]{../listings/reader.c}
		
	Исходный код программы writer:
	\lstinputlisting[style=crs_cpp]{../listings/writer.c}
	
	Поток писатель-1:
	\begin{lstlisting}[style=crs_bash]
$ ./writer 
Using default key file key
Type message to serever. Empty string to finish
1: Hello 
Type message to serever. Empty string to finish
1: Do you hear me?
Type message to serever. Empty string to finish

bye-bye
	\end{lstlisting}
	
	Поток писатель-2:
	\begin{lstlisting}[style=crs_bash]
$ ./writer 
Using default key file key
Type message to serever. Empty string to finish
1: Hello 
Type message to serever. Empty string to finish
1: Do you hear me?
Type message to serever. Empty string to finish

bye-bye
	\end{lstlisting}
	
	Поток читатель:
	\begin{lstlisting}[style=crs_bash]
$ ./reader 
Using default key file key
Client's message: 1: Hello
Client's message: 2: Hi
Client's message: 1: Do you hear me?
Client's message: 2: nope

^Cexecution complete
	\end{lstlisting}
	
	Все сообщения от клиента сервером прочитаны.
	
	\subsubsection{Вариант 2}
	К условиям предыдущей задачи добавляется условие корректной работы нескольких читателей и нескольких писателей одновременно. Как и в предыдущем варианте под чтением понимается извлечение данных из памяти, т. е. одну порцию данных может прочитать только один читатель.

	Легко понять, что это условие не приводит к необходимости использования дополнительных средств синхронизации. Теперь вместо одного процесса, за каждый семафор будут конкурировать несколько. Но повторная запись или чтение все также невозможно. Так как, чтобы очередной процесс-писатель отработал, нужно освобождение семафора, которое выполняется из процесса-читателя, и наоборот.
	
	\subsubsection{Вариант 3}	
	К условиям предыдущей задачи добавляется наличие не единичного буфера, а буфера некоторого размера. Тип буфера (очередь, стек, кольцевой буфер) не имеет значения.
	
	Двух семафоров по прежнему достаточно, но это приведет к вырождению буфера, так как все процессы будут работать только с одной ячейкой.
	
	Так как размер буфера не равен единице, то больше нет необходимости в чередовании операций чтения и записи, допустима ситуация нескольких записей подряд, и после этого нескольких чтений. Нужно только следить, чтобы не было записи в уже заполненный буфер и не было чтения из пустого буфера. Для этого выберем другие типы семафора и придадим им другую семантику. Возьмем два считающих семафора. Максимальное значение обоих – размер буфера. Первый инициализируется нулем и имеет смысл «количество заполненных ячеек», второй инициализируется N, где N – размер буфера и имеет смысл «количество пустых ячеек». Процессы-читатели перед своей работой захватывают семафор «количество заполненных ячеек», т.е. ждут появления хотя бы одной порции данных, а после чтения освобождают семафор «количество пустых ячеек». Процессы- писатели перед записью захватывают семафор «количество пустых ячеек», т.е. ждут появления хотя бы одной пустой ячейки для записи, а после записи освобождают семафор «количество полных ячеек». Таким образом, решается проблема чтения из пустого буфера и запись в полный.
	
	Так как семафоры не бинарные, захватить их может сразу несколько процессов, т.е. несколько процессов попадут в секцию записи или чтения. В этом случае, если операция записи или чтения не атомарная (а зачастую так оно и есть), может произойти нарушение нормальной работы программы, к примеру, несколько процессов-писателей попытаются произвести запись в одну и ту же ячейку буфера, или несколько читателей выполнят чтение одной и той же ячейки. Таким образом, операции записи-чтения становятся критическими секциями, доступ к которым также необходимо синхронизировать. Для этого будет достаточно еще одного бинарного семафора, имеющего смысл «доступ к памяти разрешен». Оба типа процессов должны захватывать его при попытке взаимодействия с памятью и освобождать после.
	
	Важно отметить, что порядок операций освобождения семафоров не важен, в то же время изменение порядка захвата семафоров может привести к взаимной блокировке процессов (dead lock). Взаимная блокировка в частности может произойти в таком случае: процесс-читатель захватил семафор «доступ к памяти разрешен», далее он проверяет, есть ли заполненные ячейки, т.е. пытается захватить семафор «количество заполненных ячеек», предположим, что свободных ячеек не оказалось и процесс переключился в неактивный режим, ожидая пока какой-нибудь процесс-писатель не запишет данные и не освободит семафор «количество заполненных ячеек». Но, этого никогда не произойдет, так как перед записью данных, процесс-писатель должен захватить семафор «доступ к памяти разрешен», который уже захвачен ожидающим процессом-читателем.
	
	Пример решения последнего варианта задачи. В качестве разделяемого ресурса используется массив, находящийся в разделяемой памяти, ячейка памяти, находящаяся за последним элементом массива интерпретируется как индекс последнего записанного элемента.
	
	Исходный код программы reader2:
	\begin{lstlisting}[style=crs_cpp]
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/time.h>
#include "shm.h"

int* buf;
int shmemory;
int semaphore;

void intHandler(int sig) {
	shmdt(buf);
	shmctl(shmemory, IPC_RMID, 0);
	semctl(semaphore, 0, IPC_RMID);
}

int main(int argc, char** argv) {
	char keyFile[100];
	bzero(keyFile,100);
	if(argc < 2) {
		printf("Using default key file %s\n",DEF_KEY_FILE);
		strcpy(keyFile,DEF_KEY_FILE);
	} else strcpy(keyFile,argv[1]);
	key_t key;
	//uses same key for semaphore and shm
	if((key = ftok(keyFile, 'Q')) < 0) {
		printf("Can't get key for key file %s and id 'Q'\n",keyFile);
		exit(1);
	}
	//creates shm
	if((shmemory = shmget(key, (BUF_SIZE+1)*sizeof(int), IPC_CREAT | 0666)) < 0) {
		printf("Can't create shm\n");
		exit(1);
	}
	//connect shm to our adress space
	if((buf = (int*)shmat(shmemory, 0, 0)) < 0) {
		printf("Error while attaching shm\n");
		exit(1);
	}
	// sets signal wrapper
	signal(SIGINT, intHandler);
	//create group of 3 symophores
	//1 - number of free slots
	//2 - number of busy slots
	// 3 memmory processing
	if((semaphore = semget(key, 3, IPC_CREAT | 0666)) < 0) {
		printf("Error while creating semaphore\n");
		kill(getpid(),SIGINT);
	}
	// sets index to -1, first client to write will set it to 0
	buf[BUF_SIZE] = -1;
	// init array -1
	int j = 0;
	for(j = 0; j < BUF_SIZE; ++j) {
		buf[j] = -1;
	}
	// sets 1 syaphor to the number of free slots, we can write
	if(semop(semaphore, setFree, 1) < 0) {
		printf("execution complete\n");
		kill(getpid(),SIGINT);
	}
	// tell that memmory is free
	if(semop(semaphore, mem_unlock, 1) < 0) {
		printf("execution complete\n");
		kill(getpid(),SIGINT);
	}
	printf("Press enter to start working\n");
	getchar();
	// main loop
	int i = 0;
	for(i = 0; i < 15; ++i) {
		// wait for firs not empty slot
		if(semop(semaphore, waitNotEmpty, 1) < 0) {
			printf("execution complete\n");
			kill(getpid(),SIGINT);
		}
		// wait for oportunity to proccess memmory
		if(semop(semaphore, mem_lock, 1) < 0) {
			printf("execution complete\n");
			kill(getpid(),SIGINT);
		}
		//read client message
		int res = buf[buf[BUF_SIZE]];
		buf[BUF_SIZE] = buf[BUF_SIZE] - 1;
		printf("Remove %d from cell %d\n", res,buf[BUF_SIZE]+1);
		// free the memory
		if(semop(semaphore, mem_unlock, 1) < 0) {
			printf("execution complete\n");
			kill(getpid(),SIGINT);
		}
		// sets number of free slots
		if(semop(semaphore, releaseEmpty, 1) < 0) {
			printf("execution complete\n");
			kill(getpid(),SIGINT);
		}
	}
}
	\end{lstlisting}
		
	Исходный код программы writer2:
	\begin{lstlisting}[style=crs_cpp]
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include "shm.h"

int* buf;

int main(int argc, char** argv) {
	char keyFile[100];
	bzero(keyFile,100);
	if(argc < 2) {
		printf("Using default key file %s\n",DEF_KEY_FILE);
		strcpy(keyFile,DEF_KEY_FILE);
	} else strcpy(keyFile,argv[1]);
	key_t key;
	int shmemory;
	int semaphore;
	//uses same key for semaphore and shm
	if((key = ftok(keyFile, 'Q')) < 0) {
		printf("Can't get key for key file %s and id 'Q'\n",keyFile);
		exit(1);
	}
	//create shm
	if((shmemory = shmget(key, (BUF_SIZE+1)*sizeof(int), 0666)) < 0) {
		printf("Can't create shm\n");
		exit(1);
	}
	//connect shm to our memory space 
	if((buf = (int*)shmat(shmemory, 0, 0)) < 0) {
		printf("Error while attaching shm\n");
		exit(1);
	}
	if((semaphore = semget(key, 2, 0666)) < 0) {
		printf("Error while creating semaphore\n");
		exit(1);
	}
	printf("Press enter to start working\n");
	getchar();
	int send = 0;
	char tb[10];
	int i = 0;
	for(i = 0; i < 10;++i) {
		//wait for first free slot
		if(semop(semaphore, waitNotFull, 1) < 0) {
			printf("Can't execute a operation\n");
			exit(1);
		}
		// wait for access to shared memmory
		if(semop(semaphore, mem_lock, 1) < 0) {
			printf("Can't execute a operation\n");
			exit(1);
		}
		printf("Add %d to cell %d\n",send,buf[BUF_SIZE]+1);
		++buf[BUF_SIZE];
		buf[buf[BUF_SIZE]] = send++;
		//free the access to memmory
		if(semop(semaphore, mem_unlock, 1) < 0) {
			printf("Can't execute a operation\n");
			exit(11);
		}
		//set number of busy slots
		if(semop(semaphore, releaseFull, 1) < 0) {
			printf("Can't execute a operation\n");
			exit(11);
		}
	}
	//dissconects from shared memmory
	shmdt(buf);
}
	\end{lstlisting}
	
	Поток писатель-1:
	\begin{lstlisting}[style=crs_bash]
$ ./writer2
Using default key file key
Press enter to start working
36
Add 0 to cell 0
Add 1 to cell 1
Add 2 to cell 2
Add 3 to cell 3
Add 4 to cell 4
Add 5 to cell 0
Add 6 to cell 1
Add 7 to cell 2
Add 8 to cell 3
Add 9 to cell 4
	\end{lstlisting}
	
	Поток писатель-2:
	\begin{lstlisting}[style=crs_bash]
$ ./writer2
Using default key file key
Press enter to start working
Add 0 to cell 0
Add 1 to cell 1
Add 2 to cell 2
Add 3 to cell 3
Add 4 to cell 4
Add 5 to cell 0
Add 6 to cell 1
Add 7 to cell 2
Add 8 to cell 3
Add 9 to cell 4
	\end{lstlisting}
	
	Поток читатель:
	\begin{lstlisting}[style=crs_bash]
$ ./reader 
Using default key file key
Press enter to start working
Remove 4 from cell 4
Remove 3 from cell 3
Remove 2 from cell 2
Remove 1 from cell 1
Remove 0 from cell 0
Remove 9 from cell 4
Remove 8 from cell 3
Remove 7 from cell 2
Remove 6 from cell 1
Remove 5 from cell 0
Remove 4 from cell 4
Remove 3 from cell 3
Remove 2 from cell 2
Remove 1 from cell 1
Remove 0 from cell 0
	\end{lstlisting}
	
	Процессы-писатели записывают по 10 чисел в массив, процесс-писатель считывает первые 15 из записанных. По результатам синхронизация работает корректно, выхода за пределы массива нет, записанные данные не затираются до их прочтения. К примеру, в нулевую ячейку сначала первый поток-писатель записал 0, потом он же записал 5, а потом второй поток-писатель записал также 0. Все данные были прочитаны.

\subsection{Сокеты}
	Далее будут использоваться две машины, находящиеся в одной локальной сети.
	Характеристики первой:
	\begin{lstlisting}[style=crs_bash]
$ uname -or
4.4.6-300.fc23.x86_64 GNU/Linux
$ /usr/sbin/ifconfig | grep -A1 wlp
wlp2s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.197  netmask 255.255.255.0  broadcast 192.168.1.255
    \end{lstlisting}
	
	Характеристики второй:
	\begin{lstlisting}[style=crs_bash]
$ uname -or
4.4.6-300.fc23.x86_64 GNU/Linux
$ ifconfig | grep -A1 ^br0
br0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.97  netmask 255.255.255.0  broadcast 192.168.1.255
    \end{lstlisting}
\subsubsection{TCP}	
	Сервер прослушивает заданный порт, при приходе нового соединения, создается новый поток для его обработки. Работа с клиентом организована как бесконечный цикл, в котором выполняется прием сообщения от клиента, вывод его на экран и пересылка обратно клиенту.
	
	Клиентская программа после установления соединения с сервером также в бесконечном цикле выполняет чтение ввода пользователя, пересылку его серверу, и получение работы. Если была введена пустая строка, клиент завершается.
	
	Исходный код программы tcp\_server:
	\lstinputlisting[style=crs_cpp]{../listings/tcp_server.c}
		
	Исходный код программы tcp\_client:
	\lstinputlisting[style=crs_cpp]{../listings/tcp_client.c}
	
	Для взаимодействия используются TCP сокеты, это значит, что между сервером и клиентом устанавливается логическое соединение, при этом при получении данных из сокета с помощью вызова recv, есть вероятность получить сразу несколько сообщений, или не полностью прочитать сообщение. Поэтому для установления взаимной однозначности между отосланными и принятыми данными используются функции recvFix и sendFix. Принцип их работы следующий: функция sendFix перед посылкой собственно данных посылает «заголовок» - количество байт в посылке. Функция recvFix вначале принимает этот «заголовок», и вторым вызовом recv считывает переданное количество байт. Считать ровно то, количество байт, которое указанно в аргументе функции recv, позволяет флаг \texttt{MSG\_WAITALL}. Если его не использовать и данных в буфере недостаточно, то будет прочитано меньшее количество.
	
	Клиент на первой машине:
	\lstinputlisting[style=crs_bash]{../listings/tcp_log_same_client}
	
	Клиент на второй машине:
	\lstinputlisting[style=crs_bash]{../listings/tcp_log_diff_client}
	
	Сервер на первой машине:
	\lstinputlisting[style=crs_bash]{../listings/tcp_log_server}
	
	Из результатов работы видно, что сообщения были доставлены, и прочитаны целиком. Все сетевые проблемы в данном случае лежат на плечах TCP. Программисту не нужно думать о перемешивание, потере и дублирование пакетов.\\
	
	\subsubsection{UDP}	
	Протокол UDP не предоставляет подобной надёжности. И в пределах идеальной сети он будет работать безотказно, но даже локальные сети не идеальны. Реализация эхо сервера без обеспечения дополнительной надёжности на прикладном уровне вряд ли будет вполне работоспособной. Поэтому в данной реализации введена некоторая защита:
	Исходный код программы udp/server.c:
	\lstinputlisting[style=crs_cpp]{../listings/udp/server.c}
		
	Исходный код программы udp/client.c:
	\lstinputlisting[style=crs_cpp]{../listings/udp/client.c}
	
	Заголовок сетевой библиотеки:
	\lstinputlisting[style=crs_cpp]{../listings/udp/enet.h}
	
	Реализация сетевой библиотеки:
	\lstinputlisting[style=crs_cpp]{../listings/udp/enet.c}	
	
	Для взаимодействия используются UDP сокеты, это значит, что между сервером и клиентом не устанавливается логическое соединение. Но оно организовано на прикладном уровне: поток аксепта заменён на поток генерации новых сокетов на новых портах и перенаправления дальнейшего общения с данным клиентом. Таким образом основной порт служит лишь точкой входа, реальное общение происходит на отдельных портах, с каждым клиентом индивидуально. Этот подход плох тем, что для каждого клиента используется отдельный случайный порт, что может привести к конфликтам с межсетевыми экранами и корреляции с портами других приложений. 
	
	Клиент на первой машине:
	\lstinputlisting[style=crs_bash]{../listings/udp/log/same_client}
	
	Клиент на второй машине:
	\lstinputlisting[style=crs_bash]{../listings/udp/log/diff_client}
	
	Сервер на первой машине:
	\lstinputlisting[style=crs_bash]{../listings/udp/log/server}
	
	Данные результаты были получены не сразу. Политика безопасности сервера была выстроена так, что незнакомые UDP пакеты он отбрасывал.	
	Протокол UDP намного проще TCP, так как не следит за доставкой, дублированием, перемешиванием пакетов. Его использование обоснованно в случаях, когда подобные недостатки не важны, а приоритет имеют скорость передачи и снижение нагрузки (голосовой чат, он-лайн игры, dns запросы). Однако в некоторых случаях надёжность схожая с TCP реализуется на прикладном уровне(TFTP).
	
\section{Вывод}
	В ОС Unix адресные пространства различных процессов изолированы друг от друга. Для взаимодействия процессов используются специальные средства IPC, включающие в себя сигналы, именованные и неименованные каналы, сообщения, сокеты, семафоры и разделяемую память.
	
	В Unix поддерживается два вида сигналов: надёжные и ненадёжные. Ненадежные сигналы более просты в использовании, в тоже время надежные сигналы позволяют отложить прием других сигналов до окончания обработки текущего.
	
	Сигналы самое простое средство IPC, являются достаточно медленными и ресурсоёмкими, не позволяют передавать произвольные данные, служат главным образом для уведомления, обработки нештатных ситуаций и синхронизации.
	
	Именованные и неименованные каналы реализуют запись и чтение по принципу FIFO. Запись и чтение, таким образом, происходит быстро, однако при создании канала затрачивается несколько больше времени. Кроме того, каналы работают в полудуплексном режиме, т.е. передают данные только в одну сторону. Каналы FIFO представляют собой вид IPC, который может использоваться только в пределах одного узла. Хотя FIFO и обладают именами в файловой системе, они могут применяться только в локальных файловых системах

	Сообщения являются мощным средством межпроцессного обмена данными. Время доставки сообщения сравнимо с временем доставки сигнала, однако сообщение несёт гораздо больше информации, чем сигнал. С помощью сообщений гораздо проще организовать асинхронный обмен данными между процессами, чем с помощью каналов.
	
	Семафоры и разделяемая память зачастую используются вместе. Семафоры позволяют синхронизировать доступ к разделяемому ресурсу и гарантировать «взаимноеисключение» нескольких процессов при разделении ресурса (пока предыдущий процесс не закончит работу с ресурсом, следующий не начнет ее).
	
	Сокеты являются средством IPC, которое можно использовать не только между процессами на одном компьютере, но и в сетевом режиме. Многие сетевые приложения построены на основе сокетов.


\section{Список литературы}
\begin{itemize}
\item Душутина Е.В.  Межпроцессные взаимодействия в операционных системах – СПб, 2014 г, 136 с.
\item Душутина Е.В.  Практические вопросы оазработки системных приложений – СПб, 2015 г, 165 с.
\item Таненбаум Э., Бос Х. Современные операционные системы. 4-е изд. – СПб.: Питер, 2015 – 1120 с.
\end{itemize}
\end{document}

