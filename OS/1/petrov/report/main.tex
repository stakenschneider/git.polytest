\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}
\usepackage{listings}
\lstset{ %
language=bash,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm] % название работы, затем отступ 0,6см
\large Отчет по лабораторной работе №1\\[0.1cm]
\large Операционные системы и среды\\[5cm]
% тема работы, затем отступ 3,7см
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Команды работы с файлами}
\subsection{Создание регулярных файлов}
\subsubsection{Touch}
Для создания регулярнього файла можно воспользоваться утилитой \textbf{touch}
\lstinputlisting{../listings/touch}
Однако, основной задачей утилиты является корректировка временн\'{ы}х параметров. Флаг -a позволяет менять только время доступа, -m - модификации. Без указания каких-либо ключей утилита обновит времена доступа и модификации до текущего.
Если указанного файла не существует, он будет создан, если в комманде не указаны флаги -c (не создавать файлы) или -h (обновлять времена символьной ссылки).
Самое популярное из известных мне применений - установление времени для уточнения поиска(обход шага утилиты \textbf{find} в день). Более подробное описание функций, отличных от создания файла, приведены в соответствующих разделах.
\subsubsection{Перенаправление потока}
Создать новый регулярный фаил возможно перенаправив в него консольный вывод.
\lstinputlisting{../listings/redirect}
В данном случае создается новый фаил, но при использованном виде перенаправления мы бы стёрли содержимое старого файли с этим именем, если бы он был. Любой другой вид перенаправления также способен создать регулярный фаил. Не менее интересна для перенаправления потока утилита tee, сбособная одновременно записывать в фаил и выводить поток в консоль.
\subsubsection{ Редакторы}
Сохранение с помощью тектового редактора, например, vim(vi), emacs, nano, mcedit.
\subsubsection{ Не с нуля}
\label{subsec:not_null}
Создать новый фаил можно скопировав уже существующий, для этого воспользуемся утилитой \textbf{cp}
\lstinputlisting{../listings/cp}
Позволяет копировать и файлы во вложенных директориях при флагах рекурсивности -r или -R.
\subsection{Создание директорий}
Директория в ОС Linux тоже является файлом, однако отличным от регулярного.
Для созданий директорий предусмотрена утилита \textbf{mkdir}.
\lstinputlisting{../listings/mkdir}
Утилита при флаге -m умеет устанавливать права так же как и \textbf{chmod}. Рассмотрим на примере:
\lstinputlisting{../listings/mkdir_m}
Видно, что директория была создана без прав записи для пользователя, за что и отвечает \textbf{u-w}: пользователя(u) лишить(-) права записи(w). 

Ещё один полезный флаг -p, он позволяет создать сразу серию вложенных папок, а не каждую по отдельности. Рассмотрим создание вложенных папок:
\lstinputlisting{../listings/mkdir_p}
Видно, что создать вложенные папки без дополнительного флага не получается.

Копирование директорий не отличается от копирования файлов.
\subsection{Создание жёстких ссылок}
\label{subsec:hl}
Создание жёской ссылки принципиально отличается от копирования файла. Теперь мы создаём указатель на inode всё того же файла. Т.е. в системе будут видны несколько файлов, но сам фаил на диске будет всего один, таким образом изменения одного изменят и остальные. Однако нельзя создать жёсткую ссылку на директорию.

Создание жёсткой ссылки доступно с помошью утилиты \textbf{ln}, это её стандартая функция.
\lstinputlisting{../listings/ln}
У данной утилиты есть специальный флаг -d для создания жёсткой ссылки на директорию с правами суперпользователя, однако даже так в моей системе не удалось создать ссылку. Эта возможность закрыта, так как наличие такой ссылки может привести к нестабильной работе как ФС, так и самой ОС.
Флаг -P позволяет создать жёсткую  ссылку не на фаил, на который ссылается символьная ссылка, а на саму символьную ссылку.

Альтернативный способ создания жёсткой ссылки - использования утилиты копирования - \textbf{cp} с флагом -l

\subsection{Создание символьных ссылок}
\label{subsec:sl}
Символьная ссылка является полноценным файлом, но ссылающимся на другой фаил.
В отличие от жёстких ссылок, может указывать на директорию.

Для создания используется та же утилита создания ссылок \textbf{ln}, но с флагом -s
\lstinputlisting{../listings/lns}

Особый интерес представляет флаг -r, ответственный за создание относительных символьных ссылок. крайне полезно при компановке разного рода перемещаемых структур.

Альтернативный способ создания символьной ссылки - использования утилиты копирования - \textbf{cp} с флагом -s
\subsection{Создание файлов устройств}
Мной в пределах системы Fedora 22 workstation (4.1.10 200.fc22.x86 64) была найдена только документация на пакет makedev, который, видимо, отсутствует, так как не доступен даже из под рута. Скорее всего, это системный вызов, необходимость в котором в пределах терминала крайне мала. В описание говорится о том, что эта функция генерирует ID устройства из мажорного и минорного ID.

Все известные мне файлы устройств или символьные ссылки на них лежат в каталоге /dev

\subsection{Создание FIFO файлов}
Файл FIFO, он же именованный pipe может быть создан с помощью утилиты \textbf{mkfifo}. Из интересных нам флагов у неё есть только один- -m. Он ответственен за установку прав. Отличается от chmod отсутствием битов исполняемости.

Для работы с пайпом нам потребуется либо многозадачность в одном терминале, либо несколько терминалов, так как передача не закончится, пока мы не инициализируем чтение. Пойдём по первому пути:

\lstinputlisting{../listings/mkfifo}

\subsection{Создание socket файлов}
Создание сокетов предусмотрено системными вызовами и не является функционалом часто необходимом в терминале. Однако в репозиториях доступна утилита \textbf{socat}, позволяющая создать сокет из консоли. Здесь мы лишь убедимся, что фаил создаётся.

\lstinputlisting{../listings/socat}
\subsection{ Изменение файлов}
\subsubsection{ Перемещение}
За перемещение файлов ответственна утилита \textbf{mv}. Но в ОС Linux есть одна особенность, тут нет утилиты переименования файла. Вместо изменения имени используется перемещения файла. Этот пример сейчас и рассмотрим:
\lstinputlisting{../listings/mv}
Интересный флаг утилиты -u, он позволяет переместить в директорию назначения только те файлы, что новее там уже имеющихся.
\subsubsection{ Копирование}
Пример работы утилиты \textbf{cp} мы уже рассматривали в разделе \ref{subsec:not_null}. И упоминали возможность создания с помощью неё жёстких и символьных ссылок в разделах \ref{subsec:hl} и \ref{subsec:sl}, соответственно.

Сейчас рассмотри аргумент --attributes-only, позволяющий копировать не сам файл, а только его атрибуты.
\lstinputlisting{../listings/cpao}
из примера видно, что использование только этого аргумента не заменяет атрибуты уже существующего файла.
\subsubsection{ Удаление}
Для удаления файлов всех типов существует утилита \textbf{rm}, однако директории требуют отдельного внимания: наличия аргумента -r или -R.
\lstinputlisting{../listings/rm}
Полезным и часто используемым является флаг -f, позволяющий избежать интерактивных вопросов от утилиты. Однако стоит с осторожность относится к сочетанию rm -rf, так как известны случаи неумышленного удаления всей системы с диска, например, при появление пробела в команде rm -rf /opt/programm/temp. Получалось что у системы требовали удалить /, а потом opt/programm/temp.

\subsection{ Поиск файлов}
\subsubsection{ list}
\label{list}
Начнём с самого простого, с просмотра файлов, имеющихся с открытой сейчас директории. Для этого воспользуемся утилитой \textbf{ls}
\lstinputlisting{../listings/ls}
В моей системе файлы разных типов и прав имеют разные цвета:
\begin{itemize}
\item регулярный - белый
\item регулярный исполняемый - зелёный
\item директория - синий
\item символьная ссылка - голубой
\item устройства - рыжий
\item FIFO - жёлтый
\item SOCKET - фиолетовый
\end{itemize}
Однако все эти параметры можно отображаются не только цветом. С помощью флага -l мы получим длинный формат вывода, который гораздо более подробен.
\lstinputlisting[language=bash, frame=single]{../listings/lsl}
Формат вывода:


TUUUGGGOOOS   00  UUUUUU GGGGGG \#\#\#\# @@@ @@ @@:@@  \$\$\$\$\$\$\$ 
\begin{itemize}
\item T - тип файла
\item UUU - Биты Чтения, Записи и Исполнения для пользователя
\item GGG - Биты Чтения, Записи и Исполнения для группы
\item OOO - Биты Чтения, Записи и Исполнения для остальных
\item S - Альтернативный доступ (setuid, setgid или sticky bit)
\item 00 - Количество ссылок
\item UUUUUU - Пользователь (владелец)
\item GGGGGG - Группа
\item \#\#\#\# - Размер
\item @@@ @@ @@:@@ - Время модификации
\item \$\$\$\$\$\$\$ - Имя
\end{itemize}

Таким образом мы увидели несколько типов файлов:
\begin{itemize}
\item $-$ - регулярный файл
\item d - директория
\item p - именованный канал (FIFO)
\item l - символьная ссылка
\item s - Socket
\item c - символьное устройство
\item b - блочное устройство
\end{itemize}
В этом списке отсутствует исполняемый файл, так как является разновидностью регулярного(в битах прав мы видим "х"), и жёсткая ссылка, так как она является столь же равноправны указателем на inode как и тот, что был создан вместе с файлом.

Количество ссылок у папки начинается с двух, так как на папку ссылаются с уровня выше и папка содержит ссылку на себя ".", а каждая подпапка будет содержать ссылку на папку уровнем выше "..". Таким образом количество ссылок на папку равно 2+n, где n - количество подпапок. Вышеупомянутые ссылки можно увидеть использовав флаг -a.

\lstinputlisting{../listings/lsa}

Если нас интересует не содержимое конкретной папки, а её характеристики, то можно использовать флаг -d:
\lstinputlisting{../listings/ls_d}

\subsubsection{ find}
Если утилита \textbf{ls} выводила список всех файлов в директории, а мы сами искали нужный файл, то утилита \textbf{find} будет искать по заданным критериям начиная с указанной директории и глубже.
Основные критерии поиска
\begin{itemize}
\item Имя -name
\item Права -perm
\item Пользователь -user (-nouser)
\item Группа -group (-nogroup)
\item Тип -type
\item Размер -size
\item Время модификации -mtime
\end{itemize}
Выполним поиск по имени в активном каталоге и ниже:
\lstinputlisting{../listings/find}
Найдём все файлы старше 3 дней в активном каталоге и ниже
\lstinputlisting{../listings/findm}
Найдём все именованные каналы в активном каталоге и ниже
\lstinputlisting{../listings/findt}

Данная утилита честно проверит каждый файл в указанной директории и ниже, однока по умолчанию она не переходит по символическим ссылкам. Однако, мы можем указать флаг -L, после чего утилита будет переходить и по символьным ссылкам. В таком режиме искать по типу символьной ссылки бесполезно, только если ссылка не сломана. 

\subsubsection{ locate}
Утилита \textbf{locate} специализируется на быстром поиске по имени. Основним отличием от \textbf{find} является способ поиска. Он происходит по индексам. Раньше такой подход был крайне удобен на персональных компьютерах, так как периодическое обновление индексов cron работой не было сильно заметным, а диски были медленными. Сейчас же во время ssd дисков скорость работы утилиты \textbf{find} является вполне удовлетворительной. Но, справедливости ради, замечу, что на моей системе утилита есть и работает корректно.

В связи с этим на многих современных дистрибутивах индексы для утилиты locate не обновляются по умолчанию, так что и я воздержусь от более подробного её рассмотрения.
\section{Цикл обработки программы}
Цикл обработки программ будем рассматривать на примере "родного" для OS Linux языка С, так как он первоначально был разработан для реализации операционных систем UNIX.
\subsection{Компилятор}
Для начала узнаем, какой же компилятор система использует по умолчанию:
\lstinputlisting{../listings/which}
Теперь мы знаем, что имеем дело с GNU project C and C++ compiler. Т.е. для нас он подходит.
\subsection{Hello,  world!}
Напишем простейшую программу hello.c, выводящую неформатированную строку:
\lstinputlisting[language=c, frame=single]{../listings/hello.c}
Попробуем скомпилировать без каких либо аргументов.
\lstinputlisting{../listings/purecc}
Мы видим, что был создан файл a.out (reasons!). Он сразу имеет права на исполнение.

Если просто написать название программы, мы не сможем её запустить, так как bash попробует найти такую программу в пределах переменной окружения PATH и, скорее всего, не найдёт. Для запуска необходимо указать путь до нашего исполняемого файла. Проще всего это сделать через ссылку на директорию в которой он находится (подразумевается, что именно она сейчас текущая):
\lstinputlisting{../listings/aout}
Но можно указать и полный путь:
\lstinputlisting{../listings/aoutf}
\subsection{ Препроцессор}
Препроцессор - отдельная программа \textbf{cpp}, которая автоматически вызывается компилятором вначале процесса компиляции. Команды препроцессора начинаются с символа \#. Две самых известных \#define и \#include. Первая подставляет во всём коде определённое в рамках команды значение, а вторая подставляет код, на который ссылалась.

\subsection{Объектные файлы: компилятор}
Объектный файл - артефакт процесса получения исполняемого файла из исходного кода. Объектный файл содержит в себе уже машинные команды, так как является результатом работы ассемблера. Но отличием от исполняемого является наличие информации для линковщика. Существование объектного файла обеспечено тем, что мы не храним весь код в одном месте, а подключаем различные библиотеки и файлы.

Подключив библиотеку препроцессором мы вставили только объявления функций, а самих реализаций в нашей программе ещё нет.

Запустить такой файл на исполнение без усилий не получится, так как помимо машинных команд в нём присутствует информация для линковщика и, наверняка, отсутствуют реализации функций, на которые мы вызывали.

Пример создания:
\lstinputlisting{../listings/obj}
Из примера видно, что просто запустить объектный файл не удалось. 
\subsection{Сборка всех воедино: линковщик}
Линковщик - отдельная программа \textbf{ld}, автоматически вызываемая компилятором. Задача линковщика - соединить вместе все необходимый объектные файлы в бинарный исполняемый файл. Объектные файлы бывают собранные компилятором из нашего исходного кода и собранные заранее в библиотеку.
\lstinputlisting{../listings/lnk}
Именно на этом этапе мы добавили реализацию функции puts в нашу программу.

\section{Файловый состав ОС, интерпритаторы}
Общение с системой мы подразумеваем через терминал. Для работы терминала необходима командная оболочка(интерпретатор командной строки). Попробуем узнать, какой мы пользуемся сейчас:
\lstinputlisting{../listings/bsh}
Все 4 варианта указывают на то, что используется bash

Можем попробовать узнать, какие ещё командные оболочки нам доступны:
\lstinputlisting[]{../listings/sh}
\begin{itemize}
\item bash - GNU Bourne-Again SHell
\item csh - символьная ссылка на tcsh
\item sh - символьная ссылка на bash
\item tcsh -C shell with file name completion and command line editing
\end{itemize}

Таким образом мы имеем два шелла: \textbf{bash}(поставляется с системой) и \textbf{tcsh}. C shell не поставляется вместе с ОС, но был установлен отдельно:
\lstinputlisting[]{../listings/instl}

KornShell(\textbf{ksh}), Z shell(\textbf{zsh}) не были найдены.

Попасть в другой интерпретатор можно, вызвав его. Однако, есть утилиты \textbf{chsh} b \textbf{lchsh}, позволяющие пометь интерпретатор по умолчанию.

\subsection{Иерархия}
В операционных система Linux иерархия каталогов построена по стандарту Filesystem Hierarchy Standard. Рассмотрим список основных подкаталогов корневого каталога:
\begin{itemize}
\item /etc - настройки
\item /home - домашние каталоги
\item /root - домашний каталог суперпользователя
\item /bin - базовые утилиты
\item /sbin - сервисные утилиты
\item /usr - общая часть программ, библиотеки, исходники, мануалы
\item /var - изменяемые файлы (логи, временные)
\item /boot - неизменяемые файлы, необходимые для загрузки системы
\item /dev - файлы устройств
\item /lib - разделяемые библиотеки и модули ядра
\item /opt - дополнительные программы
\end{itemize}

Одна из важных особенностей данной иерархии - наличие только одного корневого каталога. Корневые каталоги других файловых систем монтируются в точки монтирования доступные в исходной. Так, примонтировав одну дополнительную ФС, в ней можно монтировать следующую, но это не считается хорошей практикой.

Типы файлов рассматривались ранее, в пункте \ref{list}.

\section{Запуск script}
\textbf{Script} - утилита записи происходящего в консоли (как ввода, так и вывода). Для своей работы утилита открывает "дочерний"  интерпретатор командной строки и записывает всё, происходящее в нём в файл. Запись заканчивается с закрытием "дочернего" терминала. 

Цитата из мануала "BUG: script places everything in the log file, including linefeeds and backspaces.  This is not what the naive user expects". А это значит лишь то, что в файле помимо ожидаемых символов, что мы сами видели в окне терминала будет разный "мусор". Однако при выводе к файла в консоль(утилитой \textbf{cat}), всё будет выглядеть так, как должно.

Запустип утилиту:
\lstinputlisting{../listings/scrpt}
Был создан файл typescript (можно выбрать любой другой файл, указав его вторым аргументом) в который и была записана активность:
\lstinputlisting{../listings/tpsc}
Так отображает файл vim. Не все приведённые здесь символы являются самостоятельными: некоторые сочетания являются представление одного, не укладывающегося в рамки utf-8.

В файле так же присутствует "лишняя" информация: нам сообщаются времена начала и окончания записи. От этого можно избавиться, запустив утилиту \textbf{script} с флагом -q.

Другие интересные флаги:
\begin{itemize}
\item \textbf{-a} - дополняет файл, а не перезаписывает его
\item \textbf{-f} - записывает в файл сразу, а не всё в конце
\item \textbf{-c} - вместо открытия интерактивного шелла, запускает команду
\end{itemize}

\section{ Bash скрипт для записи консоли}
С целью избавиться от "мусора" в результирующих файлах утилиты \textbf{script} напишем свой скрипт со схожей функциональность:
\lstinputlisting{../listings/rec.sh}

Явным минусом этого решения является полное отсутствие интерактивности в пределах команды (она не будет записана). Поэтому, этим скриптом нельзя записать дейсвия этого же скрипта (вызвать его из него же). Однако, в большинстве наших задач сейчас итеративность и не требуется: ввели команду с параметрами, получили вывод. Так же стоит обратить внимание, что если команда exit будет первой, она не обработается корректно.

Скрип умеет направлять вывод в указанный файл и по умолчанию перезаписывает его. Однако, флаг -a позволяет дополнять уже существующий файл. Рассмотрим примеры работы:
\lstinputlisting{../listings/rec_proof}

Ещё одним недостатком является тот факт, что каждая строка выполняется в собственном сабшелле, что лишает нас возможности взаимодействия между ними:
\lstinputlisting{../listings/rec_fail}
Из примера видно, что в пределах одной строки возвращаемые значения сохраняются, также как и переход в другие директории, но каждая следующая команда не получает этих изменений.
\section{Фильтры}

\subsection{Grep}
\textbf{Grep} - утилита выводящая строки соответствующие шаблону. Источником текста может служить как файл так и текстовый поток конвейера. Рассмотрим разные шаблоны с текстовым потоком конвейера в качестве источника.

Найдём исполняемый файл:
\lstinputlisting{../listings/grpx}
Сначала были найдены строки, где 4 от начала символ 'x', но директории, ссылки и сокеты тоже имеют права на исполнения. Поэтому было внесено уточнение, что это должен быть регулярный файл.

Теперь найдём все фалы, созданные не в 23 часа
\lstinputlisting{../listings/grpr}
Так как есть лишняя строчка, за которой не стоит файл, её тоже надо отфильтровать. Исходя из того, то ни один тип файлов не начинается на t, через оператор или было добавлено условия начала строки на 't'.

Список основных флагов утилиты:
\begin{itemize}
\item -i - игнорирование регистра
\item -v - инвертирование выборки
\item -c - выводит количество совпадающих с шаблоном строк
\item -l - вывод названия файлов в которых есть совпадения
\item -L - вывод названия файлов в которых нет совпадений
\item -n - перед каждой строчкой выводит её номер в файле
\item -h - подавляет вывод имени файла при многофайловом поиске
\end{itemize}
\subsection{ Удобный вывод стены текста}  
\textbf{More} - утилита позволяющая в удобном виде отображать в консоли большие объёмы информации, разбивая её на страницы и позволяя по ним навицироваться.

\textbf{Less} - утилита схожая с предыдущей, но единицей навигации является строка.
\subsection{Sed}
\textbf{Sed} - редактор потока для фильтрации и изменения текста.

Попробуем изменить одно слово в строке:
\lstinputlisting{../listings/sedbg}
Результатом является строка, в которой была заменено слово

\subsection{Sort}
\textbf{Sort} сортирует данные (желательно структурированные). По умолчанию сортировка происходит в алфавитном порядке по первому столбцу.
Добавим ключ инверсии -r и объединим мальчиков и девочек:
\lstinputlisting{../listings/sortr}

Теперь попробуем отсортировать по второму столбцу в алфавитном порядке:
\lstinputlisting{../listings/sortk}
ключ -k позволяет выбрать столбец. Аргумент 2 говорит о том, что мы сортируем по второму столбцу

Помимо файлов sort умеет работать и с текстовым потоком:
\lstinputlisting{../listings/sortls}
Здесь были отфильтрованы строки ответственные за файлы, а потом отсортированы по пятому столбцу по объёму(числам). Для указания сортировки по числам использовался флаг -n.
\subsection{Uniq} 
\textbf{Uniq} сообщает о или пропускает повторяющиеся строки. В файле примера первая и последняя строки полностью совпадают совпадают(для наглядности).

\lstinputlisting{../listings/uniq_fail}

Мы видим, что полностью идентичные строки всё ещё присутствуют. Это связано с тем, что для корректной работы утилиты необходимо отсортировать файл или входной поток так, чтобы повторяющиеся элементы были в соседних строках. Поэтому здесь будет использоваться утилита \textbf{sort}.

\lstinputlisting{../listings/uniq}

На сей раз абсолютно совпадающие строки были представлены лишь одной (строка "Volodya Avagyan" представлена один раз).

Теперь попробуем посчитать количество человек с одинаковой фамилией:

\lstinputlisting{../listings/uniq_surname}

Флаг \textit{-f} позволяет пропустить N первых полей до начала сравнения. А флаг \textit{-c} выводит количество одинаковых записей.

Теперь попробуем найти людей с одинаковым именем:

\lstinputlisting{../listings/uniq_name}

Из примера видно, что в группе 2 Марии и 2 Володи, однако эта операция не совсем правдива, так как у утилиты \textbf{uniq} нет возможности сравнить первые N полей, мы с помощью флага \textit{-w} сравниваем первые N символов (в данном случае 5), а туда могут попасть и фамилия и одинаковая часть разных имён.
\subsection{Cmp}
\textbf{Cmp} - сравнение двух файлов по байтам. Заканчивает свою работу на первом отличающимся байте, указывая его местоположение:
\lstinputlisting{../listings/cmp}
Не стоит забывать, что символ переноса строки тоже символ, а в файлах ОС Windows за начала новой строки ответственно два символа.

\subsection{Diff}
\textbf{Diff} - сравнивает файлы по строкам.
\lstinputlisting{../listings/diff_files}
Мы видим, что во разница в файлах выявлена и выведена на экран.

 
\section{Конвейеры, списки}
\subsection{Конвейер}
Конвейеры позволяют направить выходной поток одной программы на входной поток другой. Рассмотрим работу на примере двух простых программ.

Программа имеющая узнаваемый выходной поток:
\lstinputlisting[language=c]{../listings/left.c}

Программа, модифицирующая получаемый входной поток:
\lstinputlisting[language=c]{../listings/right.c}

Рассмотрим действие программ порознь и вместе (через пайп):
\lstinputlisting{../listings/pipe}

Все остальные конвейеры реализованы через вышеприведённый. Так \textbf{|\&} является сокращением для \textbf{2>\&1 |}, что перенаправляет выходной поток ошибок первый программы во входной второй.

Для демонстрации перенаправления потока ошибок модифицируем программу имеющую. узнаваемый выходной поток:
\lstinputlisting[language=c]{../listings/left_err.c}

Программу приёма ошибок:
\lstinputlisting[language=c]{../listings/right_mult.c}

Пример использования:
\lstinputlisting{../listings/pipe_err}
Из примерно видно, что поток ошибок (stderr) при первом запуске выводится в консоль из первой программы, а во втором и третьем поток ошибок уже является выводом второй программы конвейера.
\subsection{Списки}
Список - последовательность из одного или более конвейеров, разделённых одним из операторов ;, \&, \&\&, или ||, и опционально ограниченных одним из ;, \&, или <newline>.

Операторы \&\&, и || имеют одинаковый приоритет, после которых идут ; и \&, у которых тоже одинаковый приоритет.

Оператор переноса может быть использована в списке вместо ; для разделения команд.

Если команда заканчивается оператором \&, шелл исполняет команду в фоне (в сабшелле). Шелл не ждёт, пока команда закончится, и возвращаемое значение принимается равным нулю. А команды разделённые оператором ; выполняются последовательно: шелл ждёт, пока каждая команда закончится в порядке очереди. Возвращаемое значение равно статусу завершения последней команды.

При операторе \&\& правая команда исполнится только если левая завершится с нулём.
При операторе || правая команда исполнится, если левая вернёт не нулевое значение. Проверим:
\lstinputlisting{../listings/lists_and}
Первые две команды показывают нам, какие значения возвращает команда равенства. Оператор \textbf{;} показывает окончание первой команды и начало второй. В переменной окружения \textbf{?} хранится последнее возвращаемое значение.

Для более наглядного понимания напишем свои программы.

Программа возвращающая число(0-255), принятое как параметр:
\lstinputlisting{../listings/return.c}

Программа выводящая строку:
\lstinputlisting{../listings/proof.c}

Проверим возвращаемые значения и работу конвейера:
\lstinputlisting{../listings/ANDc}
Для стандартных ситуаций конвейер работает как и положено. Попробуем встречающиеся реже коды ошибок:
\lstinputlisting{../listings/ANDc2}
Из примера видно, что поведении сохраняется как и при 1

\section{Выводы:}
В ходе данной работа были рассмотрены команды работы с файлами, что позволило успешно приводить примеры в дальнейшем и работать с системой через терминал.

Не менее важным для работы в терминале было изучение конвейеров и списков, с помощью которых также был написан скрипт для для записи действий в терминале.

Был разобран цикл обработки программ языка С и написаны рабочие примеры для наглядной демонстрации других аспектов этой работы.
\end{document}