\documentclass[14pt,a4paper,report]{report}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{listings} 
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{graphicx}
\hypersetup{
	colorlinks = true,
	linkcolor  = black
}

\usepackage{titlesec}
\titleformat{\chapter}
{\Large\bfseries} % format
{}                % label
{0pt}             % sep
{\huge}           % before-code


\DeclareCaptionFont{white}{\color{white}} 

% Listing description
\usepackage{listings} 
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{ 
	% Listing settings
	inputencoding = utf8,			
	extendedchars = \true, 
	keepspaces = true, 			  	 % Поддержка кириллицы и пробелов в комментариях
	language = C,            	 	 % Язык программирования (для подсветки)
	basicstyle = \small\sffamily, 	 % Размер и начертание шрифта для подсветки кода
	numbers = left,               	 % Где поставить нумерацию строк (слева\справа)
	numberstyle = \tiny,          	 % Размер шрифта для номеров строк
	stepnumber = 1,               	 % Размер шага между двумя номерами строк
	numbersep = 5pt,              	 % Как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor = \color{white}, % Цвет фона подсветки - используем \usepackage{color}
	showspaces = false,           	 % Показывать или нет пробелы специальными отступами
	showstringspaces = false,    	 % Показывать или нет пробелы в строках
	showtabs = false,           	 % Показывать или нет табуляцию в строках
	frame = single,              	 % Рисовать рамку вокруг кода
	tabsize = 2,                  	 % Размер табуляции по умолчанию равен 2 пробелам
	captionpos = t,             	 % Позиция заголовка вверху [t] или внизу [b] 
	breaklines = true,           	 % Автоматически переносить строки (да\нет)
	breakatwhitespace = false,   	 % Переносить строки только если есть пробел
	escapeinside = {\%*}{*)}      	 % Если нужно добавить комментарии в коде
}

\begin{document}

\def\contentsname{Содержание}

% Titlepage
\begin{titlepage}
	\begin{center}
		\textsc{Санкт-Петербургский Политехнический 
			Университет Петра Великого\\[5mm]
			Кафедра компьютерных систем и программных технологий}
		
		\vfill
		
		\textbf{Отчёт по лабораторной работе №1\\[3mm]
			Курс: «Операционные системы»\\[6mm]
			Тема: «Интерпретаторы командной строки Linux»\\[35mm]
		}
	\end{center}
	
	\hfill
	\begin{minipage}{.5\textwidth}
		Выполнил студент:\\[2mm] 
		Волкова Мария Дмитриевна\\
		Группа: 43501/3\\[5mm]
		
		Проверил:\\[2mm] 
		Душутина Елена Владимировна
	\end{minipage}
	\vfill
	\begin{center}
		Санкт-Петербург\\ \the\year\ г.
	\end{center}
\end{titlepage}

% Contents
\tableofcontents
\clearpage

\chapter{Лабораторная работа №1}

\section{Цель работы}

\begin{itemize}
	\item Изучение основных команд пользовательского интерфейса.
	\item Изучение цикла подготовки и исполнения программ.
	\item Изучение команд и утилит обработки текстов.
\end{itemize}

\section{Программа работы}

\begin{itemize}
	\item Команды работы с файлами.
	\item Цикл работы программы (компиляторы, запуск отладчика).
	\item Файловый состав ОС.
	\item Интерпретаторы (как работают, где есть).
	\item Запуск script.
	\item Утилиты и фильтры.
	\item Организация конвейера.
\end{itemize}

\clearpage

\section{Ход работы}

\subsection{Команды работы с файлами}

\subsubsection{Команда ls}

Изучим команду получения информации о файлах и папках \emph{ls}:

\lstinputlisting{listings/2.4.a.log}

Команда \emph{ls} без ключей и указания абсолютного пути к директории выведет все файлы и папки в текущем каталоге. Если используется ключ -l, то выводится информация в виде таблицы: в первом столбце выводятся права доступа для пользователя, группы и остальных на файлы и каталоги (r - чтение, w - запись, x - выполнение). В следующих столбцах выводится количество ссылок на файл или каталог, имя владельца и имя группы, размер в байтах, дата последней модификации и самого файла или каталога имя. Если задать параметром не директорию, а файл, то тогда команда выведет только название этого файла.

\subsubsection{Команда cat}

Изучим команду просмотра содержимого файлов \emph{cat}:

\lstinputlisting{listings/2.4.b.log}

Команда \emph{cat} выводит содержимое указанных файлов (одного или нескольких) или печатает сообщение об ошибке, если параметром указана директория.

\subsubsection{Команды mv, cp}

Исследуем команду \emph{mv}, которая переименовывает или перемещает файл, и команду \emph{cp}, которая копирует файл в указанную директорию:

\lstinputlisting{listings/2.4.c.log}

Команда \emph{mv} действительно переименовала файл, а после применения команды \emph{cp} файл также отображается в списке директории, в которую мы скопировали файл.

\subsubsection{Команды pwd, cd, mkdir, rmdir, rm}

Исследуем процесс навигации по файловой системе, исследования системных папок и создание/удаление новых файлов и папок:

\lstinputlisting{listings/2.5.log}

\begin{itemize}
	\item \emph{pwd} - выводит полное имя текущей директории.
	\item \emph{>filename} - создает новый файл в текущей директории.
	\item \emph{ls /} - выводит имена файлов и папок в корне файловой системы.
	\item \emph{cd} - меняет текущую директорию (можно указывать как полный путь к директории, так и относительный). Команда использует ".." как указатель на директорию выше по иерархии и ".", как указатель на текущую директорию (что работает и для остальных команд). При попытке подняться выше, чем корень файловой системы, команда ничего не сделает.
	\item \emph{mkdir} - создает новую директорию.
	\item \emph{rmdir} - удаляет пустую директорию. Если директория не пуста, то сначала н используют команду \emph{rm dir/*}, которая удалит все файлы внутри.
	\item \emph{rm} - удаляет файл или множество файлов, с помощью символа "*".
\end{itemize}

\clearpage

\subsubsection{Команда ls с флагом -l}

\emph{ls -l} - выводит имена файлов и папок с дополнительной информацией о типе файла, правах доступа к файлу, количестве ссылок на файл, имени владельца, имени группы, размере файла (в байтах) и временном штампе.

Был проведен эксперимент для изучения вывода команды \emph{ls -l}:

\lstinputlisting{listings/2.5.d.log}

В начале эксперимента создана пустая папка \emph{example} и пустой файл \emph{cat.ty} внутри. Далее исследуем содержимое командой \emph{ls -l}, в результате чего получено: \emph{total 0 -rw-rw-r-- 1 nikita nikita 0 сен 23 12:28 cat.ty}. Разберем вывод по частям:

\begin{itemize}
	\item \emph{total 0} - общее дисковое пространство, выраженное в блоках, используемое всеми файлами в данном каталоге. В ходе эксперимента было выявлено увеличение и уменьшение количество занимаемых блоков, в зависимости от размера содержимого файлов. Более наглядную информацию об этом параметре можно получить командой \emph{ls -as}.
	\item \emph{-rw-rw-r--} - права доступа для владельца (rw- чтение и запись), для группы (rw- чтение и запись) и для остальных (r-- чтение). Параметр можно изменить с помощью команды \emph{chmod}.
	\item \emph{1} - количество жестких ссылок на файл. Экспериментально подтверждено, что параметр можно изменить, создав дополнительную ссылку, с помощью команды \emph{ln}.
	\item \emph{nikita nikita} - имя владельца и группы.
	\item \emph{0} - размер файла в байтах. Было установлено, что для только что созданного каталога, по умолчанию, размер будет равен 4096 байт (4 блока).
	\item \emph{сен 23 12:28} - временной  штамп.
	\item \emph{cat.ty} - символьное имя файла.
\end{itemize}

Последующая часть эксперимента была направлена на изучение этих полей.

\clearpage

\subsubsection{Команда ps}

Исследуем команду \emph{ps}, которая выводит информацию о работающих процессах:

\lstinputlisting{listings/2.6.log}

Выводимые столбцы:

\begin{itemize}
	\item \emph{PID} - уникальный идентификатор процесса.
	\item \emph{TTY} - терминал, с которым связан данный процесс.
	\item \emph{TIME} - процессорное время, занятое этим процессом.
	\item \emph{CMD} - команда, запустившая данный процесс «с некоторыми опциями выводит и каталог откуда процесс был запущен».
\end{itemize}

\clearpage

Рассмотренные ключи команды:

\begin{itemize}
	\item \emph{-A} - выводит информацию обо всех процессах.
	\item \emph{-T} - выводит информацию обо всех процессах на конкретном терминале.
	\item \emph{r} - выводит информацию исключительно о работающих процессах.
	\item \emph{-d} - выводит информацию обо всех процессах, кроме главных системных процессов сеанса.
	\item \emph{-N} - отрицание выбора.
\end{itemize}

\subsection{Цикл работы программы (компиляторы, запуск отладчика)}

Исследуем процесс компиляции программ на языке "C":
\lstinputlisting{listings/3.log}
prog.c:
\lstinputlisting{listings/prog.c}
my\_open.c:
\lstinputlisting{listings/my_open.c}

В первую очередь были созданы 2 файла с текстами программ ("\emph{>prog.c}, \emph{>my\_open.c}"), после этого были созданы объектные файлы, с помощью компилятора \emph{gcc} и флага \emph{-c}, который подавляет действие компоновщика связей (\emph{ld}). На заключительном этапе, с помощью компилятора \emph{gcc} и флага \emph{-o}, производится вызов компоновщика связей и создается исполняемый файл. В дальнейшем, принудительное создание объектного файла, с помощью флага \emph{-c} игнорируется и сразу компилируется исполняемый файл.

Запуск программы на исполнение производится с помощью конструкции \emph{./progname}, где "." означает текущий каталог. Перенаправление выходного потока программы в файл \emph{res.txt} осуществляется с помощью команды \emph{./progname >res.txt}.

С помощью аргументов функции main(int argc, char *argv []) можно обрабатывать информацию из консоли (вызывающего окружения). С помощью команды \emph{./my\_open res.txt} была передана строка "res.txt" программе my\_open. Если ничего не было передано или неверное имя файла для обработки, то выводится ошибка.

Попробуем скомпоновать программу из нескольких файлов, для этого разработаем тестовую программу.
prog.c:
\lstinputlisting{listings/progmodify.c}
foo.c:
\lstinputlisting{listings/foo.c}

Функция \emph{foo()} объявлена как внешняя, поэтому можно осуществить компоновку из внешнего файла:

\lstinputlisting{listings/3.m.log}

Для выявления ошибок при компиляции можно исследовать вывод компилятора \emph{gcc}, где указывается подробная информация об ошибках и предупреждениях. Для отладки программы можно использовать отладчик \emph{gdb}. Отладчик \emph{gdb} – интерактивный, поэтому его можно запускать без параметров, а задавать их прямо из него. Если указано имя исполнимого файла, то он будет сразу же загружен в отладчик.

Создадим тестовую программу и попробуем ее отладить:
gdbtest.c:
\lstinputlisting{listings/gdbtest.c}
Запустим отладчик gdb:
\lstinputlisting{listings/gdb.log}

При отладке программы была поставлена точка останова на функции \emph{main()}. После этого был произведен запуск программы и отладчик уведомил о том, что программа постигла точки останова по адресу функции \emph{main()}. Продолжение программы осуществляется командой \emph{next}. После этого предлагается ввести число, это можно сделать прямо из отладчика и программа продолжится. Результат работы программы тоже выводится в отладчике. Для выхода из отладчика используется команда \emph{quit}.

\subsection{Файловый состав ОС}

Рассмотрим содержимое основных системных каталогов:

\begin{itemize}
	\item \emph{/bin} - этот каталог содержит в основном готовые к исполнению программы, большинство из которых необходимы во время старта системы (или в однопользовательском системном режиме, используемом для отладки). Здесь хранится значительное количество общеупотребительных команд Linux.
	\item \emph{/boot} - содержит основные постоянные файлы для загрузки системы, в частности загружаемое ядро. Файлы из этого каталога нужны только во время загрузки системы.
	\item \emph{/dev} - каталог специальных файлов или файлов устройств.
	\item \emph{/etc} - этот каталог и его подкаталоги содержат большинство данных, необходимых для начальной загрузки системы и основные конфигурационные файлы. Каталог /etc не должен содержать двоичных файлов (их следует перенести в /bin или /sbin).
	\item \emph{/home} - в этом каталоге находятся домашние каталоги пользователей.
	\item \emph{/lib} - этот каталог содержит разделяемые библиотеки функций, необходимых компилятору языка C и модули (драйверы устройств). Даже если в системе не установлен компилятор языка C, разделяемые библиотеки необходимы, поскольку они используются многими прикладными программами. Они загружаются в память по мере необходимости выполнения каких-то функций, что позволяет уменьшить объем кода программ — в противном случае один и тот же код многократно повторялся бы в различных программах.
	\item \emph{/root} - в этом каталоге находится домашний каталог суперпользователя.
	\item \emph{/tmp} - каталог для временных файлов. В любой момент суперпользователь может удалить файлы из этого каталога без большого ущерба для остальных пользователей.
	\item \emph{/usr} - в его подкаталогах находятся все основные приложения. В соответствии со стандартом FHS рекомендуется выделять для этого каталога отдельный раздел диска или вообще располагать его на сетевом диске, общем для всех компьютеров в сети. Такой раздел или диск монтируют только для чтения и располагают в нем общие конфигурационные и исполняемые файлы, документацию, системные утилиты и библиотеки, а также включаемые файлы.
	\item \emph{/usr/bin} - готовые к исполнению программы — утилиты и приложения, которые часто вызывают обычные пользователи.
	\item \emph{/usr/etc} - здесь содержатся конфигурационные файлы для группы машин. Однако, команды и программы должны смотреть в каталог /etc, в котором должны быть линки к файлам в каталоге /usr/etc.
	\item \emph{/usr/etc/include} - этот каталог содержит исходный код стандартных библиотек языка C, подставляемый в программы директивой препроцессора include. 
	\item \emph{/usr/lib} - в данном каталоге содержится объектные библиотеки подпрограмм, динамические библиотеки, некоторые готовые к исполнению программы, которые не вызываются непосредственно. Сложные программные системы могут иметь свои подкаталоги в этом каталоге.
	\item \emph{/usr/local} - здесь помещают программы и подкаталоги, которые являются локальными (уникальными) для данной машины. Также содержит подкаталоги \emph{/bin}, \emph{/etc}, \emph{/lib}, \emph{/man}, \emph{/src}, которые отличаются от уже рассмотренных тем, что они являются уникальными для данной машины.
	\item \emph{/usr/man} - страницы интерактивного руководства man в исходном формате (не подготовленные для просмотра).
	\item \emph{/usr/src} - Исходные тексты для различных частей Linux. \emph{/usr/src/linux} — исходные тексты для ядра Linux.
	\item \emph{/usr/tmp} - еще одно место для хранения временных файлов. 
	\item \emph{/var} - Этот каталог содержит файлы, в которых сохраняются различные переменные данные, определяющие конфигурацию некоторых программ при следующем запуске или временно сохраняемую информацию, которая будет использоваться позже в ходе текущего сеанса. Объем данных в этом каталоге может сильно изменяться, поскольку он содержит, например, файлы протоколов (логи), файлы спулинга и блокировки (locking), временные файлы и т.д.
\end{itemize}

\subsection{Интерпретаторы}

Интерпретатор командной строки - компьютерная программа, часть операционной системы, обеспечивающая базовые возможности управления компьютером посредством интерактивного ввода команд через интерфейс командной строки или последовательного исполнения пакетных командных файлов.

Зачастую интерпретатор командной строки предоставляет возможность использования циклов, операторов условного и безусловного перехода и переменных. Он позволяет писать как несложные сценарии для автоматизации повседневных задач, так и довольно сложные программы.

Примеры интерпретаторов: для DOS - \emph{command.com}, для Windows - \emph{cmd.exe}, \emph{PowerShell}, для UNIX - \emph{bash}, \emph{csh}, \emph{ksh}, \emph{zsh}.

Узнаем какой именно интерпретатор используем с помощью команды \emph{ps -T} и запустим другой интерпретатор непосредственно из первого:

\lstinputlisting{listings/sh.log}

Можно заметить, что команда \emph{ps -T} выдаст информацию не только о текущем интерпретаторе, но и обо всех процессах запущенных им.

\subsection{Запуск script}

Для целей лабораторных работ был разработан скрипт, который сохраняет информацию из командной строки в файл:

script.sh:

\lstinputlisting{listings/script.sh}

Недостатком данного скрипта является отсутствие автоподстановки команд, которая существенно экономит время работы, поэтому этот метод не является универсальным. В тоже время простое копирование из командной строки занимает не намного больше времени, зато позволяет использовать все удобства при работе.

\subsection{Утилиты и фильтры}

\subsubsection{Утилиты}

Утилита - это сервисная программа, облегчающая пользование другими программами, работу с компьютером. Рассмотрим некоторые полезные утилиты.

Введем набор команд для получения информации об ОС и текущем сеансе:

\lstinputlisting{listings/2.1.log}

\begin{itemize}
	\item \emph{date} - выводит информацию о текущем системном времени.
	\item \emph{who} - выводит пользователей системы, которые в данный момент находятся в ней.
	\item \emph{whoami} - выводит имя пользователя, ассоциированное с текущим эффективным идентификатором пользователя.
	\item \emph{tty} - выводит на экран полное имя файла-терминала.
	\item \emph{logname} - выводит имя пользователя, под которым он произвел вход в систему.
	\item \emph{uname} - выводит на экран имя UNIX-системы. 
\end{itemize}

Изучим команду задержки на указанное время:

\lstinputlisting{listings/2.2.log}

\emph{sleep} - задерживает на указанное время (задается в секундах, однако можно задавать в часах, например 5h).

Команду \emph{sleep} (как и другие) можно преждевременно остановить, послав сигнал прерывания, с помощью комбинации клавиш \emph{Ctrl+C}.

С помощью команды \emph{man}, можно получить справочную информацию о любой команде в формате справочника:

\lstinputlisting{listings/2.3.log}

Справочники в ОС Linux имеют следующие разделы:

\begin{itemize}
	\item \emph{NAME} - указывается название команды и ее функциональное применение.
	\item \emph{SYNOPSIS} - указывается синтаксис команды (все что не заключено в квадратные скобки обязательно к добавлению).
	\item \emph{DESCRIPTION} - описание флагов программы.
	\item \emph{EXAMPLES} - примеры работы команды.
	\item \emph{AUTHOR} - автор программы.
	\item \emph{REPORTING BUGS} - контактные данные для обращения по поводу выявленных ошибок.
	\item \emph{COPYRIGHT} - информация о лицензии.
	\item \emph{SEE ALSO} - список похожих команд, рекомендованных для просмотра.
\end{itemize}

\subsubsection{Фильтры}

Существует большое  число  команд  UNIX,  которые  читают входной поток,  выполняют  простые операции над ним и записывают результат в выходной поток.  Такие программы называются фильтрами. Многие команды могут быть фильтрами, поскольку обычно в случае незадания файла-аргумента читается стандартный ввод.  Важной особенностью фильтров  является то,  что они никогда не изменяют исходных файлов,  а лишь выводят на стандартный вывод обработанную информацию.  Стандартный  вывод  также можно переназначить в файл.

\subsubsection{Фильтр Grep}

Изучим команду \emph{grep}, которая осуществляет поиск по шаблону, заданному регулярным выражением. Для этого выполним тестовое задание:

\begin{verbatim}
Выведите только те строки из вывода ls -l /tmp, которые: 
1) соответствуют каталогам; 
2) соответствуют выполняемым для всех файлам; 
3) принадлежат пользователь root; 
4) не принадлежат пользователю root.
\end{verbatim}

Результат фильтрации представлен в листинге:

\lstinputlisting{listings/4.1.log}

\subsubsection{Фильтр Cut}

Изучим команду \emph{Сut}, которая выбирает отдельные поля из строк файла. Для этого выполним тестовое задание:

\begin{verbatim}
Определите с использованием команды cut: 
1) номера запущенных Вами процессов; 
2) идентификаторы пользователей,  имеющих  x-терминалы на Вашей рабочей станции; 
3) Ваше входное имя в системе.
\end{verbatim}

Результат фильтрации представлен в листинге:

\lstinputlisting{listings/4.2.log}

\subsubsection{Фильтр Tr}

Изучим команду \emph{Tr}, которая копирует стандартный ввод на стандартный вывод с заменой либо удалением выбранных символов.  Символы, найденные в цепочке1,  заменяются  на  соответствующие  символы из цепочки2. Для этого выполним тестовое задание:

\begin{verbatim}
Выведите информацию о ваших файлах прописными буквами.
\end{verbatim}

Результат фильтрации представлен в листинге:

\lstinputlisting{listings/4.3.log}

\subsubsection{Фильтр Sort}

Изучим команду \emph{Sort}, которая сортирует строки,  входящие во все исходные файлы, и выдает результат на стандартный вывод. Для этого выполним тестовое задание:

\begin{verbatim}
Отсортируйте файлы в вашем каталоге (ls -l): 
1) в алфавитном порядке, 
2) в порядке увеличения размеров файлов, 
3) в порядке уменьшения размеров файлов.
\end{verbatim}

Результат фильтрации представлен в листинге:

\lstinputlisting{listings/4.4.log}

\subsubsection{Фильтр Uniq}

Изучим команду \emph{Uniq}, которая   читает  исходный  файл  и сравнивает соседние строки. В обычном режиме вторая и последующие копии повторяющейся строки исключаются;  остаток поступает в выходной файл, который не должен совпадать с исходным. Для этого выполним тестовое задание:

\begin{verbatim}
Выведите повторяющиеся размеры файлов из каталога /usr/bin. Для этого из вывода ls -l с помощью cut оставьте только размеры, отсортируйте полученный  поток  и  из результата выделите только повторения.
\end{verbatim}

Результат фильтрации представлен в листинге:

\lstinputlisting{listings/4.5.log}

\subsubsection{Фильтр Cmp}

Изучим команду \emph{Cmp}, которая производит побайтное сравнение и прекращает работу при первом несовпадении. Для этого выполним тестовое задание:

\begin{verbatim}
Сравните файлы исходных текстов и объектные файлы созданных С-программ.
\end{verbatim}

Результат сравнения представлен в листинге:

\lstinputlisting{listings/4.6.log}

\subsubsection{Фильтр Diff}

Изучим команду \emph{Diff}, которая выдает на стандартный вывод только те строки файлов, которые нужно изменить, чтобы привести файлы в соответствие друг с другом. Для этого выполним тестовое задание:

\begin{verbatim}
Сравните prog.c и my_open.c с помощью diff:
diff -e prog.c my_open.c > eqv
\end{verbatim}

Результат сравнения представлен в листингах:

\lstinputlisting{listings/4.7.log}

Результат выполнения команды \emph{diff -e prog.c my\_open.c > eqv} автоматически сохраняется в файле \emph{eqv}:

\lstinputlisting{listings/eqv.log}

Результатом выполнения программы являются строки, которые необходимо заменить, для того, чтобы файлы были одинаковые. Можно заметить, что \emph{Diff} не посчитала, что нужно менять строки с "\#include", "{", "}", потому что они встречаются в обоих программах. Также команда выводит номер строки, начиная с которой должны быть произведены изменения.

\subsection{Организация конвейера}

\emph{Конвейер} - некоторое множество процессов, для которых выполнено следующее перенаправление ввода-вывода: то, что выводит на поток стандартного вывода предыдущий процесс, попадает в поток стандартного ввода следующего процесса.

Рассмотрим различные методы организации конвейеров (где undefigned.txt это несуществующий файл, при открытии которого программа возвращает 1, а defigned.txt это существующий файл, при открытии которого программа возвращает 0):

\lstinputlisting{listings/3.k.log}

Различия конвейеров:

\begin{itemize}
	\item $\&\&$ - срабатывает только тогда, когда предыдущая команда вернула ноль.
	\item $||$ - срабатывает только тогда, когда предыдущая команда вернула не ноль.
	\item $|$ - стандартный выходной поток одной программы перенаправляется в стандартный входной поток другой программы.
	\item $;$ - исполняет команды друг за другом, ожидая окончания каждой из них перед началом выполнения другой.
\end{itemize}

Хорошим примером конвейера являются фильтры, рассмотренные в предыдущем пункте.













\end{document}