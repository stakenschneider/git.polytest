\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}

\usepackage{caption}
\renewcommand{\lstlistingname}{Листинг}

\usepackage{listings}

\lstdefinestyle{base_listing}{ %
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\lstdefinestyle{crs_bash}{
  style    = {base_listing},
  language = {bash}
}

\lstdefinestyle{crs_cpp}{
  style    = {base_listing},
  language = {C++}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm]
\large Отчет по лабораторной работе №3\\[0.1cm]
\large Процессы в UNIX-системах\\[5cm]
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Цель работы}
	Изучить основные принципы управления процессами и нитями в ОС LINUX.
	
\section{Программа работы}
\begin{enumerate}
	\item Порождение и запуск процессов
	\begin{enumerate}
		\item Создайте программу на основе одного исходного (а затем исполняемого файла с псевдораспараллеливанием вычислений посредством порождения процесса-потомка.
		\item Выполните сначала однократные вычисления в каждом процессе, обратите внимание, какой процесс на каком этапе владеет процессорным ресурсом. Каждый процесс должен иметь вывод на терминал, идентифицирующий текущий процесс. Последняя исполняемая команда функции main должна вывести на терминал сообщение о завершении программы. Объясните результаты. Сделайте выводы об использовании адресного пространства.
		\item Затем однократные вычисления замените на циклы, длительность исполнения которых достаточна для наблюдения конкуренции процессов за процессорный ресурс.
		\item Измените процедуру планирования и повторите эксперимент.
		\item Разработайте программы родителя и потомка с размещением в файлах father.c и son.c
		\item Для фиксации состояния таблицы процессов в файле целесообразно использовать системный вызов system("ps —abcde > file”). Запустите на выполнение программу father.out C терминала узнайте о процессах, запущенных с вашего терминала.
		\item Выполните программу father.out13 фоновом режиме father \& Получите таблицу процессов, запущенных с вашего терминала (включая отцовский и сыновний процессы).
		\item Выполните создание процессов с использованием различных функций семейства exec () с разными параметрами функций семейства, привести результаты эксперимента.
		\item Проанализируйте значение, возвращаемое функцией wait (\&status) . Предложите эксперимент, позволяющий родителю отслеживать подмножество порожденных потомков, используя различные функции семейства wait () .
		\item Проанализируйте очередность исполнения процессов, порожденных вложенными вызовами fork ().
			\begin{enumerate}
			\item Измените процедуру планирования с помощью функции с шаблоном scheduler B ее названии и повторите эксперимент.
			\item Поменяйте порядок очереди в КК-процедуре.
			\item Можно ли задать разные процедуры планирования разным процессам с одинаковыми приоритетами. Как они будут конкурировать, подтвердите экспериментально.
		\end{enumerate}

		\item Определите величину кванта. Можно ли ее поменять? — для обоснования проведите эксперимент.

		\item Проанализируйте наследование на этапах fork () и exec (). Проведите эксперимент с родителем и потомками по доступу к одним и тем же файлам, открытым родителем. Аналогичные эксперименты 
проведите по отношению к другим параметрам. 

	\end{enumerate}
	\item Взаимодействие родственных процессов
	\begin{enumerate}
		\item Изменяя длительности выполнения процессов и параметры системных вызовов, рассмотрите 3 ситуации и получите соответствующие таблицы процессов:
		\begin{enumerate}
			\item процесс—отец запускает процесс-сын и ожидает его завершения;
			\item процесс—отец запускает процесс-сын и, не ожидая его завершения, завершает свое выполнение. Зафиксируйте изменение родительского идентификатора процесса-сына;

			\item процесс—отец запускает процесс-сын и не ожидает его завершения; процесс-сын завершает свое выполнение. Зафиксируйте появление процесса—зомби, для этого включите команду ps B программу father.c	
		\end{enumerate}
		\item Перенаправьте вывод не только на терминал, но и в файл. Организуйте программу многопроцессного функционирования так, чтобы результатом ее работы была демонстрация всех трех ситуаций с отображением в итоговом файле.
		
	\end{enumerate}	
	
	\item Управление процессами посредством сигналов
	\begin{enumerate}	
		\item C помощью команды kill —l ознакомьтесь с перечнем сигналов, поддерживаемых процессами. Ознакомьтесь с системными вызовами kill (2) , signal (2) . Подготовьте программы следующего содержания:
		\begin{enumerate}
			\item процесс father порождает процессы sonl, son2, son3 и запускает на исполнение программные коды из соответствующих исполнительных файлов;
			\item далее родительский процесс осуществляет управление потомками. :шт
этого он генерирует сигнал каждому пользовательскому процессу:
			\item в пользовательских процессах-потомках необходимо обеспечить:\\
				для son1 - реакцию на сигнал по умолчанию;\\
				для son2 - реакцию игнорирования;\\
				для son3 — перехватывание и обработку сигнала.\\
			Сформируйте файл-проект из четырех файлов, откомпилируйте, запустите программу. Проанализируйте таблицу процессов до и после посылки сигналов с помощью системного вызова system("ps -s >> filе"). Обратите внимание на реакцию, устанавливаемую для последнего потомка.
		\end{enumerate}	
		\item Организуйте посылку сигналов любым двум процессам, находящимся в разных состояниях: активном и пассивном, фиксируя моменты посылки и приема каждого сигнала с точностью до секунды. Приведите результаты в файле результатов.

		\item Запустите в фоновом режиме несколько утилит, например: cat *.C > myprog \& lpr myprog \& lpr intro\& \\ Воспользуйтесь командой jobs для анализа списка заданий и очередности их выполнения. Позаботьтесь об уведомлении о завершении одного из заданий с помощью команды notify. Аргументом команды является номер задания. Верните невыполненные задания в приоритетный режим командой fg.\\
Например: fg \%3\\
Отмените одно из невыполненных заданий.

		\item Ознакомьтесь с выполнением команды и системного вызова nice (1)
и getpriority (2). Приведите примеры их использования в приложении. Определите границы приоритетов (создайте для этого программу). Есть ли разница в приоритетах для системных и пользовательских процессов, используются ли приоритеты реального времени. Каков пользовательский приоритет для запуска приложений из shell. Все ответы подкрепляйте экспериментально.

		\item Ознакомьтесь с командой nohup (l) . Запустите длительный процесс по nohup (l ) . Завершите сеанс работы. Снова войдите в систему и проверьте таблицу процессов. Поясните результат.

		\item Определите uid процесса, каково минимальное значение и кому оно принадлежит. Каково минимальное и максимальное значение рісі, каким процессам принадлежат. Проанализируйте множество системных процессов, как их отличить от прочих, перечислите назначение самых важных из них.
	\end{enumerate}
	\item Многонитевое функционирование
		\begin{enumerate}
		\item Подготовьте программу, формирующую несколько нитей. Нити для эксперимента могут быть практически идентичны. Например, каждая нить в цикле: выводит на печать собственное имя и инкрементирует переменную времени, после чего "засыпает" (sleep (5) ; sleep (1) ; - для первой и второй нитей соответственно), на экран (в файл) должно выводиться имя нити и количество пятисекундных (для первой) и секундных (для второй) интервалов функционирования каждой нити.
		
		\item После запуска программы проанализируйте выполнение нитей,распределение во времени. Используйте для этого вывод таблицы процессов командой ps —ath Попробуйте удалить нить, зная ее идентификатор, командой kill. Приведите и объясните результат.

		\item Модифицируйте программу так, чтобы управление второй нитью осуществлялось посредством сигнала SIGUSRI из первой нити. На пятой секунде работы приложения удалите вторую нить. Для этого воспользуйтесь функцией pthread\_kill (t2 , SIGUSR) ; (t2 - дескриптор второй ниш). B остальном программу можно не Изменять. Проанализируйте полученные результаты

		\item Последняя модификация предполагает создание собственного обработчика сигнала, содержащего уведомление о начате его работы и возврат посредством функции pthread\_exit(NULL); Сравните результаты, полученные после запуска этой модификации программы c результатами предыдущей.

		\item Перехватите сигнал «CTRL С» для процесса и потока однократно, a
также многократно с восстановлением исходного обработчика после
нескольких раз срабатывания. Проделайте аналогичную работу для
переназначения другой комбинации клавиш.

		\item C помощью утилиты kill выведите список всех сигналов и дайте их
краткую характеристику на основе документации ОС. Для чего
предназначены сигналы с 32 по 64-й. Приведите пример их применения.

		\item Проанализируйте процедуру планирования для процессов и потоков одного процесса.
		\begin{enumerate}
			\item Обоснуйте результат экспериментально. 
			\item Попробуйте процедуру планирования изменить. Подтвердите экспериментально, если изменение возможно.
			\item Задайте нитям разные приоритеты программно и извне (объясните результат),
		\end{enumerate}
	\end{enumerate}
\end{enumerate}
	
\section{Рабочая станция}
	Лабораторная выполняется на физической машине со следующими характеристиками:
	\lstinputlisting[style=crs_bash]{../listings/uname}
	
	В связи с многопоточностью используемой машины была написана функция one\_core, назначающая процесс на нулевое ядро. Таким образом мы можем увидеть конкуренцию процессов за ресурсы.
	
	\captionof{lstlisting}{onecore.h}
	\lstinputlisting[style=crs_bash]{../listings/onecore.h}
	
	\captionof{lstlisting}{onecore.с}
	\lstinputlisting[style=crs_bash]{../listings/onecore.c}
	
\section{Порождение и запуск процессов}
	В UNIX-системах, \textbf{fork()} --- системный вызов, создающий новый процесс (потомок), который является практически полной копией процесса-родителя, выполняющего этот вызов. Между процессом-потомком и процессом-родителем существуют различия:
	\begin{itemize}
		\item PID процесса-потомка отличен от PID процесса-родителя;
		\item значению PPID процесса-потомка присваивается значение PID процесса-родителя;
		\item процесс-потомок получает собственную таблицу файловых дескрипторов, являющуюся копией таблицы процесса-родителя на момент вызова \textbf{fork()}. Это означает, что открытые файлы наследуются, но если процесс-потомок, например, закроет какой-либо файл, то это не повлияет на таблицу дескрипторов процесса-родителя.
		\item для процесса-потомка очищаются все ожидающие доставки сигналы;
		\item временная статистика выполнения процесса-потомка в таблицах ОС обнуляется;
		\item блокировки памяти и записи, установленные в процессе-родителе, не наследуются.	
	\end{itemize}
	
	После вызова \textbf{fork()} алгоритм обычно разветвляется. В случае успешного выполнения функции \textbf{fork()}, она возвращает PID процесса-потомка родительскому процессу и нуль --- процессу-потомку. Если порождение процесса-потомка закончилось неудачей, функция \textbf{fork()} возвращает значение -1.
	
	После \textbf{fork()} процесс-потомок чаще всего выполняет системный вызов \textbf{exec()}, загружающий в пространство процесса новую программу (именно так, и только так, в UNIX-системе выполняется запуск программы в отдельном процессе). Так, первый (нулевой) процесс UNIX (ядро системы) создаёт свою копию, чтобы запустить systemd или init (процессы с PID = 1), которые в свою очередь создадут дочерние процессы для запуска инициализации системы и терминалов.
	
	Семейство функций \textbf{exec()} загружает  и  запускает другие    программы, известные как "дочерние" процессы. 
	\lstinputlisting[style=crs_cpp]{../listings/exec}
	
	Суффиксы l, v, p и e, добавляемые к имени семейства \textbf{exec()} обозначают, что данная функция будет работать с некоторыми особенностями:
	\begin{itemize}
		\item p --- определяет, что функция будет искать "дочернюю" программу в директориях, определяемых переменной среды PATH. Без суффикса p поиск будет  производиться только в рабочем каталоге. Если параметр path  не  содержит  маршрута,  то поиск  производится  в  текущей  директории,  а затем  по  маршрутам,  определяемым  переменной окружения PATH.
		\item l --- показывает, что адресные указатели (arg0, arg1, ..., argn) передаются, как отдельные аргументы. Обычно суффикс l употребляется, когда число передаваемых аргументов заранее известно.
		\item v --- показывает,  что  адресные  указатели  (arg[0], arg[1],...arg[n]) передаются, как массив указателей. Обычно, суффикс  v  используется, когда передается переменное число аргументов.
		\item e --- показывает, что "дочернему" процессу может быть передан аргумент envp, который позволяет выбирать среду "дочернего"   процесса. Без суффикса e "дочерний" процесс унаследует среду "родительского" процесса.
	\end{itemize}
	
	Функция \textbf{wait()} приостанавливает процесс до тех пор, пока один из его дочерних процессов не будет остановлен или не завершится, после чего возвращает информацию о том, какой процесс завершился и что стало причиной его завершения. Значение, возвращаемое функцией \textbf{wait()} – это PID завершившегося процесса, а аргументом функции должен быть указатель на переменную status типа int. В этой переменной функция вернет дополнительные сведения о том, как завершился процесс. 
	
	Функция \textbf{exit()} вызывает нормальное завершение процесса и возвращает значение принимаемого аргумента родителю процесса.
	
	Функция \textbf{sleep()} вызывает "засыпание" процесса или нити на указанное количество секунд. Однако в состоянии "сна" процесс продолжает принимать и обрабатывать сигналы. Функция возвращает 0, если указанное время прошло, иначе она возвращает число секунд, сколько оставалось до завершения сна.
	
\subsection{Псевдораспараллеливание}
	Рассмотрим программу с псевдораспараллеливанием:
	\lstinputlisting[style=crs_cpp]{../listings/pseudo_multi.c}
	
	Если функция \textbf{fork()} возвращает 0, значит мы находимся в процессе-потомке. Иначе --- в процессе родителе.
	
	Скомпилируем и запустим программу:
	\lstinputlisting[style=crs_bash]{../listings/pseudo_multi}
	
	По выводу видно, что сразу после вызова функции \textbf{fork()} процессорным ресурсом продолжает владеть процесс-родитель. Процесс-потомок становится в очередь на выполнение.

\subsection{Псевдораспараллеливание с циклами}
	Далее в программу были добавлены циклы длинны, достаточной для наблюдения за конкурированием процессов за процессорный ресурс:
	\lstinputlisting[style=crs_cpp]{../listings/pseudo_multi_contest.c}

	Скомпилируем и запустим программу:
	\lstinputlisting[style=crs_bash]{../listings/pseudo_multi_contest}
	
	По выводу видно, что после вызова функции \textbf{fork()} проходит некоторое время перед тем как процесс-потомок начинает работать. Поэтому вначале мы видим вывод только процесса-родителя. После запуска второго процесса вывод идет по очереди, это отражает то, что процессы конкурируют между собой за процессорное время.
	
	Процессу-родителю и процессу-потомку были заданы приоритеты с помощью функции \texttt{sched\_setscheduler}. В зависимости от установленный приоритетов можно наблюдать различия при завершении программ.
	\lstinputlisting[style=crs_bash]{../listings/pseudo_multi_contest_shced}
	
	В первом случае большим приоритетом обладала программа-потомок, поэтому сразу после запуска она первой завершила свою работу. Во втором случае программа-потомок имела меньший приоритет, поэтому первой работу завершила программа-родитель.
	
\subsection{Программы родителя и потомка}
	Были разработаны программы родителя и потомка. Тексты программы родителя:
	\lstinputlisting[style=crs_cpp]{../listings/father.c}

	Тексты программы потомка:
	\lstinputlisting[style=crs_cpp]{../listings/son.c}
	
	Скомпилируем эти программы и запустим программу-родитель:
	\lstinputlisting[style=crs_bash]{../listings/father_son}
	
	По дереву процессов  видно, что процесс father является родителем процесса son. PPID процесса son равен PID процесса father. Родителем процесса father является процесс bash. Окружающие процессы были удалены из листинга.
	
	В программе son.c присутствует функция sleep(5), которая переводит процесс в состояние сна. Благодаря тому, что в программе father присутствует функция wait(), данный процесс не завершился сразу, а дождался завершения процесса son.
	
\subsection{Фоновый режим}
	Запустим программу father в фоновом режиме:
	\lstinputlisting[style=crs_bash]{../listings/father_son_bg}
	В данном случае управление возвращается командной оболочке до завершения процесса.
	
\subsection{Различные функции семейста exec()}
	Программа father была запущена с разными вариантами функции exec(), однако результат остается таким же.\\
Пример вывода программы father с функцией execle():
	\lstinputlisting[style=crs_bash]{../listings/father_son_execle}

\subsection{функция wait(\&status)}		
	Добавим в программу father отслеживание значения, возвращаемого функцией wait():
	\lstinputlisting[style=crs_cpp]{../listings/father_wait.c}
	
	Результат работы:
	\lstinputlisting[style=crs_bash]{../listings/father_wait}
	
	Мы видим, что функция wait() возвращает PID завершенного процесса, при этом в переменную status записывается значение, с которым завершился этот процесс. С помощью семейства функций wait() можно отслеживать статус множества порожденных процессов.\\
	
	Проверим с какой очередностью выполняются процессы. Для этого добавим в программы промежуточный вывод.
	
	\lstinputlisting[style=crs_bash]{../listings/father_son_priority_simple}
	
	Видно, что родитель и потомок конкурируют за процессорное время. Узнаем доступные приоритеты:
	\lstinputlisting[style=crs_cpp]{../listings/priorities.c}
	Результат работы
	\lstinputlisting[style=crs_bash]{../listings/priorities}
	
	
	Выберем режим планирования FIFO и зададим процессу-потомку максимальный(99) приоритет, а родителю - минимальный(0).
	Родитель:
	\lstinputlisting[style=crs_cpp]{../listings/father_prioriry.c}

	Потомок:
	\lstinputlisting[style=crs_cpp]{../listings/son_priority.c}

	
	Результат запуска:
	\lstinputlisting[style=crs_bash]{../listings/father_son_priority}
		
	Видно, что после запуска процессы всё также конкурируют за процессорное время. Это связано в тем, что  SCHED\_FIFO и SCHED\_RR назначаются только в режиме суперпользователя. Запустим программу в режиме суперпользователя:
	\lstinputlisting[style=crs_bash]{../listings/father_son_priority_root}
	
	Если сделать наоборот и задать родителю максимальный приоритет:
	\lstinputlisting[style=crs_bash]{../listings/father_son_priority_root_r}
	Такая инверсия объясняется тем, что приоритеты ядра относятся к приоритетам процессов как 98..0 и 1..99 соответственно, т.е. они противоположны.\\

	
	Если изменить тип планирования на режим с квантованием и задать потомку высший приоритет, то на данной системе вывод не поменяет, процесс сын будет выводиться после процесса отца. Данное ограничение могло быть наложено systemd или selinux,	но мне его устранить ну удалось.
	
	Однако, процессы должны выполняются по очереди, так как время выполнения каждого процесса ограничено квантом времени. Но, процессы с большим приоритетом получают процессорное время чаще, т.е. в итоге больше.
	
	Определить квант времени, выделяющийся процессу можно с помощью функции \\\texttt{sched\_rr\_get\_interval}, которая возвращает время, оставшееся до завершения процессорного времени у текущего процесса:
	
	\begin{lstlisting}[style=crs_cpp]	
sched_rr_get_interval(0, &tmin);
printf("time left %d\n", tmin.tv_sec + tmin.tv_nsec/1000000);
	\end{lstlisting}
	
	Результат запуска:
	\lstinputlisting[style=crs_bash]{../listings/time_left}
	
	Значит, квант времени, выделяемый одному процессу равен 17мс. Изменить величину кванта времени можно только изменив приоритет nice.
	Однако это же значение для режима суперпользователя уже равно 100 мс.
\section{Взаимодействие родственных процессов}
	Изменяя длительности выполнения процессов и параметры системных вызовов было смоделировано 3 ситуации:
	\begin{itemize}
		\item процесс-отец запускает процесс-сын и ожидает его завершения. Исходный такого варианта был приведен ранее. Результат запуска:
	\lstinputlisting[style=crs_bash]{../listings/father_wait}
	
		\item процесс-отец запускает процесс-сын и, не ожидая его завершения, завершает свое выполнение. Зафиксируйте изменение родительского идентификатора процесса-сына;
		
		Программа-родитель:
		\lstinputlisting[style=crs_cpp]{../listings/typical_father.c}

		
		Программа-потомок:
		\lstinputlisting[style=crs_cpp]{../listings/abandoned_son.c}


		Результат запуска:
		\lstinputlisting[style=crs_bash]{../listings/abandoned_son}
	
		
		Мы видим, что после завершения работы программы father PPID программы son изменился.

		\item процесс-отец запускает процесс-сын и не ожидает его завершения; процесс-сын завершает свое выполнение. Зафиксируйте появление процесса-зомби, для этого включите команду ps в программу father.c;
		
		Программа-родитель:
		\lstinputlisting[style=crs_cpp]{../listings/typical_father_zombie.c}
		
		Программа-потомок:
		\lstinputlisting[style=crs_cpp]{../listings/abandoned_son_zombie.c}
	
		Результат запуска:
		\lstinputlisting[style=crs_bash]{../listings/abandoned_son_zombie}	
		
		Мы видим, что программа son завершает свое выполнение, однако процесс son еще не исчез. Процесс son перешел в статус зомби - он не может выполняться, но еще не освободил все используемые ресурсы.
	\end{itemize}
	
\section{Управление процессами посредством сигналов}
	Сигналы в UNIX, UNIX-подобных и других POSIX-совместимых операционных системах являются одним из способов взаимодействия между процессами. Фактически, сигнал --- это асинхронное уведомление процесса о каком-либо событии. Когда сигнал послан процессу, операционная система прерывает выполнение процесса. Если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале. Если процесс не установил обработчик, то выполняется обработчик по умолчанию.
	
	Ознакомиться со списком существующих сигналов можно выполнив команду \textbf{kill -l}:
	\lstinputlisting[style=crs_bash]{../listings/kill_l}
	
	В программах на языке С работа с сигналами происходит с помощью системных вызовов \textbf{kill()} и \textbf{signal()}. \textbf{kill()} посылает указанный сигнал указанному процессу. Если не указано ни одного сигнала, посылается сигнал SIGTERM. Сигнал SIGTERM завершит те процессы, которые не обрабатывают его приход. Для других процессов может быть необходимым послать сигнал 9 (SIGKILL), поскольку этот сигнал перехватить нельзя. \textbf{signal(int sig, void (*func)(int))} назначает действие, предпринимаемое при получении программой сигнала sig. Если значение func равно \texttt{SIG\_DFL}, то происходит обработка по умолчанию для указанного сигнала. Если значение func равно \texttt{SIG\_IGN}, то сигнал игнорируется. В остальных случаях func указывает на вызываемую функцию обработчик сигнала при получении сигнала. Функция func может завершиться выполнением операции возврата или вызовом функций самозавершения, выхода или перехода.
	\subsection{Основная работа с сигналами}	
	Были подготовлены программы следующего содержания: 
	\begin{itemize}
		\item процесс father порождает процессы son1, son2, son3 и запускает на исполнение программные коды из соответствующих исполнительных файлов; 
		\item далее родительский процесс осуществляет управление потомками, для этого он генерирует сигнал каждому пользовательскому процессу; 
		\item в пользовательских процессах-потомках необходимо обеспечить:
			\begin{itemize}
				\item для son1 - реакцию на сигнал по умолчанию; 
				\item для son2 - реакцию игнорирования; 
				\item для son3 - перехватывание и обработку сигнала.		
			\end{itemize}	
	\end{itemize} 
	
	Программа father.c:
	\lstinputlisting[style=crs_cpp]{../listings/honest_father.c}
	
	Программа создает три процесса-потомка, ждет 5 секунд и посылает каждому потомку сигнал SIGUSR1.
	
	Программа son1.c, которая выполняет обработку сигнала по-умолчанию:
	\lstinputlisting[style=crs_cpp]{../listings/son1.c}
	
	Программа son2.c, которая игнорирует поступивший сигнал:
	\lstinputlisting[style=crs_cpp]{../listings/son2.c}
	
	Программа son3.c, которая выполняет пользовательскую обработку сигнала (в данном случае -- печать сообщения на экран):
	\lstinputlisting[style=crs_cpp]{../listings/son3.c}
	
	Данные программы были скомпилированы. Программа father была запущена. Результаты запуска:	
	\lstinputlisting[style=crs_cpp]{../listings/honest_father}
	
	Посмотрим таблицу процессов до и после посылки сигналов:
	\lstinputlisting[style=crs_bash]{../listings/honest_father_zombie}
	
	По таблице процессов видно, что после обработки сигнала процессы son1 и son3 перешли в состояние зомби. Первый потомок перешел в это состояние из-за того, что по умолчанию, сигнал SIGUSR1 и  завершает выполнение процесса. Второй потомок проигнорировал пришедший сигнал и продолжает работу.
	
	\subsection{Процессы в разных состояниях}
	Рассмотрим случай обмена сигналами между процессами в разных состояниях: активном и пассивном. Для этого запустим процесс son3 в фоновом режиме, посмотрим его PID и, изменив исходный код программы father, запустим ее в активном режиме. Для фиксации моментов посылки и получения сигнала используем стандартные функции \textbf{time()} и \textbf{localtime()}.
	
	Код пассивного процесса:
	\lstinputlisting[style=crs_cpp]{../listings/son3_passive.c}

	Укажем в программе father PID процесса son3 для посылки сигнала:
	\lstinputlisting[style=crs_cpp]{../listings/honest_father_kills_passive_son.c}
	
	Запустим программы:
	\lstinputlisting[style=crs_bash]{../listings/kill_passive_son}
	
	Вывод программ показывает, что обмен сигналом между двумя процессами происходит менее чем за секунду.
	
	Запустим три программы в фоновом режиме. Посмотрим на вывод команды \textbf{jobs}:
	\begin{lstlisting}[style=crs_bash]
$ ./son1 & ./son2 & ./son3 &
[1] 3372
[2] 3373
[3] 3374
$ 
 SON PARAM: pid=3372 ppid=2362 

SON PARAM: pid=3374 ppid=2362 
 SON PARAM: pid=3373 ppid=2362 

$ jobs
[1]   Running                 ./son1 &
[2]-  Running                 ./son2 &
[3]+  Running                 ./son3 &
	\end{lstlisting}

	Команда \textbf{jobs} выводит нас список процессов, выполняющихся в фоновом режиме. Для того, чтобы вернуть программу в активный режим можно воспользоваться командой \textbf{fg}. Вернем задачу 1 в активный режим:
	\begin{lstlisting}[style=crs_bash]
$ fg %1
./son1
^C
$ jobs
[2]-  Running                 ./son2 &
[3]+  Running                 ./son3 &
	\end{lstlisting}	
	
	После того, как мы вернули программу son1 в активный режим и прервали ее работу, осталось всего два задания, выполняющихся в фоновом режиме. Отменим невыполненные задания с помощью команды \textbf{kill}.	
	\begin{lstlisting}[style=crs_bash]
$ kill %2
$ kill %3
[2]-  Terminated              ./son2
[3]+  Terminated              ./son3
$ jobs
	\end{lstlisting}	
	
	Вывод пуст -- мы отменили все задания.
	
	\subsection{nice и getpriority}
	Утилита \textbf{nice} --- программа в UNIX-подобных ОС, предназначенная для запуска процессов с изменённым приоритетом \textbf{nice}. Приоритет \textbf{nice} (целое число) процесса используется планировщиком процессов ядра ОС при распределении процессорного времени между процессами.
	
	Команда \textbf{nice} --- встроенная команда интерпретатора команд (shell), выполняющая такие же функции, как и утилита \textbf{nice}, но работающая внутри процесса shell. Реализована, например, интерпретаторами команд csh и tcsh.

	Приоритет \textbf{nice} --- число, указывающее планировщику процессов ядра ОС приоритет, который пользователь хотел бы назначить процессу.
	
	Утилита \textbf{nice}, запущенная без аргументов, выводит приоритет nice, унаследованный от родительского процесса. \textbf{nice} принимает аргумент «смещение» в диапазоне от -20 (наивысший приоритет) до +19 (низший приоритет). Если указать смещение и путь к исполняемому файлу, утилита \textbf{nice} получит приоритет своего процесса, изменит его на указанное смещение и использует системный вызов семейства exec() (англ.) для замещения кода своего процесса кодом из указанного исполняемого файла. Команда \textbf{nice} сделает то же, но сначала выполнит системный вызов семейства fork() для запуска дочернего процесса. Если смещение не указано, будет использовано смещение +10. Привилегированный пользователь (root) может указать отрицательное смещение.

	Попробуем изменить приоритет для командной оболочки:
	\lstinputlisting[style=crs_bash]{../listings/nice}

	Для получения текущего приоритета \textbf{nice} процесса используется системный вызов \textbf{getpriority()}, а для его изменения — \textbf{setpriority()}.
	
	Создадим программу для определения максимального и манимального приоритетов:
	\lstinputlisting[style=crs_cpp]{../listings/priority_borders.c}	
	
	Увеличивать приоритет программ может только суперпользователь. Запустим программу от имени обчного пользователя, а затем от имени суперпользователя:
	\lstinputlisting[style=crs_cpp]{../listings/priority_borders}	
	
	Значит, суперпользователь может устанавливать приоритет пользовательским программам в любых, доступных в системе, пределах. Обычному пользователю же доступно только понижение приоритета. Мы видим, что при запуске программ из shell они имеют приоритет 0.

Проверим границы значений приоритета для системных процессов:
	\begin{lstlisting}[style=crs_bash]	
$ nice -n 40 /bin/bash
$ nice
19
$ nice -n -40 /bin/bash
$ nice
-20
	\end{lstlisting}
	
	Для системных процессов приоритет так же меняется в любых пределах.
	
	\subsection{nohup}
	\textbf{nohup} --- UNIX-утилита, запускающая указанную команду с игнорированием сигналов потери связи (SIGHUP). Таким образом, команда будет продолжать выполняться в фоновом режиме и после того, как пользователь выйдет из системы.
	Запустим какой-либо длительный процесс с помощью этой утилиты и выйдем из системы:
	\lstinputlisting[style=crs_bash]{../listings/nohup}	
	
	Выйдем из системы, войдем снова и проверим таблицу процессов:
	\lstinputlisting[style=crs_bash]{../listings/nohup_relogin}	
	
	\subsection{UID и PID}
	UID процесса определяется UID пользователя, которому этот процесс принадлежит. Один из способов посмотреть UID процесса -- команда \textbf{ps -s}:
	\begin{lstlisting}[style=crs_bash]	
$ ps -s
  UID   PID   PENDING   BLOCKED   IGNORED    CAUGHT STAT TTY        TIME COMMAND
 1000  5525  00000000  00010000  00380004  4b817efb Ss   pts/6      0:00 bash
 1000  5605  00000000  00000000  00000001  00000200 S    pts/6      0:00 ./son3
 1000  5658  00000000  00000000  00000000  73d3fef9 R+   pts/6      0:00 ps -s
	\end{lstlisting}
	
	Множество допустимых значений UID зависит от системы; в общем случае UID допускает использование значений от 0 до 65535 с некоторыми оговорками:
	\begin{itemize}
		\item Суперпользователь всегда должен иметь UID, равный нулю (0).
		\item Пользователю nobody обычно присваивается или наибольший из возможных UID (в противоположность суперпользователю), или один из системных UID (см. ниже).
		\item UID с 1 по 100 по соглашению резервируются под системные нужды; некоторые руководства рекомендуют резервировать UID со 101 по 499 (в Red Hat) или даже 999 (в Debian).	
	\end{itemize}
	
	Значение UID ставится в соответствие пользователю в файле /etc/passwd.\\
	
	 PID --- уникальный номер (идентификатор) процесса в многозадачной операционной системе. Имеется два специальных значения PID. Процесс с номером 0 (часто не отображается в списке), отвечает за выгрузку страниц и является частью ядра операционной системы. Процесс 1 - обычно является процессом init, ответственным за запуск и останов системы, однако в моём случае это более современное решение - systemd. Также обычно init или systemd становится родительским процессом для процессов-сирот.

	В Linux максимальный возможный идентификатор процесса по умолчанию ограничен 32 тысячами, но может быть перенастроен на величину до 4 миллионов. Системные процессы имеют наименьшие PID, потому что начинают выполняться самыми первыми. Системными процессами являются: shed (диспетчер свопинга), vhand (диспетчер страничного замещения), bdfflush (диспетчер буферного кэша) и kmadaemon (диспетчер памяти ядра). К системным процессам следует отнести systemd, являющийся прародителем всех остальных процессов в UNIX. Хотя systemd не является частью ядра, и его запуск происходит из исполняемого файла (/usr/lib/systemd/systemd), его работа жизненно важна для функционирования всей системы в целом.
	
\section{Многонитевое функционирование}
	Подготовим программу, формирующую несколько нитей.
	\lstinputlisting[style=crs_cpp]{../listings/mthreads.c}
	
	Скомпилируем программу и запустим ее. 
	\lstinputlisting[style=crs_cpp]{../listings/mthreads}
	
	\subsection{Завершение нити командой kill}	
	После начала работы откроем новый терминал выведем дерево процессов с помощью команды \textbf{ps -aLf}.
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_ps}
	
	Мы видим, что программа создала две нити. Все нити имеют общий PID, поэтому завершить выполнение одной из нитей извне невозможно, потому что нить является внутренней частью процесса и завершить ее работу извне невозможно.
	\begin{lstlisting}[style=crs_bash]		
$ kill 19983
$ ps -aLf | grep mthreads
 	\end{lstlisting}
 	
	\subsection{Зывершение нити сигналом}	
	Попробуем завершить работу одной из нитей отправив ей сигнал SIGUSR2 и установив обработчик по умолчанию (для сигналов SIGUSR1 и SIGUSR2 обработчик по умолчанию завершает работу процесса). Для этого изменим программу следующим образом:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_signal.c}
	
	Результат работы:
	\begin{lstlisting}[style=crs_bash]		
$ ./prog
thread2, 0
thread1, 0
[1]    30879 user-defined signal 2  ./mthreads
$ ps -aLf | grep mthreads
 	\end{lstlisting}
 	
 	Мы видим, что обработчик завершил не только выполнение нити, но и всего процесса. Как было сказано ранее, нить является внутренней частью процесса и завершить ее работу извне невозможно. В документации функции \textbf{\texttt{pthread\_kill()}} указано, что она только убеждается в том, что сигнал будет обработан в контексте данной нити. Результирующее действие сигнала (будь то остановка или завершение работы) оказывает влияние на весь процесс. В данном случае, обработчик по умолчанию сигнала SIGUSR2 вызывает завершение всего процесса.
 	
	\subsection{Завершение только нити сигналом}
 	Для того, чтобы по сигналу завершить выполнение только одной нити необходимо добавить свой обработчик сигнала, в котором выполнить системный вызов \textbf{\texttt{pthread\_exit(NULL)}}.
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_signal_handler.c}
	
	Скомпилируем и запустим программу:	
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_signal_handler_exec}
	
	Мы видим, что на 5 секунде работы нить номер 2 получает сигнал SIGUSR2 и завершает свою работу. Процесс и другая нить при этом продолжают выполняться в нормальном режиме. Убедиться в этом можно и с помощью утилиты \textbf{ps}:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_signal_handler}
	
	Модифицируем программу так, чтобы управление второй нитью осуществлялось с помощью сигналов, отправляемых из первой нити:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_signal_handler_ft.c}

	
	Результаты запуска совпали с предыдущими.

	\subsection{Перехватывание сигналов}
	Модифицируем программу и реализуем в ней обработку сигнала прерывания SIGINT, который генерируется при нажатии клавиш <<CTRL+C>>.
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch.c}

	
	Результат запуска:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch}
	
	Программа ушла в бесконечный цикл и мы не можем прервать ее работу сочетанием клавиш <<CTRL+C>>. Для ее завершения необходимо воспользоваться командой \textbf{kill}.\\

	Для того, чтобы перехватить сигнал в нити, достаточно просто перенести команду \textbf{signal()} из функции main() в тело одной из нитей:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch_in_thread.c}
	

	Результат запуска:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch_in_thread}
	
	Для реализации многократного перехвата сигнала с восстановлением исходного обработчика после нескольких раз срабатывания, необходимо в функции-обработчике сигнала добавить рекурсивный вызов функции \textbf{signal()} с восстановлением обработчика по умолчанию.
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch_return.c}
	
	Результат запуска:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_catch_return}
	
	\subsection{Список всех сигналов}
	Ознакомиться со списком существующих сигналов можно выполнив команду \textbf{kill -l}:
	\lstinputlisting[style=crs_bash]{../listings/kill_l}
	
	Краткая характеристика сигналов с 1 по 32:
	\begin{itemize}
		\item SIGABRT -	6 --- Сигнал посылаемый функцией abort()
		\item SIGALRM - 14 --- Сигнал истечения времени, заданного alarm()
		\item SIGBUS - 10 --- Неправильное обращение в физическую память
		\item SIGCHLD - 18 --- Дочерний процесс завершен или остановлен
		\item SIGCONT - 25 --- Продолжить выполнение ранее остановленного процесса
		\item SIGFPE - 8 --- Ошибочная арифметическая операция
		\item SIGHUP - 1 --- Закрытие терминала
		\item SIGILL - 4 --- Недопустимая инструкция процессора
		\item SIGINT - 2 --- Сигнал прерывания (Ctrl-C) с терминала
		\item SIGKILL - 9 --- Безусловное завершение
		\item SIGPIPE - 13 --- Запись в разорванное соединение (пайп, сокет)
		\item SIGQUIT - 3 --- Сигнал «Quit» с терминала (Ctrl-\\)
		\item SIGSEGV - 11 --- Нарушение при обращении в память
		\item SIGSTOP - 23 --- Остановка выполнения процесса
		\item SIGTERM - 15 --- Сигнал завершения (сигнал по умолчанию для утилиты kill)
		\item SIGTSTP - 20 --- Сигнал остановки с терминала (Ctrl-Z)
		\item SIGTTIN - 26 --- Попытка чтения с терминала фоновым процессом	
		\item SIGTTOU - 27 --- Попытка записи на терминал фоновым процессом	
		\item SIGUSR1 - 16 --- Пользовательский сигнал № 1
		\item SIGUSR2 - 17 --- Пользовательский сигнал № 2
		\item SIGPOLL - 22 --- Событие, отслеживаемое poll()
		\item SIGPROF - 29 --- Истечение таймера профилирования	
		\item SIGSYS - 12 --- Неправильный системный вызов
		\item SIGTRAP - 5 --- Ловушка трассировки или брейкпоинт
		\item SIGURG - 21 --- На сокете получены срочные данные
		\item SIGVTALRM - 28 --- Истечение «виртуального таймера»
		\item SIGXCPU - 30 --- Процесс превысил предел процессорного времени
		\item SIGXFSZ - 31 --- Процесс превысил допустимый размер файла
	\end{itemize}
	
	Сигналы с номерами 32--64 являются сигналами реального времени. Эти сигналы имеют следующие особенности:
	\begin{itemize}
		\item Сигналы помещаются в очередь.
		\item Если сигнал будет порожден несколько раз, он будет несколько раз получен адресатом. Более того, повторения одного и того же сигнала доставляются в порядке очереди (FIFO). Если же сигналы в очередь не помещаются, неоднократно порожденный сигнал будет получен лишь один раз.
		\item Когда в очередь помещается множество неблокируемых сигналов в диапазоне SIGRTMIN—SIGRTMAX, сигналы с меньшими номерами доставляются раньше сигналов с большими номерами. То есть сигнал с номером SIGRTMIN имеет «больший приоритет», чем сигнал с номером SIGRTMIN+1, и т.д.
	\end{itemize}

	\section{Анализ процедуры планирования}
	Рассмотрим распространение приоритета по потокам в пределах одного процесса. Проведём 4 эксперимента:
\begin{enumerate}
	\item Изменим политику родителя и посмотри, изменится ли она у уже существующего потомка
	\item Изменим политику потомка и посмотрим, изменится ли она у родителя
	\item Вызовем из потомка изменение политики планирования по PID и посмотрим, чьи политики изменятся
	\item Попробуем изменить политику из стороннего процесса и посмотрим, чья изменится
\end{enumerate}		
	 Для этого была написан следующая программа:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_policy.c}
	А для изменения политики планирования из вне - следующая:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_policy_changer.c}
	Результат выполнения всех четырёх экспериментов:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_policy}
	Сразу после появления PID изучаемого процесса, в соседнем эмуляторе терминала от имени суперпользователя была запущена вторая программа:
	\lstinputlisting[style=crs_cpp]{../listings/mthreads_policy_changer}
	Из первого и второго эксперимента мы видим, что нити наследуют политику процесса. Так же по первому, третьему и четвёртому эксперименту видно, что нити не меняют свою политику, когда изменяется политика процесса, независимо от источника изменения. Однако, как видно по второй ните, программно можно изменить политику отдельной нити из самой нити, задав в качестве аргумента для sched\_setscheduler 0, т.е. вызывающую нить.

\subsection{Сочетания приоритетов и политик}
	Для проверки связи динамического и статического приоритетов посмотрим, меняет ли статический приоритет при изменение динамического и наоборот. Для это проведём опыты с различными системными вызовами при различных политиках. Нам известно, что для политики OTHER доступен только нулевой статический приоритет и 40 динамических. Попробуем изменить динамический приоритет системными вызовами \textbf{nice()} и \textbf{setpriority()}. После изменим политику планирования на Round Robin c максимальным статическим приоритетом и снова попробуем менять динамический. Для этого была написана следующая программа:
	\lstinputlisting[style=crs_cpp]{../listings/nice_no_static.c}
	Скомпилируем программу и запустим её от имени суперпользователя:
	\lstinputlisting[style=crs_bash]{../listings/nice_no_static}
	Как было выяснено ранее, статический приоритет для OTHER равняется нулю, а динамический меняется в пределах от -20 до 19. Из данного примера мы видим, что при политике планирования OTHER меняется только динамический приоритет, а при политиках планирования реального времени изменение динамического приоритета хоть и возможно, но бесполезно так как эти политики оперяются на статический приоритет. А его не изменить системными вызовами \textbf{nice()} и \textbf{setpriority()}.


	\section{Системный вызов clone()}
	В 2000 году В Linux был введен новый системный вызов clone, который размыл различия между процессами и потоками. Вызова clone нет ни в одной из версий UNIX. Классический при создание нового потока исходный поток и новый поток совместно использовали всё, кроме регистров. А у процессов были собственные файловые дескрипторы, обработчики сигналов, прочие глобальные свойства. Системный вызов clone дал возможность процессам разделять общее адресное пространство, файловые дескрипторы и т.д. Но появились и другие новые возможности. Все эти аспекты контролируются флагами при вызове clone().\\
	Изучим влияние основных флагов на разделения основных параметров между процессами. Для это была написана следующая программа. Она объявляет переменную, открывает файл, выводит PID и PPID, после чего происходит системный вызов \textbf{clone()}, создающий поток, закрывающий файл, меняющий переменную и также выводящий PID и PPID. По изменениям в главном потоке после выполнения порождённого мы и узнаем, что они разделяют между процессами:


	\lstinputlisting[style=crs_cpp]{../listings/clone.c}
	Эксперименты будем проводить меняя в исходном коде соответствующие флаги системного вызова clone().\\		Запустим без каких либо флагов:
	\lstinputlisting[style=crs_bash]{../listings/clone1}
	Из листинга видно, что был создан новый процесс с отдельными PID, дескрипторами и адресным пространством. При этом родителем является наш процесс родитель. В таком поведение нет ничего уникального\\
	
	Добавим флаг CLONE\_PARENT. Это должно привести к тому, что у потомка будет тот же родитель, что и у родителя.
	\lstinputlisting[style=crs_bash]{../listings/clone2}
	Результаты совпали с ожидаемыми.\\

	Теперь сделаем общим адресное пространство (флаг CLONE\_VM). Должна измениться переменная.	
	\lstinputlisting[style=crs_bash]{../listings/clone3}
	Переменная в родителе изменилась, значит, процессы разделяют адресное пространство, хоть и являются с традиционной точки зрения разными процессами.\\

	Теперь сделаем общими дескрипторы файлов (флаг CLONE\_FILES). Чтение из файла должно вызвать ошибку, так как мы закроем его в потомке.
	\lstinputlisting[style=crs_bash]{../listings/clone4}
	Родитель не смог почесть файл, что говорит о том, что таблица файловых дескрипторов общая.\\

	Теперь попробуем создать поток в том же процессе (флаг CLONE\_THREAD). В таком случае поток внутри процесса должен повести себя как традиционный процесс (отдельные дескрипторы, адресное пространство)
	\lstinputlisting[style=crs_bash]{../listings/clone5}
	Вывод потомка на экран пропал, в данном случае это говорит от том, что потомок не вызван. Связано это с тем, что CLONE\_THREAD работает только при наличе CLONE\_SIGHAND, а он работает только при наличие CLONE\_VM. Таким образом возможности создать поток с отдельным адресным пространством и обработчиком сигналов в рамках одного процесса нельзя. Рассмотрим пример, добавив эти зависимости:
	\lstinputlisting[style=crs_bash]{../listings/clone5_1}
	PID совпал, так как потоки находятся в одном процессе. Так же поменялась переменная. И обработчик сигналов теперь общий. Однако удалось создать новую (отдельную) таблицу дескрипторов.\\

	Теперь попробуем создать отдельный процесс, но с таким же PID (флаг CLONE\_PID). Результат будем наблюдать в виртуальной ФС proc (появится ли папки с одинаковыми именами).
	\lstinputlisting[style=crs_bash]{../listings/clone6}
	Ошибка компилятора говорит, что такой флаг не объявлен. А в мануале написано, что с версии ядра 2.3.21 этот флаг был доступен только процессу загрузчику (PID 0), ещё позже, в версии 2.5.16, от флага полностью отказались.
	
	Это далеко не все доступные флаги, но и их достаточно, чтобы показать отличную природу системного вызова clone().
\section{Вывод}
	В данной работе были изучены основные принципы управления процессами и потоками в ОС Linux. 
	
	У каждого процесса есть уникальный номер, называемый process ID, или PID, и, как и у файлов, у каждого процесса есть владелец и группа. Информация о владельце и группе процесса используется для определения того, какие файлы и устройства могут быть открыты процессом с учетом прав на файлы. У всех процессов есть родительский процесс. Исключением из этого правила является специальный процесс init. init --- первый процесс запускаемый в системе, его PID всегда равен 1.
	
	Управление процессами через программный интерфейс происходит с помощью системных вызовов. Основные функции это \textbf{fork()} -- создание процесса, семейство функций \textbf{exec()} для загрузки новый программ в созданный процесс и семейство функций \textbf{wait()} для корректного завершения работы всех процессов.
	
	Процессы изолированы друг от друга, ни один процесс не может обратиться к адресному пространству другого. Поэтому для организации взаимодействия между процессами используются специальные инструменты.
	
	Сигналы — это асинхронный механизм передачи сообщений между процессами и от ядра к процессам. Они оповещают процесс о том, что произошло определённое событие. Сигналы могут генерироваться программно, с использованием системных вызовов \textbf{kill()} и \textbf{sigsend()}. Кроме того, сигналы могут генерироваться различными аппаратными событиями.  При поступлении сигнала автоматически вызывается обработчик сигнала, который выполняет необходимые действия. Для всех сигналов имеется обработчик по умолчанию, но при создании программы можно перехватить эти сигналы и вызвать для них свой обработчик. Единственный сигнал, который невозможно перехватить --- сигнал SIGKILL, который вызывает принудительное завершение процесса.
	
	 Приоритет --- это числовая характеристика выполняемого на компьютере процесса, которая позволяет определить порядок его исполнения в очереди процессов. Обеспечивает реализацию мультипрограмности на однопроцессорных системах. После запуска процессы конкурируют между собой за процессорное время. Для разрешения конфликтов используются различные методики планирования. В данной работе были рассмотрены две методики: FIFO и RR. FIFO (First Input First Output) --- методика планирования, при которой процессы выполняются в порядке очереди. Процессорным ресурсом владеет процесс с наивысшим приоритетом. Он не освобождает ресурс до тех пор, пока не завершится или пока не придет процесс с еще более высоким приоритетом. Методика RR схожа с FIFO. Главное отличие в том, что процесс может занять процессорное время только на определенный промежуток времени (квант). При истечении этого кванта процесс должен освободить ресурс, даже если он еще не завершил свою работу. В операционной системе UNIX используются динамические приоритеты, основанные на статических системных приоритетах. 
	 	
	Были изучены потоки в Unix. Однопоточный процесс использует, как обычно, код, данные в основной памяти и файлы, с которыми он работает. Процесс также использует определенные значения регистров и стек, на котором исполняются его процедуры. Многопоточный процесс организован несколько сложнее. Он имеет несколько параллельных потоков, для каждого из которых ОС создает свой стек и хранит свои собственные значения регистров. Потоки работают в общей основной памяти и используют то же адресное пространство, что и процесс-родитель, а также разделяют код процесса и файлы. 

\end{document}

