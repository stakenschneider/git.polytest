\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}
\usepackage{listings}
\lstset{ %
language=bash,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm] % название работы, затем отступ 0,6см
\large Отчет по лабораторной работе №2\\[0.1cm]
\large Файловые системы\\[5cm]
% тема работы, затем отступ 3,7см
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Типы файлов}
\subsection{Задание:} Ознакомиться с типами файлов исследуемой ФС.
Применяя утилиту ls, отфильтровать по одному примеру каждого типа файла используемой вами ФС. Комбинируя различные ключи утилиты рекурсивно просканировать все дерево, анализируя крайнюю левую позицию выходной информации полученной посредством ls –l. Результат записать в выходной файл с указанием полного пути каждого примера. Выполнить задание сначала в консоли построчно, выбирая необходимые сочетания ключей  (в командной строке), а затем оформить как скрипт с задаваемым в командной строке именем файла как параметр.

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/types_nr}
\begin{itemize}
\item \textbf{cd /} - переход в корневую директорию
\item \textbf{ls -ld \$PWD**/* 2>/dev/null} - вызов \textbf{ls} отдельно для всех файлов в и ниже текущей директории и перенаправление потока ошибок "в никуда"
\item \textbf{grep \^{} [-dplscb]} - избавление от всех строк, что не начинаются одним из символов \textit{-dplscb} .
\item \textbf{sort -k1.1,1.1} - сортировка по первому символу строки
\item \textbf{uniq -w1} - оставляем строки с уникальным первым символом
\item \textbf{cd -} - возврат в исходную директорию
\end{itemize}

Однако, такое решение, являясь абсолютно работоспособным для оболочки \textbf{zsh}, не подходит для оболочки \textbf{bash}, так как в последней команда \$PWD**/* не будет рекурсивной, так как эквивалентна \$PWD*/*, а это только файлы поддиректорий (первого уровня) активной директории.

Поскольку силами команды \textbf{ls} больше нет способа вывести полный путь в строке характеристик файла, модифицируем вывод самостоятельно.

\subsection{Полное решение в командной строке:}
\lstinputlisting{../listings/types_r}
Данная команда отличается тем, что исходный(корневой) каталог мы указывает непосредственно утилите \textbf{ls} и она сама ответственна за рекурсивность, а не передаваемый ей параметр. Но главным отличием является ступень конвейера, ответственная за модификацию вывода \textbf{ls}. С помощью утилиты \textbf{awk} реализуется скрипт, запоминающий, какую директорию просматривает \textbf{ls}, и добавляющий этот путь к полю имени файла (последнему или предпредпоследнему, если это символьная ссылка).

\subsection{Скрипт:}
\lstinputlisting{../listings/types}
Уже рассмотренная команда обёрнута в минимальный набор и добавлен выбор файла со значением по умолчанию.

Рассмотрим примеры работы:
\lstinputlisting{../listings/types_examp}
Из примера видно, что в первом случае происходит запись в файл по умолчанию, а во втором - в указанный.
\section{Жесткие ссылки} \textbf{Задание:} Получить все жесткие ссылки на заданный файл, находящиеся в разных каталогах пользовательского пространства (разными способами, не применяя утилиты file и find). Использовать конвейеризацию и фильтрацию. Оформить в виде скрипта. 

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/hl_tty}
Как видно из примера, мне для реализации данной задачи в терминале потребовалось две команды и одна переменная, их связывающая. Поиск происходит в пределах домашнего каталога пользователя.

\subsection{Скрипт:}
\lstinputlisting{../listings/hl}
Сначала сохраняем inode файла в переменную, а потом проверяем всю домашнюю директорию пользователя, запустившего скрипт на наличие файлов с таким же inode.

Рассмотрим пример работы:
\lstinputlisting{../listings/hl_examp}
Из примера видно, что что все возможные варианты поведения скрипта для первого аргумента (а остальные скриптом не обрабатываются) корректно обрабатываются. И в случае существования файла и наличия его inode в домашней директории пользователя, скрипт его/их выведет.
\section{Создание символьных ссылок}
\subsection{Задание:} Проанализировать все возможные способы формирования символьных ссылок (ln, link,cp и т.д.), продемонстрировать их экспериментально.
\subsection{Утилиты}
\subsubsection{ln}

Утилита \textbf{ln} по умолчанию создает жёсткие ссылки, но флаг -s позволяет создать символьную ссылку. Рассмотрим пример:
\lstinputlisting{../listings/ls}

\subsubsection{link}

Утилита \textbf{link} - вызывает функцию создания жёстких ссылок (только жёстких). Используется только с двумя аргументами: имя исходного файла и имя ссылки. Рассмотрим пример:
\lstinputlisting{../listings/link}

\subsubsection{cp}

Утилита \textbf{cp} создана для копирования файлов, а не создания ссылок. Однако, как уже было продемонстрировано в первом отчёте, создать символьные и жёсткие ссылки можно c помощью флагов -s и -l, соответственно. Рассмотрим пример:
\lstinputlisting{../listings/cp}

\subsection{Отображение}
В примерах выше, мы видели, что утилита \textbf{ls} указывает файл, на который указывает ссылка. Но путь к этому относителен по отношению к самой ссылке. Рассмотрим на примере утилиты \textbf{ls} и \textbf{cp}:
\lstinputlisting{../listings/symlinkpath}
Из примера видно, что утилита \textbf{ln} создаёт ссылку на файл относительно директории вызова утилиты. Поэтому, ссылка sym\_link1, помещённая на директорию ниже, указывала на файл, находящийся на директорию ниже. Эту особенность мы обошли с помощью флага -r, скорректировавшего путь относительно местоположения ссылки. А утилита \textbf{cp} не позволяет создавать символьные ссылки в директории, отличной от текущей.

До этого мы пользовались общей утилитой \textbf{ls} для просмотра ссылок, но есть и специализированные - \textbf{readlink} и \textbf{realpath}. Рассмотрим:
\lstinputlisting{../listings/readlink}
Из приведённого видно, что для ссылки можно получить и полный путь.
\section{Символьные ссылки} Предложить скрипт, подсчитывающий и перечисляющий все полноименные символьные ссылки на файл, размещаемые в разных местах файлового дерева. Получить все символьные ссылки на заданный в качестве входного параметра файл, не используя file.

\lstinputlisting{../listings/sym_search}

Первой командой данного скрипта мы узнаём и запоминаем полный путь до указанного нами файла. А первые шаги поиска ссылок нам уже известны: модификация вывода утилиты \textbf{ls}, добавляющая полный путь к файлам. После чего выделяются только ссылки и по полному пути к ним утилитой \textbf{realpath} идентифицируется файл, на который они ссылаются. Этот результат файл сравнивается с запомненным в начале скрипта по полному пути и имени.

Данный скрип не считает количество ссылок, а всего лишь выводит их. Но этот функционал легко добавить конвейером, что сейчас и рассмотрим.
\lstinputlisting{../listings/sym_search_examp}
Из приведённого видно, что утилита \textbf{wc} позволяет посчитать количество строк, что нам и требуется. Таким образом мы узнали, что у нас есть 3 символьных ссылки на этот файл.

\section{Find} \subsection{Задание:}Изучить утилиту , используя ее ключи получить расширенную информацию о всех типах файлов. Создать примеры вложенных команд.
\subsection{Расширенно о типах файлов}
Утилиты \textbf{find} имеет фалг -ls соответствующий форме вывода утилиты \textbf{ls} с флагами -dils, однако пользоваться рассматриваемой сейчас утилитой проще, так как она позволяет легко организовать вложенность. Найдём по одному примеру файла каждого типа:
\lstinputlisting{../listings/find}
\subsection{Вложенные команды}
Одна из важных особенностей утилиты - возможность вызывать утилиты внутри самой утилиты. Существует несколько типов вызова утилит:
\begin{itemize}
\item exec - вызывает утилиту из активной директории
\item execdir - вызывает утилиту из директории файла
\item ok - аналог exec, но подтверждения для каждого файла
\item okdir - аналог execdir, но подтверждения для каждого файла
\end{itemize}
Рассмотрим работу со вложенными командами:
\lstinputlisting{../listings/find_in}
И приведённого видна разница между exec и execdir по утилите \textbf{pwd}. И продемонстрирована возможность создавать и удалять файлы по различным критериям с использованием вложенных команд.
\section{Заголовок файла} \subsection{Задание:}Проанализировать содержимое заголовка файла, а также файла-каталога с помощью утилит od  и  *dump. 
Если доступ к файлу-каталогу возможен (для отдельных модификаций POSIX-совместимых ОС), проанализировать изменение его содержимого при различных операциях над элементами, входящими в его состав (файлами и подкаталогами).  
\subsection{Эксперименты:}
\lstinputlisting{../listings/od}
Из приведённого видно, как выглядят пустой файл и текстовый файл из двух и четырёх символов.\\

В определённый момент развития ОС Linux, вероятно при переходе от записей в файлах директорий фиксированной длинны к переменной, было решено отгородить пользователя от работы с менее тривиальной структурой. Так уже много лет директории недоступны для системного вызова read(), а имеют собственный readdir() и getdents(). И именно из-за использования read() утилиты cat, od и подобные не могут продемонстрировать нам дирректорию. Однако утилита dumpfs позволяет сделать дамп файла директории. Для эксперимента был отформатирован usb-накопитель в ФС ext4. Файл устройства /dev/sdd1.\\

\noindent Создадим пустую директорию в корне:
\lstinputlisting{../listings/dirdump_create_dir}
Теперь создадим дамп:
\lstinputlisting{../listings/dirdump_dump}
Теперь дамп находится в файле dir\_dump, рассмотрим уже его дамп:
\lstinputlisting{../listings/dirdump_dump_of_the_dump}
Первые 4 байта дампа соответствуют inode самой директории, следующие 4 байта пока не очевидны и ещё 4 байта содержат имя директории ".". Такой же набор в 12 байт для родительской директории имя - ".." и inode - 2, так как родителем является корень данной ФС. Оставшаяся область файла заполнена нулями.\\
Для уточнения средних 4 байт создадим файлы различных типов:
\lstinputlisting{../listings/dirdump_files}
Рассмотрим новый дамп:
\lstinputlisting{../listings/dirdump_dump_of_the_dump2}
Теперь ясно, что на один файл может выделяться больше 12 байт, в зависимости от длины имени. А ранее не очевидные значения второй четвёрки байт в записи имеют такие побайтные значения:
\begin{itemize}
\item Общая длина записи (младшая часть)
\item Старшая часть
\item Длина имени
\item Тип файла
\end{itemize}
Общая длина записи у сокета, вероятно имеет иное значение или формируется из других атрибутов. Немаловажно, что сокет был создан не родной утилитой и является самым сложным из приведённых типов файлов.\\

С помощью утилиты objdump можно посмотреть информацию из объектных и уже исполняемых файлов, например, дизассемблированный код:
\lstinputlisting{../listings/objdump}

\section{Максимальное количество записей в каталоге}
\subsection{Задание:} Определить максимальное количество записей в каталоге. 
Изменить размер каталога, варьируя количество записей (для этого создать программу, порождающую новые файлы и каталоги, а затем удаляющую их, предусмотрев промежуточный и конечный вывод информации о размере подопытного каталога). 

\subsection{Эксперименты:}
Определение максимального количества файлов в каталоге для моей системы не имеет особого смысла, так как максимальное количество файлов в каталоге равно ограничено только максимальным количеством файлов в ФС для ext4. А максимальное количество файлов ограничено количеством inode'ов, которое варьируется, но потолком является $2^{32}-1$. Но существуют ещё популярные ФС с существенно ограниченным, но всё же большим, количеством файлов в директории, например, FAT32. Для неё это значение равно $2^{16}-1$. Рассмотрим простой скрипт для обнаружения этого ограничения:

\lstinputlisting{../listings/max_count}
Проверим работу на отформатированном в FAT32 USB-флеш накопителе:
\lstinputlisting{../listings/max_count_examp}
Из примера видно, что удалось создать 65533 файла. Это обоснованно тем, что в директории изначально находятся два файла: ссылка на себя и ссылка на родителя. Описание такого количество файлов в файле каталога занимает порядка 2 мегабайт.


Теперь рассмотрим первые 10 изменений размера файла каталога. Для этого модифицируем скрипт:
\lstinputlisting{../listings/increase_count.sh}
Рассмотрим поведение системы в рамках ФС FAT32:
\lstinputlisting{../listings/increase_count_examp}
В левом столбце вывода расположен размер директории, а в правом - номер файла, вызвавшего увеличение (в директории на 2 файла больше). В этой ФС увеличение файла каталога имеет константный инкремент.

Теперь рассмотрим поведение системы в рамках родной для неё ФС ext4:
\lstinputlisting{../listings/increase_count_examp2}
Этот случай отличается от предыдущего тем, что первое увеличение отличается от остальных, которые уже имеют константный инкремент, сходный с рассмотренным для FAT32. Но зависимость от количества файлов тут не линейна.
\section{Файлы описания пользователя} \subsection{Задание:} Ознакомиться с содержимым /etc/passwd, /etc/shadow, с утилитой /usr/bin/passwd, проанализировать права доступа к этим файлам.
\subsection{ Теория:}
Системе необходимо где-то хранить информацию о пользователях и основным местом для этого является файл /etc/passwd. Рассмотрим первые его строки:
\lstinputlisting{../listings/passwd}
Как видно из примера, в присутствует определённый формат данных, рассмотри его:

[Имя]:[Пароль]:[№ Пользователя]:[№ Группы]:[Домашняя Директория]:[Интерпретатор]

Однако из-за доступности файла хранить в нём пароли не желательно, поэтому в поле пароля мы наблюдаем "х". Для хранения паролей используется файл /etc/shadow. Он имеет специфичные права доступа в системах семейства RH:
\lstinputlisting{../listings/shadow_rights}
В ОС семейства Ubuntu права нагляднее:
\lstinputlisting{../listings/shadow_rights_u}
В обоих случаях прямую запись в файл может выполнить только владелец файла, root.

Рассмотрим первые строки:
\lstinputlisting{../listings/shadow}
Как видно из примера, в присутствует определённый формат данных, рассмотри его:
\begin{itemize}
\item Имя пользователя. Сопоставляется с оным в /ets/passwd
\item Зашифрованный пароль — от 13 до 24 символов. Пароль зашифрован с помощью библиотечной функции crypt(3) или по хеш алгоритму md5. В этом поле, значения отличные от корректно зашифрованного или хешированного пароля используются для контроля. Например, если значение равно ! or *, аккаунт заблокирован и пользователю вход не разрешён . Если же !! , то пароль не установлен
\item Время последнего изменения пароля (от 01.01.1970)
\item Число дней до возможности сменить пароль
\item Число дней до необходимости поменять пароль
\item Число дней за которое появится предупреждения о необходимости смены пароля
\item Число дней до деактивации аккаунта после окончания срока годности пароля
\item Число дней с момента деактивации пользователя
\item Зарезервированные поля — сейчас игнорируются в большинстве систем
\end{itemize}

\subsection{Эксперименты:}
Для этого опыта создадим пользователя lab2:
\lstinputlisting{../listings/passwd_examp}
Значения по умолчанию подразумевают, что перейти в пользователя lab2 можно, только будучи суперпользователем. Это обоснованно тем, что пароль не задан вовсе, а не задан пустой. Поэтому все попытки входа будут неудачны, кроме той, что не требует пароля вовсе.
\lstinputlisting{../listings/passwd_login}
Зададим пароль:
\lstinputlisting{../listings/passwd_set}
Из приведённого видно, что поменять пароль может только суперпользователь. И пароль работает.\\

Рассмотрим влияние файла /etc/passwd:
\lstinputlisting{../listings/passwd_change}
То есть отсутствие пароля здесь означает отсутствие пароля у пользователя. А наличие чего-либо отличного от ничего и "х" не позволяет проверить пароль в /etc/shadow и не является паролем.
\section{Права владения и доступа} Исследовать права владения и доступа, а также их сочетаемость
\subsection{chmod, chown} Утилита chown работает только при наличие прав суперпользователя. Рассмотрим пример работы:
\lstinputlisting{../listings/chown}
Таким образом, указав данные в формате Пользователь:Группа, я заменил соответствующие атрибуты файла.\\
\par Утилита chmod работает в случае, если файл принадлежит текущему пользователю, независимо от наличия прав чтения и записи.
\lstinputlisting{../listings/chmod}
\subsection{SUID} Атрибут SetUID установленный у исполняемого файла позволяет повысить права текущего пользователя до прав владельца файла. Примеры использования рассматриваются в пункте \ref{getaway}.
\subsection{ Права пользователя и группы} Рассмотрим, как формируются итоговые права на использование файла, если права пользователя и группы, в которую он входит, различны:
\lstinputlisting{../listings/u_vs_g}
Из примера видно, что права владельца приоритетнее прав группы.
%\subsection{ Сопоставить} возможности исполнения наиболее часто используемых операций, варьируя правами доступа к файлу и каталогу.

\section{«Программа-шлюз» } \label{getaway}
\subsection{Задание:} Разработать «программу-шлюз» для доступа к файлу другого пользователя при отсутствии прав на чтение информации из этого файла. Провести эксперименты для случаев, когда пользователи принадлежат одной и разным группам. Сравнить результаты. Для выполнения задания применить подход, аналогичный для обеспечения функционирования утилиты /usr/bin/passwd (манипуляции с правами доступа, флагом SUID, а также размещением файлов).
\subsection{Реализация:}
В качестве шлюза была написана простая программа чтения файла:
\lstinputlisting{../listings/suid.c}

Проверим функционирование программы в условиях запуска от владельцем:
\lstinputlisting{../listings/suid_owner}
Работает корректно.\\

Теперь разрешим программе исполняться не владельцем (пользователь lab2 состоит в группе ejiek):
\lstinputlisting{../listings/suid_lab2}
Из примера видно, что программа запускается, однако доступа к файлу у неё нет.\\

Разрешим расширение прав до прав владельца:
\lstinputlisting{../listings/suid_lab2_s}
Из примера видно, что через программу-шлюз пользователь не имеющий прав на чтение файла смог его прочесть.\\

Убирём права на исполнения файла, но оставим на расширение прав:
\lstinputlisting{../listings/suid_lab2_nx}
Из примера видно, что расширения прав недостаточно, нужно иметь и права на исполнение.\\

В данном эксперименте не рассматривался SGID, расширяющий права до прав группы.

\section{ df и аналоги} 
\subsection{Задание:} Применяя утилиту df и аналогичные ей по функциональности утилиты, а также информационные файлы типа fstab, mtab и т.п. получить информацию о файловых системах, возможных для монтирования, а также установленных на компьютере реально. 
\subsection{ Утилиты и файлы} Рассмотрим уже смонтированные ФС, для этого воспользуемся утилитой \textbf{df}
\lstinputlisting{../listings/df}
Флаг -Т добавляет в вывод утилиты тип ФС.

Теперь рассмотрим ФС с точки зрения физических устройств (вывод модифицирован в угоду LaTeX):
\lstinputlisting{../listings/lsblk}
Разделы не имеющие точки монтирование не смонтированы. А логический раздел(том в рамках LVM) bigbadpool находится на устройстве sdb, но является членом группы, созданной на sda, по этой причине там и отображается.

Рассмотрим ФС с точки зрения LVM:
\lstinputlisting{../listings/lvm}
Из приведённого видно, что существует одна группа (fedora), три логических раздела, развёрнутых на двух физических разделах.

Файл /etc/fstab содержит описательную информацию о доступных системе к монтированию файловых системах. Описывается способ монтирования или интегрирования в систему. Для программ файл доступен только для чтения и за исключением начальных значений формируется пользователем вручную.
\lstinputlisting{../listings/fstab}
Формат: Монтируемое устройство, точка монтирования, тип, опции, флаг резервного копирования, степень необходимости проверки.

Файл /etc/mtab содержит все смонтированные на данный момент ФС. При монтирование новой ФС в файл бдет добавлена соответствующая запись, а при удаление - удалена.
\lstinputlisting{../listings/mtab}

Список всех доступных для монтирования ФС можно узнать с помощью утилиты \textbf{blkid}
\lstinputlisting{../listings/blkid}
Флаг -k отвечает за вывод всех доступных для монтирования ФС и RAID массивов.
\subsection{ Дерево ФС} В основной таблице разделов устройств, в загрузочной части, предусмотрено место только под 4 раздела(физических):
\lstinputlisting{../listings/fdisk}
Однако такое ограничение обходится созданием расширенного раздела(занимает место одного физического раздела), указывающего на логические. Специального ограничения на количество логических разделов нет. Так же современные дистрибутивы предлагают использовать LVM, добавляющий уровень абстракции в работу с накопителями.\\

Т.е. из основной таблицы разметки ограничений на ширину дерева ФС не вытекает.

Попробуем наёти ограничение на глубину дерева:
\lstinputlisting{../listings/depth}
Из примера видно, что в корневую ФС было успешно смонтировано ещё 4 ФС (каждая следующая в предыдущую).

Так, на основе файла mtab можно построить дерево ФС.
\section{ File}  
\subsection{ Задание} Привести алгоритм её функционирования на основе информационной базы, размещение и полное имя которой указывается в описании утилиты в технической документации ОС (как правило, /usr/share/file/magic.*), а также содержимого заголовка файла, к которому применяется утилита. Определить, где находятся магические числа и иные характеристики, идентифицирующие тип файла, применительно к исполняемым файлам, а также файлам других типов. 
\subsection{ Утилита} Утилита \textbf{file} предназначена для определения типа файла. Утилита проверят каждый аргумент с целью классифицировать его. Всего существует три типа тестов, проводимых в таком порядке: тест ФС, magic тест, языковой тест.

\subsubsection{ Тест ФС}
Этот тип тестов полагается на возвращаемое значение системного вызова stat. Утилита проверяет является ли файл пустым или каким-либо специальным файлом.
\subsubsection{ magic тест}
Этот тип тестов полагается на сравнение данных в определённом месте файла с "магическим числом". В случае успеха выводится предопределённое сообщение. Информация для сравнения хранится в файле /usr/share/misc/magic.mgc, или файлах директории /usr/share/misc/magic.  В дополнение, если существуют \$HOME/.magic.mgc или \$HOME/.magic, то эти файлы будут иметь приоритет над системными. Формат magic файла:
\begin{itemize}
\item смещение
\item тип данных
\item значение для сравнения
\item сообщение
\end{itemize}

\subsubsection{ Языковой тест}
Если не пройден ни один magic тест, то файл проверяется на содержание текста. Сначала выявляется кодировка, после чего по ключевым словам совершается попытка определить язык, например, С по слову "struct". Если язык в текстовом файле выявить не получилось, то он определяется как дынные. Стоит учитывать, что это самый ненадёжный из приведённого перечня тестов. 

\subsection{ Эксперименты}
Рассмотрим пример работы:
\lstinputlisting{../listings/file_examp}

Теперь попробуем добавить свой тип файлов:
\lstinputlisting{../listings/file_own_magic}
Из эксперимента  видно, что утилита \textbf{file} работает как с компилированными файлами, так и с текстовыми в качестве  magic файлов. Утилита не может добавить файл для постоянного поиска в нём, а лишь в пределах одной команды.
\section{ Вывод}
В ходе выполнения данной работы были написаны скрипты для работы с файлами: поиск одного примера каждого типа файла, поиск всех символических ссылок на указанный файл, поиск всех жёстких ссылок на указанный файл. Изучены символьные и жёсткие ссылки и принципы из функционирования: символьная ссылка является отельным файлом, содержащим ссылку на исходный, а жёсткая ссылка ещё один указатель на ту же область памяти.

Была изучена утилита \textbf{find}, позволяющая по большому списку параметров искать файлы и выполнять над ними ранее описанные действия (вложенные команды).

Рассмотрены особенности ФС и утилиты \textbf{file} дампы обычных файлов, директорий и объектных файлов. Например эксперимент с изменением файла каталога в зависимости от содержимого.

Разобраны права доступа пользователей и системные файлы /etc/passwd и /etc/shadow, ответственные за атрибуты пользователей. Так же написана "программа-шлюз", расширяющая права пользователя до прав владельца. 

\newpage
\section{Дополнения}
\subsection{Влияния прав каталога на его файлы}
\subsubsection{Чтение}
Влияние - просмотр списка содержимого каталога
\lstinputlisting{../listings/dir_read}
Из листинга видно, что просмотр списка единственная доступная при чтение опция. Доступ к чтению/записи файлом и даже информации о них закрыт.\\

\subsubsection{Запись}
Влияние - создание, удаление и перемещение файлов.
\lstinputlisting{../listings/dir_write_fail}
Из приведённого выше листинга видно, что сам по себе бит записи бесполезен, так как мы не имеем доступа к файлам. Добавим бит чтения:
\lstinputlisting{../listings/dir_write_fail2} 
Ни информацию о файлах, ни доступ к ним опять не удалось получить. Проведём эксперимент от обратного: оставим биты чтения и исполнения, убрав бит записи.
\lstinputlisting{../listings/dir_write}


\subsubsection{Выполнение}
Влияние - вход в дирректорию и доступ к файлам внутри
\lstinputlisting{../listings/dir_execute}


\subsubsection{Stiky bit}
Влияние - защита дирректории и её содержимого от удаления всеми кроме владельца и root'а.
Данный пример рассмотрен с точки зрения члена группы
\lstinputlisting{../listings/dir_stiky_fail}
Данный пример рассмотрен с точки зрения "остальных"
\lstinputlisting{../listings/dir_stiky_fail2}
Повторим операции убрав stiky bit.
\lstinputlisting{../listings/dir_stiky}
Из листнингов видно, что данный бит защищает содержимое директорию и её содержимое от удаления не владельцем (группа и остальные). 

\subsection{Монтирование устройств хранения}
\subsubsection{Монтирование с помошью fstab}
Добавим в файл /etc/fstab строчку для монтирования внешнего устройства хранения
\lstinputlisting{../listings/usb_fstab}
Из листинга видно, что добавление строчки с инструкцией в fstab и монтирование всех указанных в нём 
ФС привело к монтированию ФС накопителя в директорию /mnt/usb (этого же результата можно добиться перезагрузкой ЭВМ).

\subsubsection{Мотирование с помощью mtab}
Файл /etc/mtab играет пассивную роль в монтирование ФС: при монтирование запись в файл заносится и при размонтирование удаляется. Появление и исчезновение вызванные монтирование рассмотрены в предыдущем пункте. Здесь попробуем добавить в mtab строчку из предыдущего пункта.
\lstinputlisting{../listings/usb_mtab}
Простым способом добавить строчку в mtab  не получилось. Подобное ограничение сделано для того, чтобы таблица была доступна только монтирующим утилитам и её целостность не нарушалась.

\subsubsection{Источники magic описаний}
Утилита \textbf{file} выполняет множество проверок, так что для ускорения работы используются скомпилированные файлы (/usr/share/misc/magic.mgc), но утилита воспринимает и не скомпилированные файлы и хранит исходный файл основного (/usr/share/misc/magic). Именно в исходном файле будем искать строки, по которым утилита распознает файлы:
\lstinputlisting{../listings/magic_tex}
Из листинга видно, что утилита произвела распознавание по имеющимся в основном magic файле описаниям. И после этого был проведён языковой тест, модифицировавший оригинальный вывод описания.\\

Попробуем указать свой файл описаний:
\lstinputlisting{../listings/own_magic}
Из листинга видно, что при подключение своего файла с описание пропадает языковой тест и выводится только сообщение нашего из описания. Разрешить языковой тест можно, изменив тип дынных на подразумевающий языковой тест:
\lstinputlisting{../listings/magic_lang}
А для ускорения работы утилиты можно скомпилировать наш файл описания:
\lstinputlisting{../listings/magic_compile}
Из листинга видно, что компиляция производится самой утилитой с флагом \textbf{-C} и порождает файл с расширение .mgc .

\end{document}

