Лабораторная работа 1 по курсу "Транслирующие 
системы" - программирование лексического разбора на 
языке C
Редакция от 16.02.2011
Введение
Образец лексического анализатора приведен в модуле scanner (состоит из двух файлов: 
scanner.c и scanner.h). Модуль test_scanner.c содержит функцию main, в ней запрограммирован 
циклический вызов функции yylex (реализована в модуле scanner). Базовый вариант модуля 
scanner, вкупе с тестовой программой, находится в папке _basic_.
Функция yylex построена на основе программного цикла с ветвлением по значению 
переменной состояния. Преимущества такого подхода применительно к задаче лексического 
анализа обсуждаются, с примерами, в статье "Автоматное программирование" (см. папку Intro).
1. Функции в составе модуля scaner
В состав модуля входят функции для лексического разбора, а также ряд вспомогательных 
функций для синтаксического разбора, в основном, для контроля ошибок.
Ниже перечислены функции для лексического разбора и вывода результатов; они 
используются в тестовой программе.
*	int yylex (void) - читает литеры из входного потока и, пропуская вначале разделители, 
выявляет числа (код лексемы - NUM) и идентификаторы (код лексемы - ID); функция 
возвращает одиночные литеры, не являющиеся буквами или числами, как литералы (код 
лексемы представляет собой ASCII-код литеры); лексема с кодом 0 означает конец входного 
потока.
*	int prn_token (int) - выводит в stderr код указанной лексемы; видимые литералы печатаются 
в символьном формате, а невидимые - в формате десятичного числа.
Замечание:
Лексический разбор выполняется, в основном, в локальной функции __yylex, которая 
вызывается из yylex. Исправления при выполнении задания следует делать в __yylex.
2. Глобальные данные модуля scaner
Модуль scaner предоставляет следующие глобальные данные:
*	yytext - массив литер, в котором формируется (накапливается) текст очередной лексемы 
при работе функции yylex; строка в yytext завершается 0-литерой, т.о. yytext можно 
выводить функцией printf и обрабатывать строковыми функциями из библиотеки C.
*	yyleng - длина строки, сформированной в yytext.
*	yylval - семантическое значение лексемы, формируется в yylex при получении числа 
(лексемы NUM).
Эти объекты приведены в заголовочном файле scaner.h. Также там определены коды лексем 
NUM и ID. Коды лексем должны быть за пределами диапазона литералов (1..255). Ноль также 
зарезервирован - ля признака конца ввода.
Примечание:
Названия всех глобальных объектов модуля scanner и определения этих объектов следуют 
соглашениям, принятым для стандартной утилиты lex.
3. Реализация локальной функции __yylex
Остановимся на реализации функции _yylex, поскольку ее придется менять для расширения 
функциональности сканера.
Функция работает в бесконечном цикле, начиная с состояния state = 0. На каждой итерации 
считываем литеру из входного потока, заменяя признак EOF (-1) на ноль. (Существенно, что 
литера определена не как char, а как int, поскольку константа EOF находится за пределами 
диапазона char.)
В исходном состоянии (state = 0) пропускаем литеру, если это разделитель. Как только в 
состоянии 0 встретится нечто иное, выясняем, началом чего оно является. Если получена 
буква, то это начало идентификатора, и переходим в состояние 1. Если цифра, то это начало 
числа, и переходим в состояние 2. Если не буква и не цифра, то считаем это литералом 
(частный случай - 0, признак конца ввода) и сразу возвращаем ASCII-код, записав его также в 
yytext.
В состояниях 1 или 2 остаемся, накапливая литеры в yytext, пока не получим нечто, не 
относящееся соответственно к идентификатору или числу. Эту литеру возвращаем во входной 
поток и выходим из функции с кодом лексемы - NUM или ID. Если накапливали число, то 
перед выходом из функции записываем его значение в yylval.
4. Задачи
Во всех задачах требуется дополнить сканер из примера, сохранив его изначальную 
способность распознавать идентификаторы и десятичные числа, что усложняет задание.
	Внимание: 
	Решения демонстрировать на заранее подготовленном тестовом наборе файлов с входными 
данными. Эти тесты должны проверять  не только новую функцию, согласно заданию, но 
также и исходные возможности сканера. 
Варианты:
1.	16-ричные константы в стиле С, например, 0x1fa2. Внимание: ввод "0x=" распадается на 
три лексемы: число 0, идентификатор x и знак равенства, а ввод 01fe - на число 01 и 
идентификатор fe. 
2.	16-ричные константы в стиле a86, сразу в трех вариантах (все в одном сканере). Примеры 
вариантов: 01fa2, 1fh, 1fxh. Внимание: ввод "1fz" распадается на две лексемы: число 1 и 
идентификатор fz. 
3.	16-ричные константы в стиле Modula-2, сразу в двух вариантах (все в одном сканере). 
Пример вариантов: 0fah, 1fah. Внимание: ввод "1fz" распадается на две лексемы: число 1 и 
идентификатор fz.
4.	16-ричные, 8-ричные и 2-ичные константы в стиле Step-7, все в одном сканере. Примеры: 
16#fa, 8#177, 2#10101. Внимание: ввод "2#3" распадается на три лексемы: число 2, знак # и 
число 3. Аналогично для 16-ричных и 8-ричных.
5.	Числа с фиксированной точкой без знака, с обязательной целой и дробной частями. 
Пример: 1.234. Внимание: ввод "1.x" или "x.23" распадается на три лексемы: число, точка, 
идентификатор.
6.	Распознавать в сканере комментарии в стиле C, то есть /* ... **/. Пропускать их 
содержимое. Предусмотреть незавершенные комментарии, т.е. когда ввод заканчивается до 
закрывающей скобки "*/". 
7.	Распознавать в сканере вложенные комментарии в стиле Turbo-Pascal, то есть {... {...} ...}. 
Пропускать их содержимое. Предусмотреть незавершенные комментарии, когда ввод 
заканчивается до появления парной правой фигурной скобки.
8.	Разработать сканер, который распознает в тексте не идентификаторы или цифры, а целые 
предложения.
9.	Добавить в сканер проверку на переполнение yytext, а также распознавание 
дополнительных лексем: многоточие (...) и присвоение в стиле Pascal (:=). Внимание: ввод 
"..:x" распадается на пару точек, двоеточие и идентификатор x. 
10.	Распознавать в сканере комментарии в стиле a86, в двух вариантах (сначала в двух 
отдельных версиях сканера, затем все вместе). Первый вариант: комментарий от литеры ";" 
до конца строки. Второй вариант: от слова COMMENT до второго экземпляра непробельной 
литеры, примыкающей к этому слову (например, "COMMENT ~ ... ~").
11.	Десятичные константы со знаком, включая "длинные" в стиле Step-7. Примеры: -1, 1, +99, 
L#-1, L#14. Значение длинной -1 (L#-1) д.б. представлено 32 битами, короткой (-1) - 16 
битами. Внимание: ввод "L#f3" распадается на три лексемы: идентификатор L, знак # и 
идентификатов f3.
12.	16-ричные константы в стиле Step7 в размерностьях: байт, слово, двойное слово. Примеры: 
B#16#ff, W#16#1fe, DW#16#7fffffff. Внимание: ввод B#16#00f05 должен либо распадаться 
на два числа - 16-ричное f0 и  десятичное 5, либо считаться ошибкой (переполнение, f05 - 
вне диапазона байта).
13.	Десятичные константы со знаком, включая "длинные" в стиле C. Примеры: -1, 1, +99, -1L, 
14L. Значение длинной -1 (-1L) д.б. представлено 32 битами, короткой (-1) - 16 битами.
14.	Идентификаторы, начинающиеся с буквы, за которой следует произвольное кол-во букв, 
цифр, символов подчеркивания. Это взамен буквенных идентификаторов из примера. 
Дополнительно, распознавать локальные имена в стиле a86: буква, за которой следует не 
менее одной цифры, например, m12, z2.
15.	Латинские числа.
Замечание:
В задачах с 16-ричными константами для распознавания 16-ричных цифр используйте макрос 
isxdigit. В задачах с 16-ричными, 8-ричными или двоичными константами для получения 
числовых значений используйте функцию strtol, а с действительными числами - функцию 
strtod. 


5. Примеры модернизации модуля scanner
В папке signed_num приведен пример модернизации сканера: в __yylex добавлено 
распознавание целых чисел со знаком. Теперь литера '-' с примыкающими к ней цифрами 
распознается как одно целое. Отдельно стоящая литера '-' по-прежнему распознается как 
литерал, а последовательность цифр без предшествующего знака '-' - как лексема NUM.
Этот пример слишком простой, решить вышеприведенные задачи по аналогии не получится. 
Решение, отнести ли литеру '-' к числу или считать знаком препинания, принимается в начале 
разбора, и оно окончательное. Сложнее разбирать числа в разных системах счисления и/или в 
разной нотации, т.к. придется по ходу разбора уточнять первоначальное решение  и даже его 
пересматривать, возвращая прочитанные последовательности во входной поток (откат).
Предположим, нужно распознавать (наряду с десятичными числами) двоичные константы в 
нотации ассемблера a86. Пример константы: 0101xb. Можно попытаться решить эту задачу, не 
вводя дополнительных состояний: усложнить логику __yylex в состоянии state = 1 (разбор 
чисел). Попытка решения:
По первой литере (0 или 1) выбрав state = 1 (разбор десятичных чисел), читаем до литеры, 
отличной от 0-9. Если это не 'x', принятую последовательность считаем десятичным числом, 
последнюю литеру возвращаем на вход - все как обычно. Если же пришло 'x', считываем еще 
одну литеру. Если после 'x' прочитано 'b', то цифры в накопленной последовательности 
считаем числом двоичным.
Но если после 'x' получено не 'b', то принятая последовательность уже не представляет 
двоичное число. Скорее десятичное, не включая 'x'; само же 'x' - что-то другое: начало 
следующей лексемы. В этом случае делаем откат на две литеры ('x' и 'b'). Оставшаяся часть 
принятой последовательности - десятичное число, а все, что после, будет распознано 
(начиная с литеры x) при следующем вызове функции scanner. (Например, ввод 0101x= 
распадется в итоге на десятичное число 0101, идентификатор x и знак равенства.)
В чем ошибка? Решите эту задачу, введя два дополнительных состояния: одно для чтения 
двоичного числа, до 'x', и еще одно для чтения завершающей литеры 'b'.
	Содержание отчета
	В отчет входит:
	Помимо индивидуального задания, разбор двоичного числа в стиле a86 (см. п.5).
	Для каждого из этих двух заданий следует привести:
1.	Условия задачи.
2.	Тестовые наборы входных данных и соответствующие выходные данные. 
3.	Фрагменты программного кода, измененные при модернизации, с пояснениями.

 
 
 
 
2

