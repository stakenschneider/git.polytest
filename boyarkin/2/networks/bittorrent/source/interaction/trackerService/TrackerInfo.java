package interaction.trackerService;

import interaction.torrentParser.bencode.*;
import com.sun.istack.internal.NotNull;
import com.sun.istack.internal.Nullable;
import gui.TrackerTableData;
import interaction.fileAnalyser.FileAnalyzer;
import interaction.torrentParser.TorrentParser;
import javafx.application.Platform;
import javafx.collections.ObservableList;
import org.apache.commons.codec.net.URLCodec;
import util.Constants;
import util.Log;
import util.SHA1;
import util.Util;

import java.io.IOException;
import java.io.PushbackInputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;

/**
 * Class, which makes HTTP GET requests to tracker with special interval.
 * Supports 'scrape' convention.
 * @author Boyarkin Nikita.
 */
public class TrackerInfo implements OnePeerChangeable {
    /**
     * Minimum interval of requests to 'scrape' server in seconds.
     */
    public static long TRACKER_MINIMAL_SCRAPE_INTERVAL = 2 * 60;

    /**
     * Minimum interval of requests to 'announce' server in seconds.
     */
    public static long TRACKER_MINIMAL_ANNOUNCE_INTERVAL = 2 * 60;

    /**
     * Set with information about all peers (updatable).
     * @see Peer
     */
    private @NotNull final Set<Peer> mPeers;

    /** Callback, that calls when set of peers changes. */
    private @Nullable OnePeerChangeable mOnePeerChangeable;

    /**
     * Data model for current tracker.
     * @see TrackerTableData
     */
    private @NotNull TrackerTableData mTrackerTableData;

    /** Information about file partitions (for monitoring bytes left). */
    private @NotNull final FileAnalyzer mFileAnalyzer;

    /*
     *  - - - Transmittable data for HTTP GET requests. - - -
     *  Defined into class constructor, but some fields may be update after HTTP GET requests.
     */

    /** The port number that the client is listening on (not updatable). */
    private @NotNull final int mPeerPort;

    /** Sha-1 hash of 'info' dictionary (from the .torrent file). */
    private @NotNull final SHA1 mInfoHash;

    /** Sha-1 hash of 'info' dictionary in url encoded format (not updatable). */
    private @NotNull final String mTransmittableInfoHash;

    /** Peer identifier (a unique ID for the client, generated by the client at startup) in url encoded format (not updatable).  */
    private @NotNull final String mTransmittablePeerId;

    /**
     * An additional identification that is not shared with any other peers.
     * It is intended to allow a client to prove their identity should their IP address change (not updatable).
     */
    private @NotNull final String mKey;

    /**
     *  If specified, must be one of 'started', 'completed', 'stopped' or null (updatable).
     *  'started' - First request to the tracker.
     *  null - Periodically requests to the server (but not first).
     *  'stopped' - When program closes.
     *  'completed' - When uploading of all files are completed.
     */
    private @Nullable String mEvent;

    /** The number of bytes this client still has to download in base ten ASCII (updatable). */
    private @NotNull long mCountOfBytesLeft;

    /** TODO (not realized) The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII. */
    private @NotNull long mCountOfBytesDownloaded;

    /** TODO (not realized) The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII. */
    private @NotNull long mCountOfBytesUploaded;

    /** Setting this to 1 indicates that the client accepts a compact response (not updatable, always 1). */
    private @NotNull final int mCompact;

    /** Number of peers that the client would like to receive from the tracker. This value is permitted to be zero (not updatable, always 200). */
    private @NotNull final int mNumWant;

    /*
     *  - - - Response data from HTTP GET requests to 'scrape' server (if it exists). - - -
     *  Updating with mScrapeRefreshingInterval interval.
     */

    /**
     * The interval with which 'scrape' data updates (in seconds).
     * If !mScrapeSupported -> mScrapeRefreshingInterval = null.
     * If !mScrapeAvailable -> mScrapeRefreshingInterval = null.
     * Default value is Constants.TRACKER_MINIMAL_SCRAPE_INTERVAL (if mScrapeSupported and mScrapeAvailable).
     * @see Constants
     */
    private @Nullable Long mScrapeRefreshingInterval;

    /**
     * Timer object, which refreshes 'scrape' data with mScrapeRefreshingInterval interval.
     * @see ScrapeRefreshingRunnable
     */
    private @NotNull Timer mScrapeRefreshingTimer;

    /** True if tracker supports 'scrape' convention (not updatable). */
    private @NotNull final boolean mScrapeSupported;

    /** True if response on first HTTP GET request has been received (not updatable). */
    private @NotNull boolean mScrapeAvailable;

    /** Url to 'scrape' server (null if tracker don't supports 'scrape' convention) (not updatable). */
    private @Nullable final URL mScrapeUrl;

    /** Number of peers with the entire file (updatable). */
    private @NotNull long mScrapeSeedersCount;

    /** Number of non-seeder peers (updatable). */
    private @NotNull long mScrapeLeechersCount;

    /** Total number of times the tracker has registered a completion (updatable). */
    private @NotNull long mScrapeDownloadedCount;

    /** The torrent's internal name, as specified by the "name" file in the info section of the .torrent file (updatable). */
    private @Nullable String mScrapeFileName;

    /** Human-readable error message as to why the request failed (updatable). */
    private @Nullable String mScrapeFailureReason;

    /*
     *  - - - Response data from HTTP GET requests to 'announce' server. - - -
     *  Updating with mAnnounceRefreshingInterval interval.
     */

    /**
     * The interval with which 'announce' data updates (in seconds).
     * Default value is Constants.TRACKER_MINIMAL_ANNOUNCE_INTERVAL (if mAnnounceAvailable).
     * @see Constants
     */
    private @NotNull Long mAnnounceRefreshingInterval;

    /**
     * Timer object, which refreshes 'announce' data with mAnnounceRefreshingInterval interval.
     * @see AnnounceRefreshingRunnable
     */
    private @NotNull Timer mAnnounceRefreshingTimer;

    /** True if response on first HTTP GET request has been received (not updatable). */
    private @NotNull boolean mAnnounceAvailable;

    /** Url to 'announce' server (not updatable). */
    private @NotNull URL mAnnounceUrl;

    /** Human-readable error message as to why the request failed (updatable). */
    private @Nullable String mAnnounceFailureReason;

    /** Similar to failure reason, but the response still gets processed normally (updatable). */
    private @Nullable String mAnnounceWarningMessage;

    /** A string that the client should send back on its next announcements. If absent and a previous announce sent a tracker id, do not discard the old value (updatable). */
    private @Nullable String mAnnounceTrackerId;

    /** Number of peers with the entire file (updatable). */
    private @NotNull long mAnnounceSeedersCount;

    /** Number of non-seeder peers (updatable). */
    private @NotNull long mAnnounceLeechersCount;

    /**
     * Creates TrackerInfo object.
     * Sets the transmittable data for HTTP GET requests.
     * @param announceUrl - Url to the tracker 'announce' server.
     * @param torrentParser - TorrentParser object.
     * @see TorrentParser
     * @param fileAnalyzer - FileAnalyzer object.
     * @see FileAnalyzer
     * @param peerId - Last 12 bytes of peer identifier.
     * @param key - An additional identification that is not shared with any other peers.
     * @param peerPort - The port number that the client is listening on.
     */
    public TrackerInfo(@NotNull final URL announceUrl, @NotNull final TorrentParser torrentParser, @NotNull final FileAnalyzer fileAnalyzer,
                       @NotNull final byte[] peerId, @NotNull final String key, @NotNull final int peerPort) {
        // Set the transmittable data.
        mFileAnalyzer = fileAnalyzer;
        mInfoHash = torrentParser.getInfoHash();
        mTransmittableInfoHash = new String((new URLCodec()).encode(mInfoHash.toBytes()));
        mPeerPort = peerPort;
        mTransmittablePeerId = Constants.TRACKER_PEER_ID_PREFIX + new String((new URLCodec()).encode(peerId));
        mKey = key;
        mEvent = "started";
        mCountOfBytesLeft = 0;
        mCountOfBytesDownloaded = 0;
        mCountOfBytesUploaded = 0;
        mCompact = 1;
        mNumWant = 200;

        // Try to get 'scrape' server url.
        mScrapeUrl = getScrapeUrl(announceUrl);
        mScrapeSupported = (mScrapeUrl != null);

        // Set 'announce' server url.
        mAnnounceUrl = announceUrl;
        mAnnounceTrackerId = null;

        mPeers = new HashSet<>();
    }

    /**
     * Starts periodically requests to 'scrape' (if supports) and 'announce' servers.
     * @param trackersList - TrackerTableView list.
     * @see gui.Controller
     * @param onePeerChangeable - OnePeerChangeable callback (can be null).
     * @throws InterruptedException If thread is interrupted.
     * @throws IOException If 'announce' server is unreachable.
     */
    public void startTracker(@NotNull final ObservableList<TrackerTableData> trackersList, @Nullable final OnePeerChangeable onePeerChangeable) throws InterruptedException, IOException {
        mOnePeerChangeable = onePeerChangeable;

        // Create new row in 'tracker' table.
        mTrackerTableData = new TrackerTableData(-1, mAnnounceUrl.toString(), "", 0, 0, 0);
        Platform.runLater(() -> trackersList.add(mTrackerTableData));

        if(mScrapeSupported) {
            Util.checkInterrupted(null);

            // Create first request to the 'scrape' server (if supports).
            refreshScrapeTrackerData();
        }

        Util.checkInterrupted(this::stopTimers);

        // Create first request to the 'announce' server.
        refreshAnnounceTrackerData();

        // Throw exception if 'announce' server is unreachable.
        if(!mAnnounceAvailable || mAnnounceRefreshingInterval == null)
            throw new IOException();

        // Next requests are regular.
        mEvent = null;

        // Start timer with mScrapeRefreshingInterval for 'scrape' server.
        if(mScrapeSupported && mScrapeAvailable && mScrapeRefreshingInterval != null) {
            mScrapeRefreshingTimer = new Timer();
            mScrapeRefreshingTimer.scheduleAtFixedRate(new ScrapeRefreshingRunnable(), mScrapeRefreshingInterval * 1000, mScrapeRefreshingInterval * 1000);

            Log.i("Scrape '" + mScrapeUrl.toString() + "' timer task is started with interval " + mScrapeRefreshingInterval + " seconds.");
        }

        // Start timer with mAnnounceRefreshingInterval for 'announce' server.
        mAnnounceRefreshingTimer = new Timer();
        mAnnounceRefreshingTimer.scheduleAtFixedRate(new AnnounceRefreshingRunnable(), mAnnounceRefreshingInterval * 1000, mAnnounceRefreshingInterval * 1000);

        Log.i("Announce '" + mAnnounceUrl.toString() + "' timer task is started with interval " + mAnnounceRefreshingInterval + " seconds.");
        Util.checkInterrupted(this::stopTimers);
    }

    /**
     * Gets 'scrape' server url from 'announce' server url (if it's possible).
     * @param announceUrl - Url to 'announce' server.
     * @return Returns 'scrape' server url or null if 'scrape' convention don't supported.
     */
    private @Nullable URL getScrapeUrl(@NotNull final URL announceUrl) {
        final String announcePath = announceUrl.getPath();
        final String fileName = announcePath.substring(announcePath.lastIndexOf("/") + 1);

        if(fileName.equals("announce") || fileName.equals("announce.php")) {
            String resultPath = announcePath.substring(0, announcePath.lastIndexOf("/") + 1);
            resultPath += fileName.replace("announce", "scrape");

            try {
                return new URL(announceUrl.getProtocol(), announceUrl.getHost(), announceUrl.getPort(), resultPath);
            }
            catch(final MalformedURLException exception) {
                return null;
            }
        }
        else
            return null;
    }

    /**
     * Makes request to 'scrape' server and sets 'scrape' response data.
     */
    public synchronized void refreshScrapeTrackerData() {
        PushbackInputStream inputStream = null;
        try {
            // Create GET query.
            final String query = "info_hash=" + mTransmittableInfoHash;

            Log.d("Try to make HTTP GET request to scrape server '" + mScrapeUrl.toString() + "' with parameters: '" + query + "'.");

            // Try to make HTTP GET request to 'scrape' server.
            final HttpURLConnection connection = (HttpURLConnection) (new URL(mScrapeUrl.toString() + "?" + query)).openConnection();
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Accept-Charset", "UTF-8");
            connection.setRequestProperty("User-Agent", "Mozilla/5.0");

            // Exit function if HTTP response isn't HTTP_OK.
            final int responseCode = connection.getResponseCode();
            if(responseCode != HttpURLConnection.HTTP_OK) {
                Log.e("Request failed with code '" + responseCode + "' for '" + mScrapeUrl.toString() + "' scrape server.");
                return;
            }

            // Create new input stream from HTTP GET response.
            inputStream = new PushbackInputStream(connection.getInputStream());

            // Try to parse response (cuz it into interaction.torrentParser.bencode format).
            BencodeObject bencodeObject = Bencode.parseBencode(inputStream);
            if(!(bencodeObject instanceof BencodeMap)) {
                Log.e("Impossible to parse response from scrape server '" + mScrapeUrl.toString() + "'.");
                return;
            }

            mScrapeAvailable = true;

            // Set refreshing interval.
            if(mScrapeRefreshingInterval == null || mScrapeRefreshingInterval < TRACKER_MINIMAL_SCRAPE_INTERVAL)
                mScrapeRefreshingInterval = TRACKER_MINIMAL_SCRAPE_INTERVAL;

            final BencodeMap rootMap = (BencodeMap) bencodeObject;

            // Set mScrapeFailureReason variable if 'failure reason' field exists.
            bencodeObject = rootMap.get(new BencodeString("failure reason"));
            mScrapeFailureReason = (bencodeObject instanceof BencodeString) ? bencodeObject.toString() : null;

            // Try to parse 'files' dictionary.
            bencodeObject = rootMap.get(new BencodeString("files"));
            if(bencodeObject instanceof BencodeMap) {
                final BencodeMap filesMap = (BencodeMap) bencodeObject;
                for(final Map.Entry<BencodeString, BencodeObject> currentFile: filesMap.entrySet()) {
                    final byte[] keyBytes = currentFile.getKey().getBytes();
                    if(keyBytes.length == SHA1.LENGTH && currentFile.getValue() instanceof BencodeMap && mInfoHash.equals(new SHA1(keyBytes))) {
                        final BencodeMap stateMap = (BencodeMap) currentFile.getValue();

                        // Set mScrapeSeedersCount variable if 'complete' field exists.
                        bencodeObject = stateMap.get(new BencodeString("complete"));
                        if(bencodeObject instanceof BencodeLong)
                            mScrapeSeedersCount = ((BencodeLong) bencodeObject).getLong();

                        // Set mScrapeLeechersCount variable if 'incomplete' field exists.
                        bencodeObject = stateMap.get(new BencodeString("incomplete"));
                        if(bencodeObject instanceof BencodeLong)
                            mScrapeLeechersCount = ((BencodeLong) bencodeObject).getLong();

                        // Set mScrapeDownloadedCount variable if 'downloaded' field exists.
                        bencodeObject = stateMap.get(new BencodeString("downloaded"));
                        if(bencodeObject instanceof BencodeLong)
                            mScrapeDownloadedCount = ((BencodeLong) bencodeObject).getLong();

                        // Set mScrapeFileName variable if 'name' field exists.
                        bencodeObject = stateMap.get(new BencodeString("name"));
                        if(bencodeObject instanceof BencodeString)
                            mScrapeFileName = bencodeObject.toString();
                    }
                }
            }

            // Try to parse 'flags' dictionary.
            bencodeObject = rootMap.get(new BencodeString("flags"));
            if(bencodeObject instanceof BencodeMap) {
                final BencodeMap flagsMap = (BencodeMap) bencodeObject;

                // Set mScrapeRefreshingInterval value if 'min_request_interval' field exists.
                bencodeObject = flagsMap.get(new BencodeString("min_request_interval"));
                if(bencodeObject instanceof BencodeLong)
                    mScrapeRefreshingInterval = Long.max(((BencodeLong) bencodeObject).getLong(), mScrapeRefreshingInterval);
            }

            Log.d("Response from '" + mScrapeUrl.toString() + "' scrape server has been successfully parsed.");
            Log.d("Scrape data: interval - " + mScrapeRefreshingInterval + " seconds; failure reason - '" + mScrapeFailureReason +
                    "'; seeders count - " + mScrapeSeedersCount + "; leechers count - " + mScrapeLeechersCount +
                    "; total downloaded count - " + mScrapeDownloadedCount + "; file name - '" + mScrapeFileName + "'.");
        }
        catch(final IOException | RuntimeException exception) { }
        finally {
            // Release resources.
            try {
                if(inputStream != null)
                    inputStream.close();
            }
            catch(final IOException exception) { }
        }
    }

    /**
     * Makes request to 'announce' server, sets 'announce' response data and updates table fields.
     */
    public synchronized void refreshAnnounceTrackerData() {
        PushbackInputStream inputStream = null;
        try {
            if(mEvent == null || mEvent.equals("started")) {
                mCountOfBytesLeft = mFileAnalyzer.getAllBytesLeft();

                if(mEvent == null && mCountOfBytesLeft == 0)
                    mEvent = "completed";
            }

            // Create GET query.
            final String query = "info_hash=" + mTransmittableInfoHash + "&peer_id=" + mTransmittablePeerId + "&port=" + mPeerPort +
                                 "&uploaded=" + mCountOfBytesUploaded + "&downloaded=" + mCountOfBytesDownloaded +
                                 "&left=" + mCountOfBytesLeft + "&corrupt=0" + "&key=" + mKey + ((mEvent != null) ? "&event=" + mEvent : "") +
                                 "&numwant=" + mNumWant + "&compact=" + mCompact + "&no_peer_id=1" + ((mAnnounceTrackerId != null) ? "&trackerid=" + mAnnounceTrackerId : "");

            Log.d("Try to make HTTP GET request to tracker '" + mAnnounceUrl.toString() + "' with parameters: '" + query + "'.");

            // Try to make HTTP GET request to 'announce' server.
            final HttpURLConnection connection = (HttpURLConnection) (new URL(mAnnounceUrl.toString() + "?" + query)).openConnection();
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Accept-Charset", "UTF-8");
            connection.setRequestProperty("User-Agent", "Mozilla/5.0");

            // Exit function if HTTP response isn't HTTP_OK.
            final int responseCode = connection.getResponseCode();

            if(mEvent != null && !mEvent.equals("started")) {
                if(mAnnounceRefreshingTimer != null) {
                    mAnnounceRefreshingTimer.cancel();
                    mAnnounceRefreshingTimer.purge();
                }

                Log.i("Stopped 'announce' timer task for '" + mAnnounceUrl.toString() + "' tracker.");
                mTrackerTableData.setState("Disconnected");
                return;
            }

            if(responseCode != HttpURLConnection.HTTP_OK) {
                Log.e("Request failed with code '" + responseCode + "' for '" + mAnnounceUrl.toString() + "' tracker.");
                mTrackerTableData.setState("Disconnected");
                return;
            }

            // Create new input stream from HTTP GET response.
            inputStream = new PushbackInputStream(connection.getInputStream());

            // Try to parse response (cuz it into interaction.torrentParser.bencode format).
            BencodeObject bencodeObject = Bencode.parseBencode(inputStream);
            if(!(bencodeObject instanceof BencodeMap)) {
                Log.e("Impossible to parse response from tracker '" + mAnnounceUrl.toString() + "'.");
                return;
            }

            mAnnounceAvailable = true;
            mTrackerTableData.setState("Connected");

            // Set refreshing interval.
            if(mAnnounceRefreshingInterval == null || mAnnounceRefreshingInterval < TRACKER_MINIMAL_ANNOUNCE_INTERVAL)
                mAnnounceRefreshingInterval = TRACKER_MINIMAL_ANNOUNCE_INTERVAL;

            final BencodeMap rootMap = (BencodeMap) bencodeObject;

            // Set mAnnounceFailureReason variable if 'failure reason' field exists.
            bencodeObject = rootMap.get(new BencodeString("failure reason"));
            mAnnounceFailureReason = (bencodeObject instanceof BencodeString) ? bencodeObject.toString() : null;

            // Set mAnnounceWarningMessage variable if 'warning message' field exists.
            bencodeObject = rootMap.get(new BencodeString("warning message"));
            mAnnounceWarningMessage = (bencodeObject instanceof BencodeString) ? bencodeObject.toString() : null;

            // Set mAnnounceRefreshingInterval variable if 'interval' field exists.
            bencodeObject = rootMap.get(new BencodeString("interval"));
            if(bencodeObject instanceof BencodeLong)
                mAnnounceRefreshingInterval = Long.max(((BencodeLong) bencodeObject).getLong(), mAnnounceRefreshingInterval);

            // Set mAnnounceRefreshingInterval variable if 'min interval' field exists.
            bencodeObject = rootMap.get(new BencodeString("min interval"));
            if(bencodeObject instanceof BencodeLong)
                mAnnounceRefreshingInterval = Long.max(((BencodeLong) bencodeObject).getLong(), mAnnounceRefreshingInterval);

            // Set mAnnounceTrackerId variable if 'tracker id' field exists.
            bencodeObject = rootMap.get(new BencodeString("tracker id"));
            mAnnounceTrackerId = (bencodeObject instanceof BencodeString) ? bencodeObject.toString() : null;

            // Set mAnnounceSeedersCount variable if 'complete' field exists.
            bencodeObject = rootMap.get(new BencodeString("complete"));
            if(bencodeObject instanceof BencodeLong) {
                mAnnounceSeedersCount = ((BencodeLong) bencodeObject).getLong();
                mTrackerTableData.setSeeders((int) mAnnounceSeedersCount);
            }

            // Set mAnnounceLeechersCount variable if 'incomplete' field exists.
            bencodeObject = rootMap.get(new BencodeString("incomplete"));
            if(bencodeObject instanceof BencodeLong) {
                mAnnounceLeechersCount = ((BencodeLong) bencodeObject).getLong();
                mTrackerTableData.setLeechers((int) mAnnounceLeechersCount);
            }

            /*
                Try to parse 'peers' dictionary.
                In compact mode information about every peer contains 6 bytes (first 4 bytes for IP address, last 2 bytes for port)
            */
            bencodeObject = rootMap.get(new BencodeString("peers"));
            if(bencodeObject instanceof BencodeString) {
                final BencodeString peers = (BencodeString) bencodeObject;

                boolean changed = false;

                final byte[] bytes = peers.getBytes();
                for(int byteIndex = 0; byteIndex + 5 < bytes.length; byteIndex += 6) {
                    StringBuilder ip = new StringBuilder();

                    // Parse first 4 bytes of IP address.
                    int integerByteValue = bytes[byteIndex] & 0xFF;
                    ip.append(Integer.toString(integerByteValue)).append(".");

                    integerByteValue = bytes[byteIndex + 1] & 0xFF;
                    ip.append(Integer.toString(integerByteValue)).append(".");

                    integerByteValue = bytes[byteIndex + 2] & 0xFF;
                    ip.append(Integer.toString(integerByteValue)).append(".");

                    integerByteValue = bytes[byteIndex + 3] & 0xFF;
                    ip.append(Integer.toString(integerByteValue));

                    // Parse last 2 bytes of port.
                    final int port = ((int) bytes[byteIndex + 4] & 0xFF) * 0x100 + ((int) bytes[byteIndex + 5] & 0xFF);
                    changed = mPeers.add(new Peer(ip.toString(), port)) || changed;
                }

                if(changed)
                    onOnePeerChanged(this, mPeers);
            }

            Log.d("Response from '" + mAnnounceUrl.toString() + "' tracker has been successfully parsed.");
            Log.d("Announce data: interval - " + mAnnounceRefreshingInterval + " seconds; failure reason - '" + mAnnounceFailureReason +
                    "'; warning message - '" + mAnnounceWarningMessage + "'; tracker id - '" + mAnnounceTrackerId + "'; seeders count - " + mAnnounceSeedersCount +
                    "; leechers count - " + mAnnounceLeechersCount + "; peers count - " + mPeers.size() + ".");
        }
        catch(final IOException | RuntimeException exception) { }
        finally {
            // Release resources.
            try {
                if(inputStream != null)
                    inputStream.close();
            }
            catch(final IOException exception) { }
        }
    }

    /**
     * Stops 'scrape' and 'announce' servers timers.
     * After this, sends request with 'completed' or 'stop' event state to server.
     */
    public void stopTimers() {
        mOnePeerChangeable = null;

        // Stop 'scrape' timer.
        if(mScrapeRefreshingTimer != null) {
            mScrapeRefreshingTimer.cancel();
            mScrapeRefreshingTimer.purge();

            Log.i("Scrape '" + mScrapeUrl.toString() + "' timer tasks is stopped.");
        }

        // Stop 'announce' timer.
        if(mAnnounceRefreshingTimer != null) {
            mAnnounceRefreshingTimer.cancel();
            mAnnounceRefreshingTimer.purge();

            Log.i("Announce '" + mAnnounceUrl.toString() + "' timer tasks is stopped.");

            // Send last message to the tracker.
            if(mAnnounceAvailable) {
                mEvent = ((mCountOfBytesLeft = mFileAnalyzer.getAllBytesLeft()) == 0) ? "completed" : "stopped";
                refreshAnnounceTrackerData();
            }
        }
    }

    /**
     * Callback function.
     * @param trackerInfo - The TrackerInfo object on which this function was called.
     * @param peers - Unique set of peers into TrackerInfo object.
     */
    @Override
    public void onOnePeerChanged(@NotNull final TrackerInfo trackerInfo, @NotNull final Set<Peer> peers) {
        Log.d("Unique set of peers for '" + trackerInfo.mAnnounceUrl.toString() +  "' tracker has been changed.");

        mTrackerTableData.setPeers(peers.size());

        if(mOnePeerChangeable != null)
            mOnePeerChangeable.onOnePeerChanged(this, mPeers);
    }

    /**
     * Getters for all response data.
     */

    public @NotNull Set<Peer> getPeers() {
        return Collections.unmodifiableSet(mPeers);
    }

    public @NotNull TrackerTableData getTrackerTableData() {
        return mTrackerTableData;
    }

    public @NotNull boolean getScrapeSupported() {
        return mScrapeSupported;
    }

    public @Nullable URL getScrapeUrl() {
        return mScrapeUrl;

    }

    public @NotNull boolean getScrapeAvailable() {
        return mScrapeAvailable;
    }

    public @Nullable Long getScrapeRefreshingInterval() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeRefreshingInterval;
    }

    public @Nullable Long getScrapeSeedersCount() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeSeedersCount;
    }

    public @Nullable Long getScrapeLeechersCount() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeLeechersCount;
    }

    public @Nullable Long getScrapeDownloadedCount() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeDownloadedCount;
    }

    public @Nullable String getScrapeFileName() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeFileName;
    }

    public @Nullable String getScrapeFailureReason() {
        if(!mScrapeAvailable)
            return null;

        return mScrapeFailureReason;
    }

    public @NotNull boolean getAnnounceAvailable() {
        return mAnnounceAvailable;
    }

    public @Nullable Long getAnnounceRefreshingInterval() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceRefreshingInterval;
    }

    public @Nullable URL getAnnounceUrl() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceUrl;
    }

    public @Nullable String getAnnounceFailureReason() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceFailureReason;
    }

    public @Nullable String getAnnounceWarningMessage() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceWarningMessage;
    }

    public @Nullable String getAnnounceTrackerId() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceTrackerId;
    }

    public @Nullable Long getAnnounceSeedersCount() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceSeedersCount;
    }

    public @Nullable Long getAnnounceLeechersCount() {
        if(!mAnnounceAvailable)
            return null;

        return mAnnounceLeechersCount;
    }

    /**
     * Task for the mScrapeRefreshingTimer timer.
     * @author Boyarkin Nikita.
     */
    private class ScrapeRefreshingRunnable extends TimerTask {
        @Override
        public void run() {
            final long refreshingIntervalBefore = mScrapeRefreshingInterval;

            // Make request to 'scrape' server and sets 'scrape' response data.
            refreshScrapeTrackerData();

            // Reset timer if it's changed.
            if(mScrapeRefreshingInterval != refreshingIntervalBefore) {
                mScrapeRefreshingTimer.cancel();
                mScrapeRefreshingTimer.purge();
                mScrapeRefreshingTimer.scheduleAtFixedRate(this, mScrapeRefreshingInterval, mScrapeRefreshingInterval);

                Log.d("Scrape '" + mScrapeUrl.toString() + "' timer task was reset to new interval " + mScrapeRefreshingInterval + " seconds.");
            }
        }
    }

    /**
     * Task for the mAnnounceRefreshingTimer timer.
     * @author Boyarkin Nikita.
     */
    private class AnnounceRefreshingRunnable extends TimerTask {
        @Override
        public void run() {
            final long refreshingIntervalBefore = mAnnounceRefreshingInterval;

            // Make request to 'announce' server, sets 'announce' response data and updates table fields.
            refreshAnnounceTrackerData();

            // Reset timer if it's changed.
            if(mAnnounceRefreshingInterval != refreshingIntervalBefore) {
                mAnnounceRefreshingTimer.cancel();
                mAnnounceRefreshingTimer.purge();
                mAnnounceRefreshingTimer.scheduleAtFixedRate(this, mAnnounceRefreshingInterval, mAnnounceRefreshingInterval);

                Log.d("Announce '" + mAnnounceUrl.toString() + "' timer task was reset to new interval " + mAnnounceRefreshingInterval + " seconds.");
            }
        }
    }
}
