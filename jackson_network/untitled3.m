% Программа для расчета нормирующей константы замкнутой СМО
clc;
clear all;
lo = 5; 		    % интенсивность поступления пакетов  	
L = 10;                         % число каналов
N = 30;                         % число заявок
M = 33;                         % число узлов
P = 1 / L;                      % вероятность передачи пакета по i-му каналу
F = 0.15;                      % вероятность неуспешной передачи пакета
u_kan=0.5;                   % интенсивность передачи пакетов по i-му каналу 
u_pr=8;                         % интенсивность обработки пакета в процессоре 
 
% Интенсивности обслуживания заявок в узлах СМО:
u = ones(1, M);
for i = 1 : M
    if i == 1                                                          % ИСТОЧНИК
        u(i) = N-(N-lo);                                           
    elseif i == 2                                                   % ПАМЯТЬ
        u(i) = lo;
    elseif i == 3                                                   % ПР
        u(i) = u_pr;
    elseif (i >= 4) && (i <= 4 + L - 1)                 % КАН
        u(i) = u_kan;
    elseif (i >= 4 + L) && (i <= 4 + 2 * L - 1)     % ТО
        u(i) = 2*u_kan^(-1);
    elseif (i >= 4 + 2 * L - 1) && (i <= 4 + 3 * L - 1)  % АСК
        u(i) =0.1*u_kan^(-1);
    end
end
 
% Относительные интенсивности потока заявок в СМО:
w = ones(1, M);
for i = 1 : M
    if i == 1                                                           % ИСТОЧНИК
        w(i) = 1;
    elseif i == 2                                                   % ПАМЯТЬ
        w(i) = 1;
    elseif i == 3                                                   % ПР
        w(i) = 1;
    elseif (i >= 4) && (i <= 4 + L - 1)                 % КАН
        w(i) = P/(1-F);
    elseif (i >= 4 + L) && (i <= 4 + 2 * L - 1)     % ТО
        w(i) = (F*P)/(1-F);
    elseif (i >= 4 + 2 * L - 1) && (i <= 4 + 3 * L - 1)  % АСК
        w(i) = P;
    end
end
 
% Начальные условия: (r = 2; k = 1):
G = ones(M, N + 1);
Z = ones(M, N + 1);
for r = 2 : M
    G(r, 1) = 1;
    Z(r, 1) = 1;
end
 
% Непосредственно алгоритм нахождения G:
for r = 1 : M
    for k = 1 : N
        sum = 0;  % временная переменная для накопления суммы
        for l = 0 : k
            mul = 1;  % временная переменная для накопления произведения
            for j = 1 : l
                if (r >= 4 + L) || (r == 2)  % j < m(r) [для многоканальных уз-лов]
                    mul = mul * j * u(r);
                else                                % j >= m(r) [для одноканальных узлов]
                    mul = mul * u(r);
                end
            end
            if r == 1
                Z(r, l + 1) = (w(r)^(l)) / mul;
                G(r, k + 1) = (w(r)^(l)) / mul;
            else
                Z(r, l + 1) = (w(r)^(l)) / mul;
                sum = sum + Z(r, l + 1) * G(r - 1, k - l + 1);
            end
        end
        %Записываем промежуточный результат в массив G:
        G(r,k+1)=sum;   
    end
end
 
% Вывод результатов:
disp('G(33, 30) = '); disp(G(33, 30));
disp('G(33, 31) = '); disp(G(33, 31));
 
%1
%Значит, вероятность отказа приема в буферную память:
P_otkaza=(G(33, 31) - 1/lo*G(33, 30))/G(33, 31);
disp('P(0, 30) = '); disp(P_otkaza);
 
%4
% Определим среднюю интенсивность потока пакетов, занимающих буф. память
Lamb_sred = 5 * (1 - P_otkaza);
disp('Lamb_sred = '); disp(Lamb_sred);
 
%2
% Определение среднего времени пребывания пакета в буферной памяти
% Сначала определим n_sred_1 (среднее число заявок в первом узле-источник) :
n_sred_1 = 0; 
for n = 1 : N
    n_sred_1 = n_sred_1 + (1/5)^n * G(33, N - n + 1);
end
n_sred_1 = n_sred_1 / G(33, 31);
disp('n_sred_1 = '); disp(n_sred_1);
% Теперь вычислим искомое время Т:
T_sred = (N - n_sred_1) / Lamb_sred;
disp('T_sred = '); disp(T_sred);
 
%3
% Определение среднего числа пакетов в маршрутизаторе:
n_sred_marsh = N - n_sred_1;
disp('n_sred_marsh = '); disp(n_sred_marsh);

