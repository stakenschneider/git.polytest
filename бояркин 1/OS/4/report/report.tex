\documentclass[14pt,a4paper,report]{report}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{listings} 
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{graphicx}
\hypersetup{
	colorlinks = true,
	linkcolor  = black
}

\usepackage{titlesec}
\titleformat{\chapter}
{\Large\bfseries} % format
{}                % label
{0pt}             % sep
{\huge}           % before-code


\DeclareCaptionFont{white}{\color{white}} 

% Listing description
\usepackage{listings} 
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{ 
	% Listing settings
	inputencoding = utf8,			
	extendedchars = \true, 
	keepspaces = true, 			  	 % Поддержка кириллицы и пробелов в комментариях
	language = C,            	 	 % Язык программирования (для подсветки)
	basicstyle = \small\sffamily, 	 % Размер и начертание шрифта для подсветки кода
	numbers = left,               	 % Где поставить нумерацию строк (слева\справа)
	numberstyle = \tiny,          	 % Размер шрифта для номеров строк
	stepnumber = 1,               	 % Размер шага между двумя номерами строк
	numbersep = 5pt,              	 % Как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor = \color{white}, % Цвет фона подсветки - используем \usepackage{color}
	showspaces = false,           	 % Показывать или нет пробелы специальными отступами
	showstringspaces = false,    	 % Показывать или нет пробелы в строках
	showtabs = false,           	 % Показывать или нет табуляцию в строках
	frame = single,              	 % Рисовать рамку вокруг кода
	tabsize = 2,                  	 % Размер табуляции по умолчанию равен 2 пробелам
	captionpos = t,             	 % Позиция заголовка вверху [t] или внизу [b] 
	breaklines = true,           	 % Автоматически переносить строки (да\нет)
	breakatwhitespace = false,   	 % Переносить строки только если есть пробел
	escapeinside = {\%*}{*)}      	 % Если нужно добавить комментарии в коде
}

\begin{document}

\def\contentsname{Содержание}

% Titlepage
\begin{titlepage}
	\begin{center}
		\textsc{Санкт-Петербургский Политехнический 
			Университет Петра Великого\\[5mm]
			Кафедра компьютерных систем и программных технологий}
		
		\vfill
		
		\textbf{Отчёт по лабораторной работе №4\\[3mm]
			Курс: «Операционные системы»\\[6mm]
			Тема: «Системное программирование UNIX»\\[35mm]
		}
	\end{center}
	
	\hfill
	\begin{minipage}{.5\textwidth}
		Выполнил студент:\\[2mm] 
		Бояркин Никита Сергеевич\\
		Группа: 43501/3\\[5mm]
		
		Проверил:\\[2mm] 
		Душутина Елена Владимировна
	\end{minipage}
	\vfill
	\begin{center}
		Санкт-Петербург\\ \the\year\ г.
	\end{center}
\end{titlepage}

% Contents
\tableofcontents
\clearpage

\chapter{Лабораторная работа №4}

\section{Цель работы}

Изучение средств межпроцессорного взаимодействия (IPC) в ОС Linux, таких как: надежные и ненадежные сигналы, именованные и неименованные  каналы, очереди сообщений, семафоры и разделяемая память, сокеты.

\section{Программа работы}

\subsubsection{Глава 1. Ненадежные сигналы}

\begin{enumerate}
	\item Составьте программу, позволяющую изменить диспозицию сигналов, а именно, установить: обработчик пользовательских сигналов SIGUSR1 и SIGUSR2, реакцию по умолчанию на сигнал SIGINT, игнорирование сигнала SIGCHLD. Породить процесс копию и уйти в ожидание. Обработчик сигналов должен содержать восстановление диспозиции и оповещение на экране о (удачно или неудачно) полученном сигнале и идентификаторе родительского процесса. Процесс-потомок, получив идентификатор родительского процесса, посылает процессу-родителю сигнал SIGUSR1 и извещает об удачной или неудачной отправке указанного сигнала. Остальные сигналы генерируютя из командной строки.
	\item Повторить эксперимент для других сигналов, порождаемых в разных файлах, а так же для потоков одного и разных процессов. 
\end{enumerate}

\subsubsection{Глава 2. Надежные сигналы}

\begin{enumerate}
	\item Создать программу, позволяющую продемонстрировать возможность отложенной обработки (временного блокирования) сигнала.
	\item Изменить обработчик так, чтобы отправка сигнала SIGINT производилась из обработчика функцией kill.
	\item Сравните обработчики надежных и ненадежных сигналов.
\end{enumerate}

\subsubsection{Глава 3. Сигналы POSIX реального времени}

\begin{enumerate}
	\item Провести эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени.
	\item Экспериментально подтвердить, что обработка равноприоритетных сигналов реального времени происходит в порядке очереди.
	\item Опытным путем определить наличие приоритетов сигналов реального времени.
\end{enumerate}

\subsubsection{Глава 4. Неименованные каналы}

\begin{enumerate}
	\item Организовать программу так, чтобы процесс-родитель создавал неименованный канал, создавал потомка, закрывал канал на запись и записывал в произвольный текстовый файл считываемую информацию. В процессе-потомке будет происходить считывание данных из файла и запись в канал.
\end{enumerate}

\subsubsection{Глава 5. Именованные каналы}

\begin{enumerate}
	\item Создать клиент-серверное приложение, демонстрирующее дуплексную передачу информации двумя однонаправленными именованными каналами между клиентом и сервером.
\end{enumerate}

\subsubsection{Глава 6. Очереди сообщений}

\begin{enumerate}
	\item Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очереди сообщений.
\end{enumerate}

\subsubsection{Глава 7. Семафоры и разделяемая память}

\begin{enumerate}
	\item Есть один процесс, выполняющий запись в разделяемую память и один процесс, выполняющий чтение из нее. Под чтением понимается извлечение данных из памяти. Программа должна обеспечить невозможность повторного чтения одних и тех же данных и невозможность перезаписи данных, т.е. новой записи, до тех пор, пока читатель не прочитает предыдущую. В таком варианте задания для синхронизации процессов достаточно двух семафоров.
	\item Добавление условия корректной работы нескольких читателей и нескольких писателей одновременно.
	\item Добавление не единичного буфера, а буфера некоторого размера. Тип буфера не имеет значения.
\end{enumerate}

\subsubsection{Глава 8. Сокеты}

\begin{enumerate}
	\item Реализовать TCP сервер, который прослушивает заданный порт. При приходе нового соединения создается новый поток для его обработки. Работа с клиентом организована как бесконечный цикл, в котором выполняется прием сообщений от клиента, вывод его на экран и пересылка обратно клиенту. Клиентская программа после установления с сервером так же в бесконечном цикле выполняет чтение ввода пользователя, пересылку его серверу и получение сообщения. Если была введена пустая строка, клиент завершает работу.
	\item Модифицировать предыдущую программу для работы с большим количеством клиентов. Провести эксперимент, определяющий при каком максимальнов количестве клиентов TCP сервер завершает работу.
	\item Выполнить аналогичные действия на основе протокола UDP, сравнить с очередями сообщений.
	\item Провести эксперимент, определяющий при каком максимальнов количестве клиентов UDP сервер завершает работу.
	\item Запустить клиент-серверные приложения на лабораторных компьютерах.
\end{enumerate}

\section{Характеристики системы}

Некоторая информация об операционной системе и текущем пользователе:

\lstinputlisting{listings/0.my.log}

Информация об операционной системе и текущем пользователе компьютера в лаборатории:

\lstinputlisting{listings/0.lab.log}

На домашнем и лабораторном компьютерах установлены реальные системы.

\clearpage

\section{Ход работы}

\subsection{Глава 1. Ненадежные сигналы}

\subsubsection{1.  Составьте программу, позволяющую изменить диспозицию сигналов, а именно, установить: обработчик пользовательских сигналов SIGUSR1 и SIGUSR2, реакцию по умолчанию на сигнал SIGINT, игнорирование сигнала SIGCHLD. Породить процесс копию и уйти в ожидание.}

Разработаем программу, выполняющую эти операции:

\lstinputlisting{listings/p1.1.c}

Результат выполнения программы:

\lstinputlisting{listings/p1.1.u1.log}

Процесс-потомок успешно послал родительскому процессу сигнал \emph{SIGUSR1}, что видно из результатов программы. После этого сигнал был успешно обработан.

Теперь из другого терминала отправим сигнал \emph{SIGUSR2}:

\lstinputlisting{listings/p1.1.u2.log}

Кроме сигнала \emph{SIGUSR1}, отправленного процессом-потомком, был принят также и сигнал \emph{SIGUSR2}, отправленный с терминала, о чем свидетельствует два вывода "Signal handle ...".

Убедимся, что сигнал \emph{SIGCHLD} игнорируется:

\lstinputlisting{listings/p1.1.ch.log}

После отправки сигнала \emph{SIGCHLD} со второго терминала, на первом терминале ничего не изменилось, что означает игнорирование сигнала.

Убедимся, что сигнал \emph{SIGINT} завершает программу:

\lstinputlisting{listings/p1.1.i.log}

После отправки сигнала \emph{SIGINT} со второго терминала, приложение завершилось, что соответствует действию сигнала по умолчанию.

Отправим два сигнала \emph{SIGUSR2}:

\lstinputlisting{listings/p1.1.r.log}

В результате видно, что первый сигнал был перехвачен обработчиков, а второй - нет. Это связано с тем, что после первого сигнала был восстановлен обработчик по умолчанию. 

\subsubsection{2.  Повторить эксперимент для других сигналов, порождаемых в разных файлах, а так же для потоков одного и разных процессов.}

Была создана программа, порождающая поток, в котором был создан обработчик сигнала \emph{SIGUSR2}. Обработчик сигнала содержит код, который должен завершать поток:

\lstinputlisting{listings/p1.2.1.c}

Результат работы программы:

\lstinputlisting{listings/p1.2.1.log}

Хоть привязка сигнала к обработчику и происходит в побочном потоке, пришедший сигнал завершил основной поток. Для контроля побочного потока необходимо использовать системный вызов \emph{pthread\_kill}.

Исправим программу, заменив функцию \emph{kill} на \emph{pthread\_kill}:

\lstinputlisting{listings/p1.2.2.c}

Результат работы программы:

\lstinputlisting{listings/p1.2.2.log}

Теперь, как и ожидалось, завершается побочный поток, а основной продолжает свою работу.

Напишем программу-родитель и программу-предок, с помощью который определить задержку между отправкой сигнала одним процессом и приемом его другим процессом.

Родительский процесс содержит обработчик сигнала с выводом времени:

\lstinputlisting{listings/p1.2.3.c}

Второй процесс содержит отправку сигнала с фиксацией времени (\emph{PID} передается через аргумент командной строки):

\lstinputlisting{listings/p1.2.3.pr.c}

Результат работы программы:

\lstinputlisting{listings/p1.2.3.log}

Фиксация времени отправления и доставки была произведена с точностю до шести знаков после запятой. Задержка между отправлением и приемом сигнала составила 0.42 миллисекунды, что является достаточно хорошим результатом по производительности. Из этого можно сделать вывод, что обмен данными между двумя процессами посредством сигналов - это быстрая операция, которую можно применять на практике.

\subsection{Глава 2. Надежные сигналы}

\subsubsection{1.  Провести эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени.}

Разработаем программу, которая организует очередь из сигналов, с помощью следующих функций:

\begin{verbatim}
int sigemptyset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
\end{verbatim}

Функция \emph{sigemptyset} инициализирует набор сигналов, указанный в \emph{set}, и очищает его от всех сигналов. Функция \emph{sigaddset} добавляет сигнал \emph{signum} к \emph{set}.

Системный вызов \emph{sigaction} используется для изменения действий процесса при получении соответствующего сигнала. Параметр \emph{signum} задает номер сигнала и может быть равен любому номеру, кроме \emph{SIGKILL} и \emph{SIGSTOP}. Если параметр \emph{act} не равен нулю, то новое действие, связянное с сигналом \emph{signum}, устанавливается соответственно \emph{act}. Если \emph{oldact} не равен нулю, то предыдущее действие записывается в \emph{oldact}.

\lstinputlisting{listings/p2.1.c}

Результат работы программы:

\lstinputlisting{listings/p2.1.log}

После отправки сигнала \emph{SIGUSR1} вывелось сообщение и началась десятисекундная задержка. Далее был отправлен сигнал прерывания \emph{SIGINT}, который был отправлен в очередь до ожидания завершения десятисекундной задержки.

\subsubsection{2.  Изменить обработчик так, чтобы отправка сигнала SIGINT производилась из обработчика функцией kill.}

Изменим программу таким образом, чтобы отправка сигнала SIGINT производилась из обработчика функцией kill:

\lstinputlisting{listings/p2.2.c}

Результат работы программы:

\lstinputlisting{listings/p2.2.log}

Как и в предыдущем случае \emph{SIGINT} попадает в очередь и ожидает завершения текущего обработчика.

\subsubsection{3.  Сравните обработчики надежных и ненадежных сигналов.}

Отличие надежных сигналов от ненадежных состоит в том, что обработчик ненадежного сигнала срабатывает только один раз, после чего его нужно заново перезапустить внутри самого обработчика. Если в этот момент придет новый сигнал, то он будет потерян, т.к. обработчик не перезапустился и сигнал не обработался. В то время как в надежных сигналах нет этой проблемы, и они могут быть обработаны в любой момент времени. 

\subsection{Глава 3. Сигналы POSIX реального времени}

В сигналах, стандартизированных в POSIX, существуют свои, отчасти досадные, ограничения. Например, нельзя быть уверенным в том, что множество сигналов, посланных поочередно, не будут слиты вместе.

Для обхода этого и других ограничений были созданы сигналы реального времени. Системы, которые поддерживают сигналы реального времени, поддерживают и стандартный механизм сигналов POSIX. Следует учитывать, что для достижения максимальной переносимости желательно применять POSIX-реализацию сигналов, используя сигналы реального времени лишь там, где возникает необходимость в их особых свойствах.

Точные номера сигналов реального времени не специфицированы, но можно быть уверенным в том, что все сигналы с номерами между SIGRTMIN и SIGRTMAX являются сигналами реального времени. Для работы с сигналами реального времени применяются те же самые системные вызовы, что и для работы с обычными сигналами.

\subsubsection{1-3.   Провести эксперимент, позволяющий определить возможность организации очереди для различных типов сигналов, обычных и реального времени. Экспериментально подтвердить, что обработка равноприоритетных сигналов реального времени происходит в порядке очереди. Опытным путем определить наличие приоритетов сигналов реального времени.}

Была разработана программа, которая организует очередь из определенного набора сигналов, которые могут прийти. Далее программа отправляет сама себе набор случайных сигналов из этого набора функцией \emph{raise}:

\lstinputlisting{listings/p3.1.c}

Результат работы программы:

\lstinputlisting{listings/p3.1.log}

Из результатов программы хорошо видно, что множества посланных и принятых сигналов отличаются, это связано с тем что обычные сигналы слились в один. Все сигналы были отправлены одновременно, однако они приходят в порядке очереди (по коду сигнала).

\subsection{Глава 4. Неименованные каналы}

Неименованный канал - это один из методов межпроцессного взаимодействия (\emph{IPC}) в операционной системе, который доступен связанным процессам — родительскому и дочернему. Представляется в виде области памяти на внешнем запоминающем устройстве, управляемой операционной системой, которая осуществляет выделение взаимодействующим процессам частей из этой области памяти для совместной работы. Организация данных в канале использует стратегию \emph{FIFO}, то есть информация, которая первой записана в канал, будет первой прочитана из канала.

Важное отличие неименованного канала от файла заключается в том, что прочитанная информация немедленно удаляется из него и не может быть прочитана повторно. 

\subsubsection{1.  Организовать программу так, чтобы процесс-родитель создавал неименованный канал, создавал потомка, закрывал канал на запись и записывал в произвольный текстовый файл считываемую информацию. В процессе-потомке будет происходить считывание данных из файла и запись в канал.}

Разработаем программу, в которой процесс-родитель создает неименованный канал и потомка, закрывает канал на запись и записывает полученный из канала текст в текстовый файл. Процесс-потомок производит чтение из файла и запись в файл:

\lstinputlisting{listings/p4.1.c}

Содержимое файла для чтения:

\lstinputlisting{listings/readfile.txt}

Результат работы программы:

\lstinputlisting{listings/p4.1.log}

Содержимое файла записи после выполнения программы:

\lstinputlisting{listings/writefile.txt}

Программа успешно создала неименованный канал, который в одностороннем порядке передал данные от процесса-потомка процессу-родителю.

Главное применение неименованных каналов в ОС UNIX - реализация конвейеров команд в интерпретаторах командной строки.

\subsection{Глава 5. Именованные каналы}

Именованные каналы во многом работают так же, как и обычные каналы, но все же имеют несколько заметных отличий.

\begin{itemize}
	\item Именованные каналы существуют в виде специального файла устройства в файловой системе.
	\item Процессы различного происхождения могут разделять данные через такой канал.
	\item Именованный канал остается в файловой системе для дальнейшего использования и после того, как весь ввод/вывод сделан.
\end{itemize}

\subsubsection{1.  Создать клиент-серверное приложение, демонстрирующее дуплексную передачу информации двумя однонаправленными именованными каналами между клиентом и сервером.}

Разработаем программу-сервер, создающую два именованных канала, используя функцию \emph{mknod}. Для установки прав для доступа на чтение и запись используем флаг права доступа с маской \emph{S\_FIFO | 0666}. Первый канал открывается на запись, а второй на чтение. Сервер передает клиенту имя файла для чтения и ожидает содержимое файла от клиента:

\lstinputlisting{listings/p5.1.se.c}

Программа клиент, в свою очередь, симметрично серверу открывает первый канал на чтение, а второй на запись. Клиент принимает имя файла для чтения и передает серверу его содержимое:

\lstinputlisting{listings/p5.1.cl.c}

Результат работы программ:

\lstinputlisting{listings/p5.1.log}

В фоновом режиме был запущен сервер и клиент. Сервер успешно передал клиенту имя файла, в свою очередь клиент успешно отправил на сервер его содержимое.

В процессе работы программ были созданы два файла:

\lstinputlisting{listings/p5.1.ls.log}

Файлы имеют тип \emph{p}, что означает, что это файлы именованного канала. Несмотря на записанные данные, размер этих файлов равен нулю. Это означает, что файл используется не как хранилище пересылаемых данных, а только для получения информации системой о них. Сами данные проходят через ядро ОС. Это делает невозможным использование каналов в межсетевом общении.

\subsection{Глава 6. Очереди сообщений}

Очереди сообщений представляют собой связный список в адресном пространстве ядра. Сообщения могут посылаться в очередь по порядку и доставаться из очереди несколькими разными путями. Каждая очередь сообщений однозначно определена идентификатором \emph{IPC}.

В общих чертах обмен сообщениями выглядит примерно так: один процесс помещает сообщение в очередь посредством неких системных вызовов, а любой другой процесс может прочитать его оттуда, при условии, что и процесс-источник сообщения и процесс-приемник сообщения используют один и тот же ключ для получения доступа к очереди.

Для определения некоторых констант, связанных с \emph{IPC}, воспользуемся командой \emph{ipcs} с ключем \emph{-l}:

\lstinputlisting{listings/p6.1.ipcs.l.log}

\subsubsection{1.  Создать клиент-серверное приложение, демонстрирующее передачу информации между процессами посредством очереди сообщений.}

Разработаем программу-сервер, которая создает очередь, используя функцию \emph{msgget} и ожидает прием сообщений от клиентов. Как только приходит сообщение от клиента, сразу же отсылается ответное сообщение с другим типом посылки. Обработчик сигнала прерывания необходим для корректного завершения очереди:

\lstinputlisting{listings/p6.1.se.c}

Программа-клиент симметрична серверной программе: она получает строку с консоли, отсылает ее серверу и получает ответ:

\lstinputlisting{listings/p6.1.cl.c}

Результат выполнения программ:

\lstinputlisting{listings/p6.1.log}

В этом эксперименте был запущен сервер, который успешно принимал сообщения от двух клиентов. После этого сервер был корректно отключен прерыванием с терминала, вызвался обработчик прерывания и очередь успешно удалилась. Клиенты узнали о недоступности сервера только после отправки последнего сообщения.

Команда ipcs выводит информацию о текущем состоянии IPC операционной системы. Воспользуемся ей для того, чтобы определить, находится ли только что созданная очередь в списке очередей:

\lstinputlisting{listings/p6.1.ipcs.log}

И действительно, в списке "Message Queues" появилась только что созданная очередь.

\subsection{Глава 7. Семафоры и разделяемая память}

Семафор — самый часто употребляемый метод для синхронизации потоков и для контролирования одновременного доступа множеством потоков/процессов к общей памяти (к примеру, глобальной переменной). Взаимодействие между процессами в случае с семафорами заключается в том, что процессы работают с одним и тем же набором данных и корректируют свое поведение в зависимости от этих данных.

\subsubsection{1. Есть один процесс, выполняющий запись в разделяемую память и один процесс, выполняющий чтение из нее. Под чтением понимается извлечение данных из памяти. Программа должна обеспечить невозможность повторного чтения одних и тех же данных и невозможность перезаписи данных, т.е. новой записи, до тех пор, пока читатель не прочитает предыдущую.}

Для реализации программы используем два бинарных семафора (ожидание освобождения ресурса - 1, последующий захват ресурса - 0), освобождение ресурса это также установка семафора в 1. Пару таких семафоров иногда называют разделенным бинарным семафором, поскольку в любой момент времени только один из них может иметь значение 1. При таком алгоритме работы оба процесса после выполнения своей задачи и освобождения одного из семафоров будут ждать освобождения другого семафора, которое произведет другой процесс, но только после выполнения своей работы. Таким образом повторное чтение или повторная запись стала невозможной.

В качестве общей памяти была использована структура \emph{Message} из предыдущего пункта.

Обработчик сигнала прерывания необходим для корректного завершения работы с семафорами.

Программа-сервер:

\lstinputlisting{listings/p7.1.1.se.c}

Программа-клиент:

\lstinputlisting{listings/p7.1.1.cl.c}

Результаты работы программ:

\lstinputlisting{listings/p7.1.1.log}

В этом эксперименте был запущен сервер, который успешно принимал сообщения от двух клиентов. После этого сервер был корректно отключен прерыванием с терминала, вызвался обработчик прерывания и семафоры успешно удалилась.


\subsubsection{2. Добавление условия корректной работы нескольких читателей и нескольких писателей одновременно.}

Добавление этого условия не приводит к необходимости использования дополнительных средств синхронизации. Теперь вместо одного процесса за каждый семафор будут конкурировать насколько процессов, но повторная запись и чтение все также невозможно, так как, чтобы очередной клиент работал нужно освобождение семафора, которое выполняется из процесса-читателя, и наоборот.


\subsubsection{3. Добавление не единичного буфера, а буфера некоторого размера. Тип буфера не имеет значения.}

Так как размер буфера не равен единице, то больше нет необходимости в чередовании операций чтения и записи, допустима ситуация нескольких записей подряд и после этого нескольких чтений. Нужно только следить, чтобы не было записи в уже заполненный буфер и не было чтения из пустого буфера.

Так как семафоры не бинарные, захватить их может сразу несколько процессов, то есть несколько процессов попадут в секцию записи или чтения. В этом случае, если операция записи или чтения не атомарная, может произойти нарушение нормальной работы программы, к примеру, несколько клиентов попытаются произвести запись в одну и ту же ячейку буфера. Таким образом, операции записи-чтения становятся критическими секциями, доступ к которым также необходимо синхронизировать. Для этого будет достаточно еще одного бинарного семафора, имеющего смысл разрешения доступа к памяти. Оба типа процессов должны захватывать его при попытке взаимодействия с памятью и освобождать после.

Порядок операций освобождения семафоров не важен, в то же время изменение порядка захвата семафоров может привести к взаимной блокировке процессов (dead lock).

Программа-сервер:

\lstinputlisting{listings/p7.1.3.se.c}

Программа-клиент:

\lstinputlisting{listings/p7.1.3.cl.c}

Результаты работы программ:

\lstinputlisting{listings/p7.1.3.cl1.log}

\lstinputlisting{listings/p7.1.3.cl2.log}

\lstinputlisting{listings/p7.1.3.cl3.log}

\lstinputlisting{listings/p7.1.3.se.log}

Программы клиенты записывают в буфер по десять значений. Каждый следующий клиент записывает в конец одного и того же буфера. Сервер считывает 25 чисел из тех 30, которые были добавлены тремя клиентами.

\subsection{Глава 8. Сокеты} 

Сокеты - название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью.

Следует различать клиентские и серверные сокеты. Клиентские сокеты можно сравнить с конечными аппаратами телефонной сети, а серверные — с коммутаторами. Клиентское приложение (например, браузер) использует только клиентские сокеты, а серверное (например, веб-сервер, которому браузер посылает запросы) — как клиентские, так и серверные сокеты.

Для создания сервера необходимо указать порт, который не должен быть занят. Для подключения клиента к серверу необходимо знать \emph{IP} адрес и порт. 

Для получения информации о состоянии сети используют утилиты \emph{ifconfig} и \emph{netstat}. 

Утилиту \emph{ifconfig} обычно используют для получения информации о внутренних и внешних \emph{IP} адресах:

\lstinputlisting{listings/p8.1.ifconf.log}

Утилиту \emph{netstat} обычно используют для получения информации о количестве подключений, количестве отправленных и пришедших пакетов: 

\lstinputlisting{listings/p8.1.netstat.log}

\subsubsection{1. Реализовать TCP сервер, который прослушивает заданный порт. При приходе нового соединения создается новый поток для его обработки.}

Разработаем программу \emph{TCP} сервера, который в бесконечном цикле ожидает подключения клиентов, создает для каждого из них новый поток, принимает сообщения клиента и отправляет их назад. Также реализована обработка сигнала прерывания для корректного завершения работы всех потоков и закрытия сокетов:

\lstinputlisting{listings/p8.1.se.cpp}

Клиент подключается к серверу, считывает сообщения из консоли и отправляет их серверу, после этого ожидает ответного сообщения сервера. Если было введено пустое сообщение, то клиент завершает работу:

\lstinputlisting{listings/p8.1.cl.c}

Протестируем клиент-серверное приложение:

\lstinputlisting{listings/p8.1.se.1.log}
\lstinputlisting{listings/p8.1.cl.1.log}

В первую очередь был запущен \emph{TCP} сервер. После этого к нему подключился клиент, отправил набор сообщений, сообщения вернулись назад клиенту. После ввода пустой строки клиент завершает работу и сервер сразу же узнает об этом.

Теперь рассмотрим подключение нескольких клиентов:

\lstinputlisting{listings/p8.1.se.2.log}
\lstinputlisting{listings/p8.1.cl.2.log}

Два клиента подключаются к \emph{TCP} серверу и отправляют ему сообщения. После этого сервер корректно отключается обрабатываемым сигналом прерывания. Клиенты мгновенно узнают о потере соединения, так как сервер выполнил \emph{shutdown} на все клиентские сокеты.

\subsubsection{2. Модифицировать программу для работы с большим количеством клиентов. Провести эксперимент, определяющий при каком максимальнов количестве клиентов TCP сервер завершает работу.}

Модифицируем программу-клиент таким образом, чтобы сообщения посылались не с консольного ввода, а из определенной константной строки. Сообщения присылаются один раз в несколько секунд и есть лимит на количество сообщений, после которого программа завершается:

\lstinputlisting{listings/p8.2.cl.c}

Был написан скрипт, который запускает заданное количество клиентов в фоновом режиме:

\lstinputlisting{listings/p8.2.sh}

Экспериментально было подтверждено, что сервер стабильно и правильно работает с количеством клиентов от 0 до 1024. На 1025 клиенте сервер начинает выдавать непредвиденные ошибки. Это связано с тем, что количество \emph{TCP} клиентов на один сервер ограничено константой \emph{\_\_FD\_SETSIZE}, определенной в файле \emph{typesizes.h}:

\lstinputlisting{listings/p8.2.fd.log}
 
В данной системе эта константа по умолчанию имеет размер 1024, однако ее можно изменить, определив директивой \emph{\#define} перед библиотекой сокетов. 

\subsubsection{3. Выполнить аналогичные действия на основе протокола UDP, сравнить с очередями сообщений.}

Разработаем программу \emph{UDP} сервера. В отличии от \emph{TCP}, соединение не устанавливается, поэтому отсутствуют функции \emph{listen} и \emph{accept}. Также не имеет большого смысла регистрировать отдельный поток для каждого клиента. Сервер в бесконечном цикле принимает сообщения от клиента и отправляет их назад:

\lstinputlisting{listings/p8.3.se.cpp}

Клиент подключается к серверу, считывает сообщения из консоли и отправляет их серверу, после этого ожидает ответного сообщения сервера. В отличие от \emph{TCP} отсутствует функция \emph{connect}, отвечающая за установление соединения. Если было введено пустое сообщение, то клиент завершает работу:

\lstinputlisting{listings/p8.3.cl.c}

Протестируем клиент-серверное приложение:

\lstinputlisting{listings/p8.3.se.log}
\lstinputlisting{listings/p8.3.cl.log}

В первую очередь был запущен сервер два клиента. Клиенты отправляют сообщения серверу, после чего сервер завершает свою работу. В связи с тем что отсутствует установление соединения \emph{UDP}, клиенты не узнают о том, что сервер отключился. Для обхода такой ситуации обычно с какой то очередностью серверу отправляется пакет, если от сервера пакет не пришел - значит сервер недоступен.

\subsubsection{4. Провести эксперимент, определяющий при каком максимальнов количестве клиентов UDP сервер завершает работу.}

Модифицируем программу-клиент таким образом, чтобы сообщения посылались не с консольного ввода, а из определенной константной строки. Сообщения присылаются один раз в несколько секунд и есть лимит на количество сообщений, после которого программа завершается:

\lstinputlisting{listings/p8.4.cl.c}

Был написан скрипт, который запускает заданное количество клиентов в фоновом режиме:

\lstinputlisting{listings/p8.4.sh}

Экспериментально было подтверждено, что сервер стабильно и правильно работает с количеством клиентов от 0 до 2300, на большем количестве производительности не хватило. С увеличением количества клиентов заметно начала снижаться производительность. Есть подозрения, что количество \emph{UDP} клиентов ограничено только производительностью компьютера.

\subsubsection{5. Запустить клиент-серверные приложения на лабораторных компьютерах.}

Проверим работу клиент-серверного приложения на лабораторных компьютерах. В первую очередь, узнаем \emph{IP} адреса двух лабораторных компьютеров, с помощью утилиты \emph{ifconfig}, описанной ранее. Далее скомпилируем сервер на первом компьютере и клиент на втором компьютере. Программа клиент принимает аргументами командной строки \emph{IP} и порт сервера:

\lstinputlisting{listings/p8.5.se.log}

\lstinputlisting{listings/p8.5.cl.log}

Как и ожидалось, эксперименты завершились успешно. Сообщения корректно передались серверу и наоборот.

\section{Вывод}

В ходе работы, были рассмотрены основные способы межпроцессного взаимодействия в ОС Unix: надежные и ненадежные сигналы, именованные и неименованные каналы, очереди сообщений, семафоры и разделяемая память, сокеты.

Именованные и неименованные каналы позволяют организовать однонаправленную передачу по типу \emph{FIFO}. Для дуплексной передачи между двумя процессами используют два разнонаправленных канала. Из-за того, что в передаче данных задействовано ядро ОС, взаимодействие удаленных процессов через сеть с помощью каналов невозможно.

Время доставки сообщения в очереди сравнимо с временем доставки сигнала, однако сообщение несет обычно больше информации, чем сигнал. С помощью очереди сообщений проще организовать асинхронный обмен данными между процессами, чем с помощью каналов.

Разделяемая память и семафоры обычно используются вместе. Семафоры позволяют синхронизировать доступ к разделяемому ресурсу. Самые часто используемые семафоры - битовые семафоры (мьютексы), которые активно используются для синхронизации потоков.

Сокеты - это универсальное средство \emph{IPC}, которое является универсальным. Это означает, что его можно использовать также и для передачи данных между двумя разными компьютерами, подключенными к общей сети. Сокеты так или иначе реализованы на большинстве ОС, и большая часть сетевых  приложений использует эту технологию.

\clearpage

\section{Список литературы}

\begin{itemize}
	
	\item Межпроцессовые коммуникации LINUX [Электронный ресурс]. — URL: \href{http://citforum.ru/operating_systems/linux_pg/lpg_02.shtml}{http://citforum.ru/operating\linebreak \_systems/linux\_pg/lpg\_02.shtml} (дата обращения 03.12.2016).
	
	\item Работа с сигналами в Linux [Электронный ресурс]. — URL: \href{https://www.ibm.com/developerworks/ru/library/l-signals_2/}{https://www.ibm.com/developerworks/ru/\linebreak library/l-signals\_2/} (дата обращения 03.12.2016).
	
	\item Мануал sigaction [Электронный ресурс]. — URL: \href{https://www.opennet.ru/man.shtml?topic=sigaction&category=2&russian=0}{https://www.opennet.ru/man.shtml?topic=sigaction\&\linebreak category=2\&russian=0} (дата обращения 03.12.2016).
	
	\item Мануал sigemptyset [Электронный ресурс]. — URL: \href{https://www.opennet.ru/man.shtml?topic=sigemptyset&category=3&russian=0}{https://www.opennet.ru/man.shtml?topic=sigemptyset\&\linebreak category=3\&russian=0} (дата обращения 03.12.2016).
	
	\item Работа с сокетами [Электронный ресурс]. — URL: \href{http://citforum.ru/programming/unix/sockets/}{http://citforum.ru/programming/unix/sockets/} (дата обращения 03.12.2016).
	
\end{itemize}

\end{document}